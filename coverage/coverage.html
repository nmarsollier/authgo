
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>docs: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/nmarsollier/authgo/docs/docs.go (100.0%)</option>
				
				<option value="file1">github.com/nmarsollier/authgo/internal/engine/db/collection.go (0.0%)</option>
				
				<option value="file2">github.com/nmarsollier/authgo/internal/engine/db/database.go (0.0%)</option>
				
				<option value="file3">github.com/nmarsollier/authgo/internal/engine/db/errors.go (0.0%)</option>
				
				<option value="file4">github.com/nmarsollier/authgo/internal/engine/di/injector.go (30.9%)</option>
				
				<option value="file5">github.com/nmarsollier/authgo/internal/engine/env/env.go (90.0%)</option>
				
				<option value="file6">github.com/nmarsollier/authgo/internal/engine/errs/rest.go (100.0%)</option>
				
				<option value="file7">github.com/nmarsollier/authgo/internal/engine/errs/validation.go (50.0%)</option>
				
				<option value="file8">github.com/nmarsollier/authgo/internal/engine/log/factory.go (0.0%)</option>
				
				<option value="file9">github.com/nmarsollier/authgo/internal/engine/log/logger.go (0.0%)</option>
				
				<option value="file10">github.com/nmarsollier/authgo/internal/engine/rbt/rabbit_channel.go (0.0%)</option>
				
				<option value="file11">github.com/nmarsollier/authgo/internal/graph/model/federation.go (0.0%)</option>
				
				<option value="file12">github.com/nmarsollier/authgo/internal/graph/model/models_gen.go (0.0%)</option>
				
				<option value="file13">github.com/nmarsollier/authgo/internal/graph/model/schema.go (0.0%)</option>
				
				<option value="file14">github.com/nmarsollier/authgo/internal/graph/resolvers/change_password.go (0.0%)</option>
				
				<option value="file15">github.com/nmarsollier/authgo/internal/graph/resolvers/current_user.go (0.0%)</option>
				
				<option value="file16">github.com/nmarsollier/authgo/internal/graph/resolvers/disable.go (0.0%)</option>
				
				<option value="file17">github.com/nmarsollier/authgo/internal/graph/resolvers/enable.go (0.0%)</option>
				
				<option value="file18">github.com/nmarsollier/authgo/internal/graph/resolvers/find_all.go (0.0%)</option>
				
				<option value="file19">github.com/nmarsollier/authgo/internal/graph/resolvers/find_user.go (0.0%)</option>
				
				<option value="file20">github.com/nmarsollier/authgo/internal/graph/resolvers/grant.go (0.0%)</option>
				
				<option value="file21">github.com/nmarsollier/authgo/internal/graph/resolvers/revoke.go (0.0%)</option>
				
				<option value="file22">github.com/nmarsollier/authgo/internal/graph/resolvers/sign_in.go (0.0%)</option>
				
				<option value="file23">github.com/nmarsollier/authgo/internal/graph/resolvers/sign_out.go (0.0%)</option>
				
				<option value="file24">github.com/nmarsollier/authgo/internal/graph/resolvers/sign_up.go (0.0%)</option>
				
				<option value="file25">github.com/nmarsollier/authgo/internal/graph/resolvers/user_mapper.go (0.0%)</option>
				
				<option value="file26">github.com/nmarsollier/authgo/internal/graph/schema/entity.resolvers.go (0.0%)</option>
				
				<option value="file27">github.com/nmarsollier/authgo/internal/graph/schema/schema.resolvers.go (0.0%)</option>
				
				<option value="file28">github.com/nmarsollier/authgo/internal/graph/server.go (0.0%)</option>
				
				<option value="file29">github.com/nmarsollier/authgo/internal/graph/tools/auth.go (0.0%)</option>
				
				<option value="file30">github.com/nmarsollier/authgo/internal/graph/tools/context.go (0.0%)</option>
				
				<option value="file31">github.com/nmarsollier/authgo/internal/graph/tools/logger.go (0.0%)</option>
				
				<option value="file32">github.com/nmarsollier/authgo/internal/rabbit/send_logout.go (66.7%)</option>
				
				<option value="file33">github.com/nmarsollier/authgo/internal/rest/get_user_signout.go (100.0%)</option>
				
				<option value="file34">github.com/nmarsollier/authgo/internal/rest/get_users_all.go (14.3%)</option>
				
				<option value="file35">github.com/nmarsollier/authgo/internal/rest/get_users_current.go (12.5%)</option>
				
				<option value="file36">github.com/nmarsollier/authgo/internal/rest/post_users_id_disable.go (20.0%)</option>
				
				<option value="file37">github.com/nmarsollier/authgo/internal/rest/post_users_id_enable.go (20.0%)</option>
				
				<option value="file38">github.com/nmarsollier/authgo/internal/rest/post_users_id_grant.go (10.0%)</option>
				
				<option value="file39">github.com/nmarsollier/authgo/internal/rest/post_users_id_revoke.go (10.0%)</option>
				
				<option value="file40">github.com/nmarsollier/authgo/internal/rest/post_users_password.go (10.0%)</option>
				
				<option value="file41">github.com/nmarsollier/authgo/internal/rest/post_users_signin.go (9.1%)</option>
				
				<option value="file42">github.com/nmarsollier/authgo/internal/rest/post_users_signup.go (9.1%)</option>
				
				<option value="file43">github.com/nmarsollier/authgo/internal/rest/router.go (83.3%)</option>
				
				<option value="file44">github.com/nmarsollier/authgo/internal/rest/server/admin_middleware.go (0.0%)</option>
				
				<option value="file45">github.com/nmarsollier/authgo/internal/rest/server/auth_middleware.go (100.0%)</option>
				
				<option value="file46">github.com/nmarsollier/authgo/internal/rest/server/di_middleware.go (52.9%)</option>
				
				<option value="file47">github.com/nmarsollier/authgo/internal/rest/server/engine.go (20.0%)</option>
				
				<option value="file48">github.com/nmarsollier/authgo/internal/rest/server/error_handler.go (38.5%)</option>
				
				<option value="file49">github.com/nmarsollier/authgo/internal/rest/server/header_utils.go (75.0%)</option>
				
				<option value="file50">github.com/nmarsollier/authgo/internal/token/cache.go (41.7%)</option>
				
				<option value="file51">github.com/nmarsollier/authgo/internal/token/repository.go (57.9%)</option>
				
				<option value="file52">github.com/nmarsollier/authgo/internal/token/schema.go (77.8%)</option>
				
				<option value="file53">github.com/nmarsollier/authgo/internal/token/service.go (48.6%)</option>
				
				<option value="file54">github.com/nmarsollier/authgo/internal/usecases/invalidate_token.go (72.7%)</option>
				
				<option value="file55">github.com/nmarsollier/authgo/internal/usecases/sign_in.go (0.0%)</option>
				
				<option value="file56">github.com/nmarsollier/authgo/internal/usecases/sign_up.go (0.0%)</option>
				
				<option value="file57">github.com/nmarsollier/authgo/internal/user/dto.go (0.0%)</option>
				
				<option value="file58">github.com/nmarsollier/authgo/internal/user/repository.go (0.0%)</option>
				
				<option value="file59">github.com/nmarsollier/authgo/internal/user/schema.go (0.0%)</option>
				
				<option value="file60">github.com/nmarsollier/authgo/internal/user/service.go (0.0%)</option>
				
				<option value="file61">github.com/nmarsollier/authgo/main.go (0.0%)</option>
				
				<option value="file62">github.com/nmarsollier/authgo/test/engine/db/tools.go (60.0%)</option>
				
				<option value="file63">github.com/nmarsollier/authgo/test/engine/di/test_injector.go (45.0%)</option>
				
				<option value="file64">github.com/nmarsollier/authgo/test/engine/log/tools.go (100.0%)</option>
				
				<option value="file65">github.com/nmarsollier/authgo/test/mock/cache_mocks.go (0.0%)</option>
				
				<option value="file66">github.com/nmarsollier/authgo/test/mock/injector_mocks.go (0.0%)</option>
				
				<option value="file67">github.com/nmarsollier/authgo/test/mock/invalidate_token_mocks.go (0.0%)</option>
				
				<option value="file68">github.com/nmarsollier/authgo/test/mock/logger_mocks.go (77.3%)</option>
				
				<option value="file69">github.com/nmarsollier/authgo/test/mock/mongo_collection_mocks.go (32.1%)</option>
				
				<option value="file70">github.com/nmarsollier/authgo/test/mock/rabbit_channel_mocks.go (100.0%)</option>
				
				<option value="file71">github.com/nmarsollier/authgo/test/mock/send_logout_mocks.go (0.0%)</option>
				
				<option value="file72">github.com/nmarsollier/authgo/test/mock/sign_in_mocks.go (0.0%)</option>
				
				<option value="file73">github.com/nmarsollier/authgo/test/mock/sign_up_mocks.go (0.0%)</option>
				
				<option value="file74">github.com/nmarsollier/authgo/test/mock/token_repository_mocks.go (0.0%)</option>
				
				<option value="file75">github.com/nmarsollier/authgo/test/mock/token_service_mocks.go (0.0%)</option>
				
				<option value="file76">github.com/nmarsollier/authgo/test/mock/user_repository_mocks.go (0.0%)</option>
				
				<option value="file77">github.com/nmarsollier/authgo/test/mock/user_service_mocks.go (0.0%)</option>
				
				<option value="file78">github.com/nmarsollier/authgo/test/rabbit/tools.go (100.0%)</option>
				
				<option value="file79">github.com/nmarsollier/authgo/test/rest/assertions.go (80.0%)</option>
				
				<option value="file80">github.com/nmarsollier/authgo/test/rest/router.go (100.0%)</option>
				
				<option value="file81">github.com/nmarsollier/authgo/test/rest/tools.go (45.5%)</option>
				
				<option value="file82">github.com/nmarsollier/authgo/test/token/tools.go (70.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// Package docs Code generated by swaggo/swag. DO NOT EDIT
package docs

import "github.com/swaggo/swag"

const docTemplate = `{
    "schemes": {{ marshal .Schemes }},
    "swagger": "2.0",
    "info": {
        "description": "{{escape .Description}}",
        "title": "{{.Title}}",
        "contact": {
            "name": "Nestor Marsollier",
            "email": "nmarsollier@gmail.com"
        },
        "version": "{{.Version}}"
    },
    "host": "{{.Host}}",
    "basePath": "{{.BasePath}}",
    "paths": {
        "/rabbit/logout": {
            "put": {
                "description": "SendLogout envía un broadcast a rabbit con logout. Esto no es Rest es RabbitMQ.",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Rabbit"
                ],
                "summary": "Mensage Rabbit",
                "parameters": [
                    {
                        "description": "Token deshabilitado",
                        "name": "body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/rabbit.message"
                        }
                    }
                ],
                "responses": {}
            }
        },
        "/user/password": {
            "post": {
                "description": "Cambia la contraseña del usuario actual.",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Seguridad"
                ],
                "summary": "Cambiar Password",
                "parameters": [
                    {
                        "description": "Passwords",
                        "name": "body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/rest.changePasswordBody"
                        }
                    },
                    {
                        "type": "string",
                        "description": "Bearer {token}",
                        "name": "Authorization",
                        "in": "header",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "No Content"
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/errs.ValidationErr"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/server.ErrorData"
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "$ref": "#/definitions/server.ErrorData"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/server.ErrorData"
                        }
                    }
                }
            }
        },
        "/users/:userID/grant": {
            "post": {
                "description": "Otorga permisos al usuario indicado, el usuario logueado tiene que tener permiso \"admin\".",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Seguridad"
                ],
                "summary": "Haiblitar permisos",
                "parameters": [
                    {
                        "type": "string",
                        "description": "ID del usuario a habilitar permiso",
                        "name": "userId",
                        "in": "path",
                        "required": true
                    },
                    {
                        "type": "string",
                        "description": "Bearer {token}",
                        "name": "Authorization",
                        "in": "header",
                        "required": true
                    },
                    {
                        "description": "Permisos a Habilitar",
                        "name": "body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/rest.grantPermissionBody"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "No Content"
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/errs.ValidationErr"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/server.ErrorData"
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "$ref": "#/definitions/server.ErrorData"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/server.ErrorData"
                        }
                    }
                }
            }
        },
        "/users/:userID/revoke": {
            "post": {
                "description": "Quita permisos al usuario indicado, el usuario logueado tiene que tener permiso \"admin\".",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Seguridad"
                ],
                "summary": "Quitar permisos",
                "parameters": [
                    {
                        "type": "string",
                        "description": "ID del usuario a quitar permiso",
                        "name": "userId",
                        "in": "path",
                        "required": true
                    },
                    {
                        "type": "string",
                        "description": "Bearer {token}",
                        "name": "Authorization",
                        "in": "header",
                        "required": true
                    },
                    {
                        "description": "Permisos a Qutiar",
                        "name": "body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/rest.grantPermissionBody"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "No Content"
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/errs.ValidationErr"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/server.ErrorData"
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "$ref": "#/definitions/server.ErrorData"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/server.ErrorData"
                        }
                    }
                }
            }
        },
        "/users/:userId/disable": {
            "post": {
                "description": "Deshabilita un usuario en el sistema. El usuario logueado debe tener permisos \"admin\".",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Seguridad"
                ],
                "summary": "Deshabilitar Usuario",
                "parameters": [
                    {
                        "type": "string",
                        "description": "ID del usuario a deshabilitar",
                        "name": "userId",
                        "in": "path",
                        "required": true
                    },
                    {
                        "type": "string",
                        "description": "Bearer {token}",
                        "name": "Authorization",
                        "in": "header",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "No Content"
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/errs.ValidationErr"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/server.ErrorData"
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "$ref": "#/definitions/server.ErrorData"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/server.ErrorData"
                        }
                    }
                }
            }
        },
        "/users/:userId/enable": {
            "post": {
                "description": "Habilita un usuario en el sistema. El usuario logueado debe tener permisos \"admin\".",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Seguridad"
                ],
                "summary": "Enable User",
                "parameters": [
                    {
                        "type": "string",
                        "description": "ID del usuario a habilitar",
                        "name": "userId",
                        "in": "path",
                        "required": true
                    },
                    {
                        "type": "string",
                        "description": "Bearer {token}",
                        "name": "Authorization",
                        "in": "header",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "No Content"
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/errs.ValidationErr"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/server.ErrorData"
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "$ref": "#/definitions/server.ErrorData"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/server.ErrorData"
                        }
                    }
                }
            }
        },
        "/users/all": {
            "get": {
                "description": "Obtiene información de todos los usuarios. El usuario logueado debe tener permisos \"admin\".",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Seguridad"
                ],
                "summary": "Listar Usuarios",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Bearer {token}",
                        "name": "Authorization",
                        "in": "header",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Users",
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/user.UserData"
                            }
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/errs.ValidationErr"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/server.ErrorData"
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "$ref": "#/definitions/server.ErrorData"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/server.ErrorData"
                        }
                    }
                }
            }
        },
        "/users/current": {
            "get": {
                "description": "Obtiene información del usuario actual.",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Seguridad"
                ],
                "summary": "Usuario Actual",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Bearer {token}",
                        "name": "Authorization",
                        "in": "header",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "User data",
                        "schema": {
                            "$ref": "#/definitions/user.UserData"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/errs.ValidationErr"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/server.ErrorData"
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "$ref": "#/definitions/server.ErrorData"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/server.ErrorData"
                        }
                    }
                }
            }
        },
        "/users/signin": {
            "post": {
                "description": "Loguea un usuario en el sistema.",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Seguridad"
                ],
                "summary": "Login",
                "parameters": [
                    {
                        "description": "Sign in information",
                        "name": "body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/usecases.SignInRequest"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "User Token",
                        "schema": {
                            "$ref": "#/definitions/usecases.TokenResponse"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/errs.ValidationErr"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/server.ErrorData"
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "$ref": "#/definitions/server.ErrorData"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/server.ErrorData"
                        }
                    }
                }
            }
        },
        "/users/signout": {
            "get": {
                "description": "Desloguea un usuario en el sistema, invalida el token.",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Seguridad"
                ],
                "summary": "Logout",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Bearer {token}",
                        "name": "Authorization",
                        "in": "header",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "No Content"
                    },
                    "500": {
                        "description": "Error response",
                        "schema": {
                            "$ref": "#/definitions/server.ErrorData"
                        }
                    }
                }
            }
        },
        "/users/signup": {
            "post": {
                "description": "Registra un nuevo usuario en el sistema.",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Seguridad"
                ],
                "summary": "Registrar Usuario",
                "parameters": [
                    {
                        "description": "Informacion de ususario",
                        "name": "body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/usecases.SignUpRequest"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "User Token",
                        "schema": {
                            "$ref": "#/definitions/usecases.TokenResponse"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/errs.ValidationErr"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/server.ErrorData"
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "$ref": "#/definitions/server.ErrorData"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/server.ErrorData"
                        }
                    }
                }
            }
        }
    },
    "definitions": {
        "errs.ValidationErr": {
            "type": "object",
            "properties": {
                "messages": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/errs.errField"
                    }
                }
            }
        },
        "errs.errField": {
            "type": "object",
            "properties": {
                "message": {
                    "type": "string"
                },
                "path": {
                    "type": "string"
                }
            }
        },
        "rabbit.message": {
            "type": "object",
            "properties": {
                "correlation_id": {
                    "type": "string",
                    "example": "123123"
                },
                "message": {
                    "type": "string",
                    "example": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ0b2tlbklEIjoiNjZiNjBlYzhlMGYzYzY4OTUzMzJlOWNmIiwidXNlcklEIjoiNjZhZmQ3ZWU4YTBhYjRjZjQ0YTQ3NDcyIn0.who7upBctOpmlVmTvOgH1qFKOHKXmuQCkEjMV3qeySg"
                }
            }
        },
        "rest.changePasswordBody": {
            "type": "object",
            "required": [
                "currentPassword",
                "newPassword"
            ],
            "properties": {
                "currentPassword": {
                    "type": "string",
                    "maxLength": 100,
                    "minLength": 1
                },
                "newPassword": {
                    "type": "string",
                    "maxLength": 100,
                    "minLength": 1
                }
            }
        },
        "rest.grantPermissionBody": {
            "type": "object",
            "required": [
                "permissions"
            ],
            "properties": {
                "permissions": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                }
            }
        },
        "server.ErrorData": {
            "type": "object",
            "properties": {
                "error": {
                    "type": "string"
                }
            }
        },
        "usecases.SignInRequest": {
            "type": "object",
            "required": [
                "login",
                "password"
            ],
            "properties": {
                "login": {
                    "type": "string"
                },
                "password": {
                    "type": "string"
                }
            }
        },
        "usecases.SignUpRequest": {
            "type": "object",
            "required": [
                "login",
                "name",
                "password"
            ],
            "properties": {
                "login": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "password": {
                    "type": "string"
                }
            }
        },
        "usecases.TokenResponse": {
            "type": "object",
            "properties": {
                "token": {
                    "type": "string"
                }
            }
        },
        "user.UserData": {
            "type": "object",
            "properties": {
                "enabled": {
                    "type": "boolean"
                },
                "id": {
                    "type": "string"
                },
                "login": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "permissions": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                }
            }
        }
    }
}`

// SwaggerInfo holds exported Swagger Info so clients can modify it
var SwaggerInfo = &amp;swag.Spec{
        Version:          "1.0",
        Host:             "localhost:3000",
        BasePath:         "/v1",
        Schemes:          []string{},
        Title:            "AuthGo",
        Description:      "Microservicio de Autentificación.",
        InfoInstanceName: "swagger",
        SwaggerTemplate:  docTemplate,
        LeftDelim:        "{{",
        RightDelim:       "}}",
}

func init() <span class="cov8" title="1">{
        swag.Register(SwaggerInfo.InstanceName(), SwaggerInfo)
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package db

import (
        "context"

        "github.com/nmarsollier/authgo/internal/engine/log"
        "go.mongodb.org/mongo-driver/bson"
        "go.mongodb.org/mongo-driver/mongo"
)

type Collection interface {
        FindOne(ctx context.Context, filter interface{}, v interface{}) error

        InsertOne(ctx context.Context, document interface{}) (id interface{}, error error)

        UpdateOne(ctx context.Context, filter interface{}, update interface{}) (modified int64, error error)

        Find(ctx context.Context, filter interface{}) (cur Cursor, err error)
}

func NewCollection(
        log log.LogRusEntry,
        database *mongo.Database,
        collectionName string,
        indexes ...string,
) (col Collection, err error) <span class="cov0" title="0">{
        collection := database.Collection(collectionName)

        for _, index := range indexes </span><span class="cov0" title="0">{
                _, err = collection.Indexes().CreateOne(
                        context.Background(),
                        mongo.IndexModel{
                                Keys:    bson.M{index: 1},
                                Options: nil,
                        },
                )
                if err != nil </span><span class="cov0" title="0">{
                        log.Info(err)
                        return nil, err
                }</span>
        }
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                log.Error(err)
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;mongoCollection{
                collection: collection,
        }, nil</span>
}

type mongoCollection struct {
        collection *mongo.Collection
}

func (m *mongoCollection) FindOne(ctx context.Context, filter interface{}, v interface{}) error <span class="cov0" title="0">{
        if err := m.collection.FindOne(context.Background(), filter).Decode(v); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *mongoCollection) InsertOne(ctx context.Context, document interface{}) (id interface{}, error error) <span class="cov0" title="0">{
        insertedId, err := m.collection.InsertOne(context.Background(), document)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return insertedId.InsertedID, nil</span>
}

func (m *mongoCollection) UpdateOne(ctx context.Context, filter interface{}, update interface{}) (modified int64, error error) <span class="cov0" title="0">{
        insertedId, err := m.collection.UpdateOne(context.Background(), filter, update)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov0" title="0">return insertedId.ModifiedCount, nil</span>
}

func (m *mongoCollection) Find(ctx context.Context, filter interface{}) (cur Cursor, err error) <span class="cov0" title="0">{
        cursor, err := m.collection.Find(context.Background(), filter)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return NewCursor(cursor), nil</span>
}

type Cursor interface {
        Close(ctx context.Context) error
        Next(ctx context.Context) bool
        Decode(val interface{}) error
}

func NewCursor(cursor *mongo.Cursor) Cursor <span class="cov0" title="0">{
        return &amp;mongoCursor{
                cursor: cursor,
        }
}</span>

type mongoCursor struct {
        cursor *mongo.Cursor
}

func (c *mongoCursor) Close(ctx context.Context) error <span class="cov0" title="0">{
        return c.cursor.Close(ctx)
}</span>

func (c *mongoCursor) Next(ctx context.Context) bool <span class="cov0" title="0">{
        return c.cursor.Next(ctx)
}</span>
func (c *mongoCursor) Decode(val interface{}) error <span class="cov0" title="0">{
        return c.cursor.Decode(val)
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package db

import (
        "context"

        "go.mongodb.org/mongo-driver/mongo"
        "go.mongodb.org/mongo-driver/mongo/options"
)

// NewDatabase the mongo database
func NewDatabase(
        mongoUrl string,
        name string,
) (*mongo.Database, error) <span class="cov0" title="0">{
        clientOptions := options.Client().ApplyURI(mongoUrl)

        client, err := mongo.Connect(context.TODO(), clientOptions)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">database := client.Database(name)

        return database, nil</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package db

import (
        "go.mongodb.org/mongo-driver/mongo"
)

// IsDbUniqueKeyError retorna true si el error es de indice único
func IsDbUniqueKeyError(err error) bool <span class="cov0" title="0">{
        if wErr, ok := err.(mongo.WriteException); ok </span><span class="cov0" title="0">{
                for i := 0; i &lt; len(wErr.WriteErrors); i++ </span><span class="cov0" title="0">{
                        if wErr.WriteErrors[i].Code == 11000 </span><span class="cov0" title="0">{
                                return true
                        }</span>
                }
        }
        <span class="cov0" title="0">return false</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package di

import (
        "github.com/nmarsollier/authgo/internal/engine/db"
        "github.com/nmarsollier/authgo/internal/engine/env"
        "github.com/nmarsollier/authgo/internal/engine/log"
        "github.com/nmarsollier/authgo/internal/engine/rbt"
        "github.com/nmarsollier/authgo/internal/rabbit"
        "github.com/nmarsollier/authgo/internal/token"
        "github.com/nmarsollier/authgo/internal/usecases"
        "github.com/nmarsollier/authgo/internal/user"
        "go.mongodb.org/mongo-driver/mongo"
        "go.mongodb.org/mongo-driver/x/mongo/driver/topology"
)

// Singletons
var tokenCache token.TokenCache
var tokenCollection db.Collection
var userCollection db.Collection
var database *mongo.Database

type Injector interface {
        Database() *mongo.Database
        InvalidateTokenUseCase() usecases.InvalidateTokenUseCase
        Logger() log.LogRusEntry
        RabbitChannel() rbt.RabbitChannel
        SendLogoutService() rabbit.SendLogoutService
        SignInUseCase() usecases.SignInUseCase
        SignUpUseCase() usecases.SignUpUseCase
        TokenCache() token.TokenCache
        TokenCollection() db.Collection
        TokenRepository() token.TokenRepository
        TokenService() token.TokenService
        UserCollection() db.Collection
        UserRepository() user.UserRepository
        UserService() user.UserService
}

type Deps struct {
        CurrInvalidateTokenUseCase usecases.InvalidateTokenUseCase
        CurrLog                    log.LogRusEntry
        CurrSendLogoutService      rabbit.SendLogoutService
        CurrSignInUseCase          usecases.SignInUseCase
        CurrSignUpUseCase          usecases.SignUpUseCase
        CurrTokenRepository        token.TokenRepository
        CurrTokenService           token.TokenService
        CurrUserRepository         user.UserRepository
        CurrUserService            user.UserService
        CurrRabbitChannel          rbt.RabbitChannel
        CurrTokenCache             token.TokenCache
        CurrTokenCollection        db.Collection
        CurrUserCollection         db.Collection
        CurrDatabase               *mongo.Database
}

func NewInjector(log log.LogRusEntry) Injector <span class="cov0" title="0">{
        return &amp;Deps{
                CurrLog: log,
        }
}</span>

func (i *Deps) Database() *mongo.Database <span class="cov0" title="0">{
        if i.CurrDatabase != nil </span><span class="cov0" title="0">{
                return i.CurrDatabase
        }</span>

        <span class="cov0" title="0">if database != nil </span><span class="cov0" title="0">{
                return database
        }</span>

        <span class="cov0" title="0">database, err := db.NewDatabase(env.Get().MongoURL, "authgo")
        if err != nil </span><span class="cov0" title="0">{
                i.CurrLog.Fatal(err)
                return nil
        }</span>

        <span class="cov0" title="0">return database</span>
}

func (i *Deps) Logger() log.LogRusEntry <span class="cov8" title="1">{
        return i.CurrLog
}</span>

func (i *Deps) TokenService() token.TokenService <span class="cov8" title="1">{
        if i.CurrTokenService != nil </span><span class="cov8" title="1">{
                return i.CurrTokenService
        }</span>

        <span class="cov8" title="1">i.CurrTokenService = token.NewTokenService(i.CurrLog, i.TokenCache(), i.TokenRepository())
        return i.CurrTokenService</span>
}

func (i *Deps) TokenRepository() token.TokenRepository <span class="cov8" title="1">{
        if i.CurrTokenRepository != nil </span><span class="cov0" title="0">{
                return i.CurrTokenRepository
        }</span>

        <span class="cov8" title="1">repository, err := token.NewTokenRepository(i.CurrLog, i.TokenCollection())
        if err != nil </span><span class="cov0" title="0">{
                i.CurrLog.Fatal(err)
                return nil
        }</span>

        <span class="cov8" title="1">i.CurrTokenRepository = repository
        return i.CurrTokenRepository</span>
}

func (i *Deps) TokenCache() token.TokenCache <span class="cov8" title="1">{
        if i.CurrTokenCache != nil </span><span class="cov0" title="0">{
                return i.CurrTokenCache
        }</span>

        <span class="cov8" title="1">if tokenCache != nil </span><span class="cov8" title="1">{
                return tokenCache
        }</span>

        <span class="cov8" title="1">tokenCache = token.NewTokenCache()

        return tokenCache</span>
}

func (i *Deps) UserService() user.UserService <span class="cov0" title="0">{
        if i.CurrUserService != nil </span><span class="cov0" title="0">{
                return i.CurrUserService
        }</span>

        <span class="cov0" title="0">i.CurrUserService = user.NewUserService(i.UserRepository())

        return i.CurrUserService</span>
}

func (i *Deps) UserRepository() user.UserRepository <span class="cov0" title="0">{
        if i.CurrUserRepository != nil </span><span class="cov0" title="0">{
                return i.CurrUserRepository
        }</span>

        <span class="cov0" title="0">repository, err := user.NewUserRepository(i.CurrLog, i.UserCollection())
        if err != nil </span><span class="cov0" title="0">{
                i.CurrLog.Fatal(err)
                return nil
        }</span>

        <span class="cov0" title="0">i.CurrUserRepository = repository
        return i.CurrUserRepository</span>
}

func (i *Deps) SignInUseCase() usecases.SignInUseCase <span class="cov0" title="0">{
        if i.CurrSignInUseCase != nil </span><span class="cov0" title="0">{
                return i.CurrSignInUseCase
        }</span>

        <span class="cov0" title="0">i.CurrSignInUseCase = usecases.NewSignInUseCase(i.UserService(), i.TokenService())

        return i.CurrSignInUseCase</span>
}

func (i *Deps) SignUpUseCase() usecases.SignUpUseCase <span class="cov0" title="0">{
        if i.CurrSignUpUseCase != nil </span><span class="cov0" title="0">{
                return i.CurrSignUpUseCase
        }</span>

        <span class="cov0" title="0">i.CurrSignUpUseCase = usecases.NewSignUpUseCase(i.UserService(), i.TokenService())

        return i.CurrSignUpUseCase</span>
}

func (i *Deps) InvalidateTokenUseCase() usecases.InvalidateTokenUseCase <span class="cov8" title="1">{
        if i.CurrInvalidateTokenUseCase != nil </span><span class="cov0" title="0">{
                return i.CurrInvalidateTokenUseCase
        }</span>

        <span class="cov8" title="1">i.CurrInvalidateTokenUseCase = usecases.NewInvalidateTokenUseCase(i.CurrLog, i.TokenService(), i.SendLogoutService())

        return i.CurrInvalidateTokenUseCase</span>
}

func (i *Deps) SendLogoutService() rabbit.SendLogoutService <span class="cov8" title="1">{
        if i.CurrSendLogoutService != nil </span><span class="cov0" title="0">{
                return i.CurrSendLogoutService
        }</span>

        <span class="cov8" title="1">i.CurrSendLogoutService, _ = rabbit.NewSendLogoutService(i.CurrLog, i.RabbitChannel())

        return i.CurrSendLogoutService</span>
}

func (i *Deps) TokenCollection() db.Collection <span class="cov8" title="1">{
        if i.CurrTokenCollection != nil </span><span class="cov8" title="1">{
                return i.CurrTokenCollection
        }</span>

        <span class="cov0" title="0">if tokenCollection != nil </span><span class="cov0" title="0">{
                return tokenCollection
        }</span>

        <span class="cov0" title="0">tokenCollection, err := db.NewCollection(i.CurrLog, i.Database(), "tokens", "userId")
        if err != nil </span><span class="cov0" title="0">{
                i.CurrLog.Fatal(err)
                return nil
        }</span>

        <span class="cov0" title="0">return tokenCollection</span>
}

func (i *Deps) UserCollection() db.Collection <span class="cov0" title="0">{
        if i.CurrUserCollection != nil </span><span class="cov0" title="0">{
                return i.CurrUserCollection
        }</span>

        <span class="cov0" title="0">if userCollection != nil </span><span class="cov0" title="0">{
                return userCollection
        }</span>

        <span class="cov0" title="0">userCollection, err := db.NewCollection(i.CurrLog, i.Database(), "users")
        if err != nil </span><span class="cov0" title="0">{
                i.CurrLog.Fatal(err)
                return nil
        }</span>

        <span class="cov0" title="0">return userCollection</span>
}

func (i *Deps) RabbitChannel() rbt.RabbitChannel <span class="cov8" title="1">{
        if i.CurrRabbitChannel != nil </span><span class="cov8" title="1">{
                return i.CurrRabbitChannel
        }</span>

        <span class="cov0" title="0">i.CurrRabbitChannel, _ = rbt.NewRabbitChannel(env.Get().RabbitURL, i.CurrLog)

        return i.CurrRabbitChannel</span>
}

// IsDbTimeoutError función a llamar cuando se produce un error de db
func IsDbTimeoutError(err interface{}) <span class="cov0" title="0">{
        if err == topology.ErrServerSelectionTimeout </span><span class="cov0" title="0">{
                database = nil
        }</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package env

import (
        "os"
        "strconv"
)

// Configuration properties
type Configuration struct {
        Port      int    `json:"port"`
        GqlPort   int    `json:"gqlPort"`
        RabbitURL string `json:"rabbitUrl"`
        MongoURL  string `json:"mongoUrl"`
        JWTSecret string `json:"jwtSecret"`
        FluentUrl string `json:"fluentUrl"`
}

var config *Configuration

func new() *Configuration <span class="cov8" title="1">{
        return &amp;Configuration{
                Port:      3000,
                GqlPort:   4000,
                RabbitURL: "amqp://localhost",
                MongoURL:  "mongodb://localhost:27017",
                JWTSecret: "ecb6d3479ac3823f1da7f314d871989b",
                FluentUrl: "localhost:24224",
        }
}</span>

// Get Obtiene las variables de entorno del sistema
func Get() *Configuration <span class="cov8" title="1">{
        if config == nil </span><span class="cov8" title="1">{
                config = load()
        }</span>

        <span class="cov8" title="1">return config</span>
}

// Load file properties
func load() *Configuration <span class="cov8" title="1">{
        result := new()

        if value := os.Getenv("RABBIT_URL"); len(value) &gt; 0 </span><span class="cov8" title="1">{
                result.RabbitURL = value
        }</span>

        <span class="cov8" title="1">if value := os.Getenv("MONGO_URL"); len(value) &gt; 0 </span><span class="cov8" title="1">{
                result.MongoURL = value
        }</span>

        <span class="cov8" title="1">if value := os.Getenv("FLUENT_URL"); len(value) &gt; 0 </span><span class="cov8" title="1">{
                result.FluentUrl = value
        }</span>

        <span class="cov8" title="1">if value := os.Getenv("PORT"); len(value) &gt; 0 </span><span class="cov8" title="1">{
                if intVal, err := strconv.Atoi(value); err == nil </span><span class="cov8" title="1">{
                        result.Port = intVal
                }</span>
        }

        <span class="cov8" title="1">if value := os.Getenv("GQL_PORT"); len(value) &gt; 0 </span><span class="cov0" title="0">{
                if intVal, err := strconv.Atoi(value); err == nil </span><span class="cov0" title="0">{
                        result.GqlPort = intVal
                }</span>
        }

        <span class="cov8" title="1">if value := os.Getenv("JWT_SECRET"); len(value) &gt; 0 </span><span class="cov8" title="1">{
                result.JWTSecret = value
        }</span>

        <span class="cov8" title="1">return result</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package errs

// Unauthorized el usuario no esta autorizado al recurso
var Unauthorized = NewRestError(401, "Unauthorized")

// NotFound cuando un registro no se encuentra en la db
var NotFound = NewRestError(404, "Document not found")

// AlreadyExist cuando no se puede ingresar un registro a la db
var AlreadyExist = NewRestError(400, "Already exist")

// Internal esta aplicación no sabe como manejar el error
var Internal = NewRestError(500, "Internal server error")

// - Creación de errors -
// NewRestError creates a new errCustom
func NewRestError(status int, message string) RestError <span class="cov8" title="1">{
        return &amp;restError{
                status:  status,
                Message: message,
        }
}</span>

//  - Algunas definiciones necesarias -

// RestError es una interfaz para definir errores custom
type RestError interface {
        Status() int
        Error() string
}

// restError es un error personalizado para http
type restError struct {
        status  int
        Message string `json:"error"`
}

func (e *restError) Error() string <span class="cov8" title="1">{
        return e.Message
}</span>

// Status http status code
func (e *restError) Status() int <span class="cov8" title="1">{
        return e.status
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">package errs

import (
        "encoding/json"
)

// Validation es una interfaz para definir errores custom
// Validation es un error de validaciones de parameteros o de campos
type Validation interface {
        Add(path string, message string) Validation
        Error() string
}

func NewValidation() Validation <span class="cov8" title="1">{
        return &amp;ValidationErr{
                Messages: []errField{},
        }
}</span>

type ValidationErr struct {
        Messages []errField `json:"messages"`
}

func (e *ValidationErr) Error() string <span class="cov0" title="0">{
        body, err := json.Marshal(e)
        if err != nil </span><span class="cov0" title="0">{
                return "ErrValidation invalid."
        }</span>
        <span class="cov0" title="0">return string(body)</span>
}

// Add agrega errores a un validation error
func (e *ValidationErr) Add(path string, message string) Validation <span class="cov8" title="1">{
        err := errField{
                Path:    path,
                Message: message,
        }
        e.Messages = append(e.Messages, err)
        return e
}</span>

// errField define un campo inválido. path y mensaje de error
type errField struct {
        Path    string `json:"path"`
        Message string `json:"message"`
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package log

import (
        "fmt"
        "net"

        uuid "github.com/satori/go.uuid"
        "github.com/sirupsen/logrus"
)

const LOG_FIELD_CORRELATION_ID = "correlation_id"
const LOG_FIELD_CONTROLLER = "controller"
const LOG_FIELD_RABBIT_ACTION = "rabbit_action"
const LOG_FIELD_RABBIT_EXCHANGE = "exchange"
const LOG_FIELD_RABBIT_QUEUE = "queue"
const LOG_FIELD_HTTP_METHOD = "http_method"
const LOG_FIELD_HTTP_PATH = "http_path"
const LOG_FIELD_HTTP_STATUS = "http_status"
const LOG_FIELD_SERVER = "server"
const LOG_FIELD_USER_ID = "user_id"
const LOG_FIELD_THREAD = "thread"

func Get(
        fluentUrl string,
) LogRusEntry <span class="cov0" title="0">{
        logger := logrus.New()
        configureFluent(logger, fluentUrl)

        logger.SetLevel(logrus.DebugLevel)
        logEntry := logger.WithField(LOG_FIELD_SERVER, "authgo").WithField(LOG_FIELD_THREAD, uuid.NewV4().String())

        return logRusEntry{entry: logEntry}
}</span>

func configureFluent(logger *logrus.Logger, fluentUrl string) <span class="cov0" title="0">{
        conn, err := net.Dial("tcp", fluentUrl)
        if err == nil </span><span class="cov0" title="0">{
                logger.SetFormatter(&amp;logrus.JSONFormatter{})
                logger.SetOutput(conn)
                logger.AddHook(&amp;logrusConnectionHook{
                        conn: conn,
                        fmt: &amp;logrus.TextFormatter{
                                FullTimestamp:  true,
                                ForceColors:    true,
                                DisableSorting: false,
                        },
                })
        }</span>
}

type logrusConnectionHook struct {
        conn net.Conn
        fmt  logrus.Formatter
}

func (hook *logrusConnectionHook) Fire(entry *logrus.Entry) error <span class="cov0" title="0">{
        msg, err := hook.fmt.Format(entry)
        if err == nil </span><span class="cov0" title="0">{
                fmt.Println(string(msg))
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (hook *logrusConnectionHook) Levels() []logrus.Level <span class="cov0" title="0">{
        return logrus.AllLevels
}</span>

func (hook *logrusConnectionHook) Close() error <span class="cov0" title="0">{
        hook.conn.Close()
        return nil
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">package log

import "github.com/sirupsen/logrus"

type LogRusEntry interface {
        Data() logrus.Fields
        Info(args ...interface{})
        Error(args ...interface{})
        Warn(args ...interface{})
        Fatal(args ...interface{})
        WithField(key string, value interface{}) LogRusEntry
}

type logRusEntry struct {
        entry *logrus.Entry
}

func (l logRusEntry) Error(args ...interface{}) <span class="cov0" title="0">{
        l.entry.Error(args...)
}</span>

func (l logRusEntry) WithField(key string, value interface{}) LogRusEntry <span class="cov0" title="0">{
        return logRusEntry{
                entry: l.entry.WithField(key, value),
        }
}</span>

func (l logRusEntry) Info(args ...interface{}) <span class="cov0" title="0">{
        l.entry.Info(args...)
}</span>

func (l logRusEntry) Warn(args ...interface{}) <span class="cov0" title="0">{
        l.entry.Warn(args...)
}</span>

func (l logRusEntry) Fatal(args ...interface{}) <span class="cov0" title="0">{
        l.entry.Fatal(args...)
}</span>

func (l logRusEntry) Data() logrus.Fields <span class="cov0" title="0">{
        return l.entry.Data
}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">package rbt

import (
        "github.com/nmarsollier/authgo/internal/engine/log"
        "github.com/streadway/amqp"
)

type RabbitChannel interface {
        ExchangeDeclare(name string, chType string) error
        Publish(exchange string, routingKey string, body []byte) error
}

func NewRabbitChannel(
        rabbitURL string,
        log log.LogRusEntry,
) (RabbitChannel, error) <span class="cov0" title="0">{
        conn, err := amqp.Dial(rabbitURL)
        if err != nil </span><span class="cov0" title="0">{
                log.Error(err)
                return nil, err
        }</span>

        <span class="cov0" title="0">channel, err := conn.Channel()
        if err != nil </span><span class="cov0" title="0">{
                log.Error(err)
                return nil, err
        }</span>

        <span class="cov0" title="0">return rabbitChannel{ch: channel}, nil</span>
}

type rabbitChannel struct {
        ch *amqp.Channel
}

func (c rabbitChannel) ExchangeDeclare(
        name string,
        chType string,
) error <span class="cov0" title="0">{
        return c.ch.ExchangeDeclare(
                name,   // name
                chType, // type
                false,  // durable
                false,  // auto-deleted
                false,  // internal
                false,  // no-wait
                nil,    // arguments
        )
}</span>
func (c rabbitChannel) Publish(
        exchange string,
        routingKey string,
        body []byte,
) error <span class="cov0" title="0">{
        return c.ch.Publish(
                exchange,   // exchange
                routingKey, // routing key
                false,      // mandatory
                false,      // immediate
                amqp.Publishing{
                        Body: body,
                })
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package model

import (
        "context"
        "errors"
        "fmt"
        "strings"
        "sync"

        "github.com/99designs/gqlgen/plugin/federation/fedruntime"
)

var (
        ErrUnknownType  = errors.New("unknown type")
        ErrTypeNotFound = errors.New("type not found")
)

func (ec *executionContext) __resolve__service(ctx context.Context) (fedruntime.Service, error) <span class="cov0" title="0">{
        if ec.DisableIntrospection </span><span class="cov0" title="0">{
                return fedruntime.Service{}, errors.New("federated introspection disabled")
        }</span>

        <span class="cov0" title="0">var sdl []string

        for _, src := range sources </span><span class="cov0" title="0">{
                if src.BuiltIn </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">sdl = append(sdl, src.Input)</span>
        }

        <span class="cov0" title="0">return fedruntime.Service{
                SDL: strings.Join(sdl, "\n"),
        }, nil</span>
}

func (ec *executionContext) __resolve_entities(ctx context.Context, representations []map[string]interface{}) []fedruntime.Entity <span class="cov0" title="0">{
        list := make([]fedruntime.Entity, len(representations))

        repsMap := ec.buildRepresentationGroups(ctx, representations)

        switch len(repsMap) </span>{
        case 0:<span class="cov0" title="0">
                return list</span>
        case 1:<span class="cov0" title="0">
                for typeName, reps := range repsMap </span><span class="cov0" title="0">{
                        ec.resolveEntityGroup(ctx, typeName, reps, list)
                }</span>
                <span class="cov0" title="0">return list</span>
        default:<span class="cov0" title="0">
                var g sync.WaitGroup
                g.Add(len(repsMap))
                for typeName, reps := range repsMap </span><span class="cov0" title="0">{
                        go func(typeName string, reps []EntityWithIndex) </span><span class="cov0" title="0">{
                                ec.resolveEntityGroup(ctx, typeName, reps, list)
                                g.Done()
                        }</span>(typeName, reps)
                }
                <span class="cov0" title="0">g.Wait()
                return list</span>
        }
}

type EntityWithIndex struct {
        // The index in the original representation array
        index  int
        entity EntityRepresentation
}

// EntityRepresentation is the JSON representation of an entity sent by the Router
// used as the inputs for us to resolve.
//
// We make it a map because we know the top level JSON is always an object.
type EntityRepresentation map[string]any

// We group entities by typename so that we can parallelize their resolution.
// This is particularly helpful when there are entity groups in multi mode.
func (ec *executionContext) buildRepresentationGroups(
        ctx context.Context,
        representations []map[string]any,
) map[string][]EntityWithIndex <span class="cov0" title="0">{
        repsMap := make(map[string][]EntityWithIndex)
        for i, rep := range representations </span><span class="cov0" title="0">{
                typeName, ok := rep["__typename"].(string)
                if !ok </span><span class="cov0" title="0">{
                        // If there is no __typename, we just skip the representation;
                        // we just won't be resolving these unknown types.
                        ec.Error(ctx, errors.New("__typename must be an existing string"))
                        continue</span>
                }

                <span class="cov0" title="0">repsMap[typeName] = append(repsMap[typeName], EntityWithIndex{
                        index:  i,
                        entity: rep,
                })</span>
        }

        <span class="cov0" title="0">return repsMap</span>
}

func (ec *executionContext) resolveEntityGroup(
        ctx context.Context,
        typeName string,
        reps []EntityWithIndex,
        list []fedruntime.Entity,
) <span class="cov0" title="0">{
        if isMulti(typeName) </span><span class="cov0" title="0">{
                err := ec.resolveManyEntities(ctx, typeName, reps, list)
                if err != nil </span><span class="cov0" title="0">{
                        ec.Error(ctx, err)
                }</span>
        } else<span class="cov0" title="0"> {
                // if there are multiple entities to resolve, parallelize (similar to
                // graphql.FieldSet.Dispatch)
                var e sync.WaitGroup
                e.Add(len(reps))
                for i, rep := range reps </span><span class="cov0" title="0">{
                        i, rep := i, rep
                        go func(i int, rep EntityWithIndex) </span><span class="cov0" title="0">{
                                entity, err := ec.resolveEntity(ctx, typeName, rep.entity)
                                if err != nil </span><span class="cov0" title="0">{
                                        ec.Error(ctx, err)
                                }</span> else<span class="cov0" title="0"> {
                                        list[rep.index] = entity
                                }</span>
                                <span class="cov0" title="0">e.Done()</span>
                        }(i, rep)
                }
                <span class="cov0" title="0">e.Wait()</span>
        }
}

func isMulti(typeName string) bool <span class="cov0" title="0">{
        switch typeName </span>{
        default:<span class="cov0" title="0">
                return false</span>
        }
}

func (ec *executionContext) resolveEntity(
        ctx context.Context,
        typeName string,
        rep EntityRepresentation,
) (e fedruntime.Entity, err error) <span class="cov0" title="0">{
        // we need to do our own panic handling, because we may be called in a
        // goroutine, where the usual panic handling can't catch us
        defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        err = ec.Recover(ctx, r)
                }</span>
        }()

        <span class="cov0" title="0">switch typeName </span>{
        case "User":<span class="cov0" title="0">
                resolverName, err := entityResolverNameForUser(ctx, rep)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf(`finding resolver for Entity "User": %w`, err)
                }</span>
                <span class="cov0" title="0">switch resolverName </span>{

                case "findUserByID":<span class="cov0" title="0">
                        id0, err := ec.unmarshalNString2string(ctx, rep["id"])
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf(`unmarshalling param 0 for findUserByID(): %w`, err)
                        }</span>
                        <span class="cov0" title="0">entity, err := ec.resolvers.Entity().FindUserByID(ctx, id0)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf(`resolving Entity "User": %w`, err)
                        }</span>

                        <span class="cov0" title="0">return entity, nil</span>
                }

        }
        <span class="cov0" title="0">return nil, fmt.Errorf("%w: %s", ErrUnknownType, typeName)</span>
}

func (ec *executionContext) resolveManyEntities(
        ctx context.Context,
        typeName string,
        reps []EntityWithIndex,
        list []fedruntime.Entity,
) (err error) <span class="cov0" title="0">{
        // we need to do our own panic handling, because we may be called in a
        // goroutine, where the usual panic handling can't catch us
        defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        err = ec.Recover(ctx, r)
                }</span>
        }()

        <span class="cov0" title="0">switch typeName </span>{

        default:<span class="cov0" title="0">
                return errors.New("unknown type: " + typeName)</span>
        }
}

func entityResolverNameForUser(ctx context.Context, rep EntityRepresentation) (string, error) <span class="cov0" title="0">{
        for </span><span class="cov0" title="0">{
                var (
                        m   EntityRepresentation
                        val interface{}
                        ok  bool
                )
                _ = val
                // if all of the KeyFields values for this resolver are null,
                // we shouldn't use use it
                allNull := true
                m = rep
                val, ok = m["id"]
                if !ok </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">if allNull </span><span class="cov0" title="0">{
                        allNull = val == nil
                }</span>
                <span class="cov0" title="0">if allNull </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">return "findUserByID", nil</span>
        }
        <span class="cov0" title="0">return "", fmt.Errorf("%w for User", ErrTypeNotFound)</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package model

type Mutation struct {
}

type Query struct {
}

type Token struct {
        Token string `json:"token"`
}

type User struct {
        ID          string   `json:"id"`
        Name        string   `json:"name"`
        Permissions []string `json:"permissions"`
        Login       string   `json:"login"`
        Enabled     bool     `json:"enabled"`
}

func (User) IsEntity() {<span class="cov0" title="0">}</span>
</pre>
		
		<pre class="file" id="file13" style="display: none">// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package model

import (
        "bytes"
        "context"
        "errors"
        "fmt"
        "strconv"
        "sync"
        "sync/atomic"

        "github.com/99designs/gqlgen/graphql"
        "github.com/99designs/gqlgen/graphql/introspection"
        "github.com/99designs/gqlgen/plugin/federation/fedruntime"
        gqlparser "github.com/vektah/gqlparser/v2"
        "github.com/vektah/gqlparser/v2/ast"
)

// region    ************************** generated!.gotpl **************************

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema <span class="cov0" title="0">{
        return &amp;executableSchema{
                schema:     cfg.Schema,
                resolvers:  cfg.Resolvers,
                directives: cfg.Directives,
                complexity: cfg.Complexity,
        }
}</span>

type Config struct {
        Schema     *ast.Schema
        Resolvers  ResolverRoot
        Directives DirectiveRoot
        Complexity ComplexityRoot
}

type ResolverRoot interface {
        Entity() EntityResolver
        Mutation() MutationResolver
        Query() QueryResolver
}

type DirectiveRoot struct {
}

type ComplexityRoot struct {
        Entity struct {
                FindUserByID func(childComplexity int, id string) int
        }

        Mutation struct {
                ChangePassword func(childComplexity int, oldPassword string, newPassword string) int
                Disable        func(childComplexity int, userID string) int
                Enable         func(childComplexity int, userID string) int
                Grant          func(childComplexity int, userID string, permissions []string) int
                Revoke         func(childComplexity int, userID string, permissions []string) int
                SignIn         func(childComplexity int, login string, password string) int
                SignOut        func(childComplexity int) int
                SignUp         func(childComplexity int, name string, login string, password string) int
        }

        Query struct {
                CurrentUser        func(childComplexity int) int
                Users              func(childComplexity int) int
                __resolve__service func(childComplexity int) int
                __resolve_entities func(childComplexity int, representations []map[string]interface{}) int
        }

        Token struct {
                Token func(childComplexity int) int
        }

        User struct {
                Enabled     func(childComplexity int) int
                ID          func(childComplexity int) int
                Login       func(childComplexity int) int
                Name        func(childComplexity int) int
                Permissions func(childComplexity int) int
        }

        _Service struct {
                SDL func(childComplexity int) int
        }
}

type EntityResolver interface {
        FindUserByID(ctx context.Context, id string) (*User, error)
}
type MutationResolver interface {
        SignIn(ctx context.Context, login string, password string) (*Token, error)
        SignUp(ctx context.Context, name string, login string, password string) (*Token, error)
        SignOut(ctx context.Context) (bool, error)
        ChangePassword(ctx context.Context, oldPassword string, newPassword string) (bool, error)
        Enable(ctx context.Context, userID string) (bool, error)
        Disable(ctx context.Context, userID string) (bool, error)
        Grant(ctx context.Context, userID string, permissions []string) (bool, error)
        Revoke(ctx context.Context, userID string, permissions []string) (bool, error)
}
type QueryResolver interface {
        CurrentUser(ctx context.Context) (*User, error)
        Users(ctx context.Context) ([]*User, error)
}

type executableSchema struct {
        schema     *ast.Schema
        resolvers  ResolverRoot
        directives DirectiveRoot
        complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema <span class="cov0" title="0">{
        if e.schema != nil </span><span class="cov0" title="0">{
                return e.schema
        }</span>
        <span class="cov0" title="0">return parsedSchema</span>
}

func (e *executableSchema) Complexity(typeName, field string, childComplexity int, rawArgs map[string]interface{}) (int, bool) <span class="cov0" title="0">{
        ec := executionContext{nil, e, 0, 0, nil}
        _ = ec
        switch typeName + "." + field </span>{

        case "Entity.findUserByID":<span class="cov0" title="0">
                if e.complexity.Entity.FindUserByID == nil </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov0" title="0">args, err := ec.field_Entity_findUserByID_args(context.TODO(), rawArgs)
                if err != nil </span><span class="cov0" title="0">{
                        return 0, false
                }</span>

                <span class="cov0" title="0">return e.complexity.Entity.FindUserByID(childComplexity, args["id"].(string)), true</span>

        case "Mutation.changePassword":<span class="cov0" title="0">
                if e.complexity.Mutation.ChangePassword == nil </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov0" title="0">args, err := ec.field_Mutation_changePassword_args(context.TODO(), rawArgs)
                if err != nil </span><span class="cov0" title="0">{
                        return 0, false
                }</span>

                <span class="cov0" title="0">return e.complexity.Mutation.ChangePassword(childComplexity, args["oldPassword"].(string), args["newPassword"].(string)), true</span>

        case "Mutation.disable":<span class="cov0" title="0">
                if e.complexity.Mutation.Disable == nil </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov0" title="0">args, err := ec.field_Mutation_disable_args(context.TODO(), rawArgs)
                if err != nil </span><span class="cov0" title="0">{
                        return 0, false
                }</span>

                <span class="cov0" title="0">return e.complexity.Mutation.Disable(childComplexity, args["userId"].(string)), true</span>

        case "Mutation.enable":<span class="cov0" title="0">
                if e.complexity.Mutation.Enable == nil </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov0" title="0">args, err := ec.field_Mutation_enable_args(context.TODO(), rawArgs)
                if err != nil </span><span class="cov0" title="0">{
                        return 0, false
                }</span>

                <span class="cov0" title="0">return e.complexity.Mutation.Enable(childComplexity, args["userId"].(string)), true</span>

        case "Mutation.grant":<span class="cov0" title="0">
                if e.complexity.Mutation.Grant == nil </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov0" title="0">args, err := ec.field_Mutation_grant_args(context.TODO(), rawArgs)
                if err != nil </span><span class="cov0" title="0">{
                        return 0, false
                }</span>

                <span class="cov0" title="0">return e.complexity.Mutation.Grant(childComplexity, args["userId"].(string), args["permissions"].([]string)), true</span>

        case "Mutation.revoke":<span class="cov0" title="0">
                if e.complexity.Mutation.Revoke == nil </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov0" title="0">args, err := ec.field_Mutation_revoke_args(context.TODO(), rawArgs)
                if err != nil </span><span class="cov0" title="0">{
                        return 0, false
                }</span>

                <span class="cov0" title="0">return e.complexity.Mutation.Revoke(childComplexity, args["userId"].(string), args["permissions"].([]string)), true</span>

        case "Mutation.signIn":<span class="cov0" title="0">
                if e.complexity.Mutation.SignIn == nil </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov0" title="0">args, err := ec.field_Mutation_signIn_args(context.TODO(), rawArgs)
                if err != nil </span><span class="cov0" title="0">{
                        return 0, false
                }</span>

                <span class="cov0" title="0">return e.complexity.Mutation.SignIn(childComplexity, args["login"].(string), args["password"].(string)), true</span>

        case "Mutation.signOut":<span class="cov0" title="0">
                if e.complexity.Mutation.SignOut == nil </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov0" title="0">return e.complexity.Mutation.SignOut(childComplexity), true</span>

        case "Mutation.signUp":<span class="cov0" title="0">
                if e.complexity.Mutation.SignUp == nil </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov0" title="0">args, err := ec.field_Mutation_signUp_args(context.TODO(), rawArgs)
                if err != nil </span><span class="cov0" title="0">{
                        return 0, false
                }</span>

                <span class="cov0" title="0">return e.complexity.Mutation.SignUp(childComplexity, args["name"].(string), args["login"].(string), args["password"].(string)), true</span>

        case "Query.currentUser":<span class="cov0" title="0">
                if e.complexity.Query.CurrentUser == nil </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov0" title="0">return e.complexity.Query.CurrentUser(childComplexity), true</span>

        case "Query.users":<span class="cov0" title="0">
                if e.complexity.Query.Users == nil </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov0" title="0">return e.complexity.Query.Users(childComplexity), true</span>

        case "Query._service":<span class="cov0" title="0">
                if e.complexity.Query.__resolve__service == nil </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov0" title="0">return e.complexity.Query.__resolve__service(childComplexity), true</span>

        case "Query._entities":<span class="cov0" title="0">
                if e.complexity.Query.__resolve_entities == nil </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov0" title="0">args, err := ec.field_Query__entities_args(context.TODO(), rawArgs)
                if err != nil </span><span class="cov0" title="0">{
                        return 0, false
                }</span>

                <span class="cov0" title="0">return e.complexity.Query.__resolve_entities(childComplexity, args["representations"].([]map[string]interface{})), true</span>

        case "Token.token":<span class="cov0" title="0">
                if e.complexity.Token.Token == nil </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov0" title="0">return e.complexity.Token.Token(childComplexity), true</span>

        case "User.enabled":<span class="cov0" title="0">
                if e.complexity.User.Enabled == nil </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov0" title="0">return e.complexity.User.Enabled(childComplexity), true</span>

        case "User.id":<span class="cov0" title="0">
                if e.complexity.User.ID == nil </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov0" title="0">return e.complexity.User.ID(childComplexity), true</span>

        case "User.login":<span class="cov0" title="0">
                if e.complexity.User.Login == nil </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov0" title="0">return e.complexity.User.Login(childComplexity), true</span>

        case "User.name":<span class="cov0" title="0">
                if e.complexity.User.Name == nil </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov0" title="0">return e.complexity.User.Name(childComplexity), true</span>

        case "User.permissions":<span class="cov0" title="0">
                if e.complexity.User.Permissions == nil </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov0" title="0">return e.complexity.User.Permissions(childComplexity), true</span>

        case "_Service.sdl":<span class="cov0" title="0">
                if e.complexity._Service.SDL == nil </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov0" title="0">return e.complexity._Service.SDL(childComplexity), true</span>

        }
        <span class="cov0" title="0">return 0, false</span>
}

func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler <span class="cov0" title="0">{
        opCtx := graphql.GetOperationContext(ctx)
        ec := executionContext{opCtx, e, 0, 0, make(chan graphql.DeferredResult)}
        inputUnmarshalMap := graphql.BuildUnmarshalerMap()
        first := true

        switch opCtx.Operation.Operation </span>{
        case ast.Query:<span class="cov0" title="0">
                return func(ctx context.Context) *graphql.Response </span><span class="cov0" title="0">{
                        var response graphql.Response
                        var data graphql.Marshaler
                        if first </span><span class="cov0" title="0">{
                                first = false
                                ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
                                data = ec._Query(ctx, opCtx.Operation.SelectionSet)
                        }</span> else<span class="cov0" title="0"> {
                                if atomic.LoadInt32(&amp;ec.pendingDeferred) &gt; 0 </span><span class="cov0" title="0">{
                                        result := &lt;-ec.deferredResults
                                        atomic.AddInt32(&amp;ec.pendingDeferred, -1)
                                        data = result.Result
                                        response.Path = result.Path
                                        response.Label = result.Label
                                        response.Errors = result.Errors
                                }</span> else<span class="cov0" title="0"> {
                                        return nil
                                }</span>
                        }
                        <span class="cov0" title="0">var buf bytes.Buffer
                        data.MarshalGQL(&amp;buf)
                        response.Data = buf.Bytes()
                        if atomic.LoadInt32(&amp;ec.deferred) &gt; 0 </span><span class="cov0" title="0">{
                                hasNext := atomic.LoadInt32(&amp;ec.pendingDeferred) &gt; 0
                                response.HasNext = &amp;hasNext
                        }</span>

                        <span class="cov0" title="0">return &amp;response</span>
                }
        case ast.Mutation:<span class="cov0" title="0">
                return func(ctx context.Context) *graphql.Response </span><span class="cov0" title="0">{
                        if !first </span><span class="cov0" title="0">{
                                return nil
                        }</span>
                        <span class="cov0" title="0">first = false
                        ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
                        data := ec._Mutation(ctx, opCtx.Operation.SelectionSet)
                        var buf bytes.Buffer
                        data.MarshalGQL(&amp;buf)

                        return &amp;graphql.Response{
                                Data: buf.Bytes(),
                        }</span>
                }

        default:<span class="cov0" title="0">
                return graphql.OneShot(graphql.ErrorResponse(ctx, "unsupported GraphQL operation"))</span>
        }
}

type executionContext struct {
        *graphql.OperationContext
        *executableSchema
        deferred        int32
        pendingDeferred int32
        deferredResults chan graphql.DeferredResult
}

func (ec *executionContext) processDeferredGroup(dg graphql.DeferredGroup) <span class="cov0" title="0">{
        atomic.AddInt32(&amp;ec.pendingDeferred, 1)
        go func() </span><span class="cov0" title="0">{
                ctx := graphql.WithFreshResponseContext(dg.Context)
                dg.FieldSet.Dispatch(ctx)
                ds := graphql.DeferredResult{
                        Path:   dg.Path,
                        Label:  dg.Label,
                        Result: dg.FieldSet,
                        Errors: graphql.GetErrors(ctx),
                }
                // null fields should bubble up
                if dg.FieldSet.Invalids &gt; 0 </span><span class="cov0" title="0">{
                        ds.Result = graphql.Null
                }</span>
                <span class="cov0" title="0">ec.deferredResults &lt;- ds</span>
        }()
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) <span class="cov0" title="0">{
        if ec.DisableIntrospection </span><span class="cov0" title="0">{
                return nil, errors.New("introspection disabled")
        }</span>
        <span class="cov0" title="0">return introspection.WrapSchema(ec.Schema()), nil</span>
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) <span class="cov0" title="0">{
        if ec.DisableIntrospection </span><span class="cov0" title="0">{
                return nil, errors.New("introspection disabled")
        }</span>
        <span class="cov0" title="0">return introspection.WrapTypeFromDef(ec.Schema(), ec.Schema().Types[name]), nil</span>
}

var sources = []*ast.Source{
        {Name: "../schema/schema.graphqls", Input: `type Token {
  token: String!
}

type Mutation {
  signIn(login: String!, password: String!): Token!
  signUp(name: String!, login: String!, password: String!): Token!
  signOut: Boolean!
  changePassword(oldPassword: String!, newPassword: String!): Boolean!
  enable(userId: String!): Boolean!
  disable(userId: String!): Boolean!
  grant(userId: String!, permissions: [String!]): Boolean!
  revoke(userId: String!, permissions: [String!]): Boolean!
}

type User @key(fields: "id") {
  id: String!
  name: String!
  permissions: [String!]!
  login: String!
  enabled: Boolean!
}

type Query {
  currentUser: User!
  users: [User!]!
}
`, BuiltIn: false},
        {Name: "../../../federation/directives.graphql", Input: `
        directive @key(fields: _FieldSet!) repeatable on OBJECT | INTERFACE
        directive @requires(fields: _FieldSet!) on FIELD_DEFINITION
        directive @provides(fields: _FieldSet!) on FIELD_DEFINITION
        directive @extends on OBJECT | INTERFACE
        directive @external on FIELD_DEFINITION
        scalar _Any
        scalar _FieldSet
`, BuiltIn: true},
        {Name: "../../../federation/entity.graphql", Input: `
# a union of all types that use the @key directive
union _Entity = User

# fake type to build resolver interfaces for users to implement
type Entity {
        findUserByID(id: String!,): User!
}

type _Service {
  sdl: String
}

extend type Query {
  _entities(representations: [_Any!]!): [_Entity]!
  _service: _Service!
}
`, BuiltIn: true},
}
var parsedSchema = gqlparser.MustLoadSchema(sources...)

// endregion ************************** generated!.gotpl **************************

// region    ***************************** args.gotpl *****************************

func (ec *executionContext) field_Entity_findUserByID_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) <span class="cov0" title="0">{
        var err error
        args := map[string]interface{}{}
        arg0, err := ec.field_Entity_findUserByID_argsID(ctx, rawArgs)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">args["id"] = arg0
        return args, nil</span>
}
func (ec *executionContext) field_Entity_findUserByID_argsID(
        ctx context.Context,
        rawArgs map[string]interface{},
) (string, error) <span class="cov0" title="0">{
        ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
        if tmp, ok := rawArgs["id"]; ok </span><span class="cov0" title="0">{
                return ec.unmarshalNString2string(ctx, tmp)
        }</span>

        <span class="cov0" title="0">var zeroVal string
        return zeroVal, nil</span>
}

func (ec *executionContext) field_Mutation_changePassword_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) <span class="cov0" title="0">{
        var err error
        args := map[string]interface{}{}
        arg0, err := ec.field_Mutation_changePassword_argsOldPassword(ctx, rawArgs)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">args["oldPassword"] = arg0
        arg1, err := ec.field_Mutation_changePassword_argsNewPassword(ctx, rawArgs)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">args["newPassword"] = arg1
        return args, nil</span>
}
func (ec *executionContext) field_Mutation_changePassword_argsOldPassword(
        ctx context.Context,
        rawArgs map[string]interface{},
) (string, error) <span class="cov0" title="0">{
        ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("oldPassword"))
        if tmp, ok := rawArgs["oldPassword"]; ok </span><span class="cov0" title="0">{
                return ec.unmarshalNString2string(ctx, tmp)
        }</span>

        <span class="cov0" title="0">var zeroVal string
        return zeroVal, nil</span>
}

func (ec *executionContext) field_Mutation_changePassword_argsNewPassword(
        ctx context.Context,
        rawArgs map[string]interface{},
) (string, error) <span class="cov0" title="0">{
        ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("newPassword"))
        if tmp, ok := rawArgs["newPassword"]; ok </span><span class="cov0" title="0">{
                return ec.unmarshalNString2string(ctx, tmp)
        }</span>

        <span class="cov0" title="0">var zeroVal string
        return zeroVal, nil</span>
}

func (ec *executionContext) field_Mutation_disable_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) <span class="cov0" title="0">{
        var err error
        args := map[string]interface{}{}
        arg0, err := ec.field_Mutation_disable_argsUserID(ctx, rawArgs)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">args["userId"] = arg0
        return args, nil</span>
}
func (ec *executionContext) field_Mutation_disable_argsUserID(
        ctx context.Context,
        rawArgs map[string]interface{},
) (string, error) <span class="cov0" title="0">{
        ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("userId"))
        if tmp, ok := rawArgs["userId"]; ok </span><span class="cov0" title="0">{
                return ec.unmarshalNString2string(ctx, tmp)
        }</span>

        <span class="cov0" title="0">var zeroVal string
        return zeroVal, nil</span>
}

func (ec *executionContext) field_Mutation_enable_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) <span class="cov0" title="0">{
        var err error
        args := map[string]interface{}{}
        arg0, err := ec.field_Mutation_enable_argsUserID(ctx, rawArgs)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">args["userId"] = arg0
        return args, nil</span>
}
func (ec *executionContext) field_Mutation_enable_argsUserID(
        ctx context.Context,
        rawArgs map[string]interface{},
) (string, error) <span class="cov0" title="0">{
        ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("userId"))
        if tmp, ok := rawArgs["userId"]; ok </span><span class="cov0" title="0">{
                return ec.unmarshalNString2string(ctx, tmp)
        }</span>

        <span class="cov0" title="0">var zeroVal string
        return zeroVal, nil</span>
}

func (ec *executionContext) field_Mutation_grant_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) <span class="cov0" title="0">{
        var err error
        args := map[string]interface{}{}
        arg0, err := ec.field_Mutation_grant_argsUserID(ctx, rawArgs)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">args["userId"] = arg0
        arg1, err := ec.field_Mutation_grant_argsPermissions(ctx, rawArgs)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">args["permissions"] = arg1
        return args, nil</span>
}
func (ec *executionContext) field_Mutation_grant_argsUserID(
        ctx context.Context,
        rawArgs map[string]interface{},
) (string, error) <span class="cov0" title="0">{
        ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("userId"))
        if tmp, ok := rawArgs["userId"]; ok </span><span class="cov0" title="0">{
                return ec.unmarshalNString2string(ctx, tmp)
        }</span>

        <span class="cov0" title="0">var zeroVal string
        return zeroVal, nil</span>
}

func (ec *executionContext) field_Mutation_grant_argsPermissions(
        ctx context.Context,
        rawArgs map[string]interface{},
) ([]string, error) <span class="cov0" title="0">{
        ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("permissions"))
        if tmp, ok := rawArgs["permissions"]; ok </span><span class="cov0" title="0">{
                return ec.unmarshalOString2ᚕstringᚄ(ctx, tmp)
        }</span>

        <span class="cov0" title="0">var zeroVal []string
        return zeroVal, nil</span>
}

func (ec *executionContext) field_Mutation_revoke_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) <span class="cov0" title="0">{
        var err error
        args := map[string]interface{}{}
        arg0, err := ec.field_Mutation_revoke_argsUserID(ctx, rawArgs)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">args["userId"] = arg0
        arg1, err := ec.field_Mutation_revoke_argsPermissions(ctx, rawArgs)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">args["permissions"] = arg1
        return args, nil</span>
}
func (ec *executionContext) field_Mutation_revoke_argsUserID(
        ctx context.Context,
        rawArgs map[string]interface{},
) (string, error) <span class="cov0" title="0">{
        ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("userId"))
        if tmp, ok := rawArgs["userId"]; ok </span><span class="cov0" title="0">{
                return ec.unmarshalNString2string(ctx, tmp)
        }</span>

        <span class="cov0" title="0">var zeroVal string
        return zeroVal, nil</span>
}

func (ec *executionContext) field_Mutation_revoke_argsPermissions(
        ctx context.Context,
        rawArgs map[string]interface{},
) ([]string, error) <span class="cov0" title="0">{
        ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("permissions"))
        if tmp, ok := rawArgs["permissions"]; ok </span><span class="cov0" title="0">{
                return ec.unmarshalOString2ᚕstringᚄ(ctx, tmp)
        }</span>

        <span class="cov0" title="0">var zeroVal []string
        return zeroVal, nil</span>
}

func (ec *executionContext) field_Mutation_signIn_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) <span class="cov0" title="0">{
        var err error
        args := map[string]interface{}{}
        arg0, err := ec.field_Mutation_signIn_argsLogin(ctx, rawArgs)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">args["login"] = arg0
        arg1, err := ec.field_Mutation_signIn_argsPassword(ctx, rawArgs)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">args["password"] = arg1
        return args, nil</span>
}
func (ec *executionContext) field_Mutation_signIn_argsLogin(
        ctx context.Context,
        rawArgs map[string]interface{},
) (string, error) <span class="cov0" title="0">{
        ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("login"))
        if tmp, ok := rawArgs["login"]; ok </span><span class="cov0" title="0">{
                return ec.unmarshalNString2string(ctx, tmp)
        }</span>

        <span class="cov0" title="0">var zeroVal string
        return zeroVal, nil</span>
}

func (ec *executionContext) field_Mutation_signIn_argsPassword(
        ctx context.Context,
        rawArgs map[string]interface{},
) (string, error) <span class="cov0" title="0">{
        ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("password"))
        if tmp, ok := rawArgs["password"]; ok </span><span class="cov0" title="0">{
                return ec.unmarshalNString2string(ctx, tmp)
        }</span>

        <span class="cov0" title="0">var zeroVal string
        return zeroVal, nil</span>
}

func (ec *executionContext) field_Mutation_signUp_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) <span class="cov0" title="0">{
        var err error
        args := map[string]interface{}{}
        arg0, err := ec.field_Mutation_signUp_argsName(ctx, rawArgs)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">args["name"] = arg0
        arg1, err := ec.field_Mutation_signUp_argsLogin(ctx, rawArgs)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">args["login"] = arg1
        arg2, err := ec.field_Mutation_signUp_argsPassword(ctx, rawArgs)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">args["password"] = arg2
        return args, nil</span>
}
func (ec *executionContext) field_Mutation_signUp_argsName(
        ctx context.Context,
        rawArgs map[string]interface{},
) (string, error) <span class="cov0" title="0">{
        ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
        if tmp, ok := rawArgs["name"]; ok </span><span class="cov0" title="0">{
                return ec.unmarshalNString2string(ctx, tmp)
        }</span>

        <span class="cov0" title="0">var zeroVal string
        return zeroVal, nil</span>
}

func (ec *executionContext) field_Mutation_signUp_argsLogin(
        ctx context.Context,
        rawArgs map[string]interface{},
) (string, error) <span class="cov0" title="0">{
        ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("login"))
        if tmp, ok := rawArgs["login"]; ok </span><span class="cov0" title="0">{
                return ec.unmarshalNString2string(ctx, tmp)
        }</span>

        <span class="cov0" title="0">var zeroVal string
        return zeroVal, nil</span>
}

func (ec *executionContext) field_Mutation_signUp_argsPassword(
        ctx context.Context,
        rawArgs map[string]interface{},
) (string, error) <span class="cov0" title="0">{
        ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("password"))
        if tmp, ok := rawArgs["password"]; ok </span><span class="cov0" title="0">{
                return ec.unmarshalNString2string(ctx, tmp)
        }</span>

        <span class="cov0" title="0">var zeroVal string
        return zeroVal, nil</span>
}

func (ec *executionContext) field_Query___type_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) <span class="cov0" title="0">{
        var err error
        args := map[string]interface{}{}
        arg0, err := ec.field_Query___type_argsName(ctx, rawArgs)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">args["name"] = arg0
        return args, nil</span>
}
func (ec *executionContext) field_Query___type_argsName(
        ctx context.Context,
        rawArgs map[string]interface{},
) (string, error) <span class="cov0" title="0">{
        ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
        if tmp, ok := rawArgs["name"]; ok </span><span class="cov0" title="0">{
                return ec.unmarshalNString2string(ctx, tmp)
        }</span>

        <span class="cov0" title="0">var zeroVal string
        return zeroVal, nil</span>
}

func (ec *executionContext) field_Query__entities_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) <span class="cov0" title="0">{
        var err error
        args := map[string]interface{}{}
        arg0, err := ec.field_Query__entities_argsRepresentations(ctx, rawArgs)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">args["representations"] = arg0
        return args, nil</span>
}
func (ec *executionContext) field_Query__entities_argsRepresentations(
        ctx context.Context,
        rawArgs map[string]interface{},
) ([]map[string]interface{}, error) <span class="cov0" title="0">{
        ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("representations"))
        if tmp, ok := rawArgs["representations"]; ok </span><span class="cov0" title="0">{
                return ec.unmarshalN_Any2ᚕmapᚄ(ctx, tmp)
        }</span>

        <span class="cov0" title="0">var zeroVal []map[string]interface{}
        return zeroVal, nil</span>
}

func (ec *executionContext) field___Type_enumValues_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) <span class="cov0" title="0">{
        var err error
        args := map[string]interface{}{}
        arg0, err := ec.field___Type_enumValues_argsIncludeDeprecated(ctx, rawArgs)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">args["includeDeprecated"] = arg0
        return args, nil</span>
}
func (ec *executionContext) field___Type_enumValues_argsIncludeDeprecated(
        ctx context.Context,
        rawArgs map[string]interface{},
) (bool, error) <span class="cov0" title="0">{
        ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("includeDeprecated"))
        if tmp, ok := rawArgs["includeDeprecated"]; ok </span><span class="cov0" title="0">{
                return ec.unmarshalOBoolean2bool(ctx, tmp)
        }</span>

        <span class="cov0" title="0">var zeroVal bool
        return zeroVal, nil</span>
}

func (ec *executionContext) field___Type_fields_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) <span class="cov0" title="0">{
        var err error
        args := map[string]interface{}{}
        arg0, err := ec.field___Type_fields_argsIncludeDeprecated(ctx, rawArgs)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">args["includeDeprecated"] = arg0
        return args, nil</span>
}
func (ec *executionContext) field___Type_fields_argsIncludeDeprecated(
        ctx context.Context,
        rawArgs map[string]interface{},
) (bool, error) <span class="cov0" title="0">{
        ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("includeDeprecated"))
        if tmp, ok := rawArgs["includeDeprecated"]; ok </span><span class="cov0" title="0">{
                return ec.unmarshalOBoolean2bool(ctx, tmp)
        }</span>

        <span class="cov0" title="0">var zeroVal bool
        return zeroVal, nil</span>
}

// endregion ***************************** args.gotpl *****************************

// region    ************************** directives.gotpl **************************

// endregion ************************** directives.gotpl **************************

// region    **************************** field.gotpl *****************************

func (ec *executionContext) _Entity_findUserByID(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) <span class="cov0" title="0">{
        fc, err := ec.fieldContext_Entity_findUserByID(ctx, field)
        if err != nil </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>
        <span class="cov0" title="0">ctx = graphql.WithFieldContext(ctx, fc)
        defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        ec.Error(ctx, ec.Recover(ctx, r))
                        ret = graphql.Null
                }</span>
        }()
        <span class="cov0" title="0">resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) </span><span class="cov0" title="0">{
                ctx = rctx // use context from middleware stack in children
                return ec.resolvers.Entity().FindUserByID(rctx, fc.Args["id"].(string))
        }</span>)
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                ec.Error(ctx, err)
                return graphql.Null
        }</span>
        <span class="cov0" title="0">if resTmp == nil </span><span class="cov0" title="0">{
                if !graphql.HasFieldError(ctx, fc) </span><span class="cov0" title="0">{
                        ec.Errorf(ctx, "must not be null")
                }</span>
                <span class="cov0" title="0">return graphql.Null</span>
        }
        <span class="cov0" title="0">res := resTmp.(*User)
        fc.Result = res
        return ec.marshalNUser2ᚖgithubᚗcomᚋnmarsollierᚋauthgoᚋinternalᚋgraphᚋmodelᚐUser(ctx, field.Selections, res)</span>
}

func (ec *executionContext) fieldContext_Entity_findUserByID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) <span class="cov0" title="0">{
        fc = &amp;graphql.FieldContext{
                Object:     "Entity",
                Field:      field,
                IsMethod:   true,
                IsResolver: true,
                Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) </span><span class="cov0" title="0">{
                        switch field.Name </span>{
                        case "id":<span class="cov0" title="0">
                                return ec.fieldContext_User_id(ctx, field)</span>
                        case "name":<span class="cov0" title="0">
                                return ec.fieldContext_User_name(ctx, field)</span>
                        case "permissions":<span class="cov0" title="0">
                                return ec.fieldContext_User_permissions(ctx, field)</span>
                        case "login":<span class="cov0" title="0">
                                return ec.fieldContext_User_login(ctx, field)</span>
                        case "enabled":<span class="cov0" title="0">
                                return ec.fieldContext_User_enabled(ctx, field)</span>
                        }
                        <span class="cov0" title="0">return nil, fmt.Errorf("no field named %q was found under type User", field.Name)</span>
                },
        }
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        err = ec.Recover(ctx, r)
                        ec.Error(ctx, err)
                }</span>
        }()
        <span class="cov0" title="0">ctx = graphql.WithFieldContext(ctx, fc)
        if fc.Args, err = ec.field_Entity_findUserByID_args(ctx, field.ArgumentMap(ec.Variables)); err != nil </span><span class="cov0" title="0">{
                ec.Error(ctx, err)
                return fc, err
        }</span>
        <span class="cov0" title="0">return fc, nil</span>
}

func (ec *executionContext) _Mutation_signIn(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) <span class="cov0" title="0">{
        fc, err := ec.fieldContext_Mutation_signIn(ctx, field)
        if err != nil </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>
        <span class="cov0" title="0">ctx = graphql.WithFieldContext(ctx, fc)
        defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        ec.Error(ctx, ec.Recover(ctx, r))
                        ret = graphql.Null
                }</span>
        }()
        <span class="cov0" title="0">resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) </span><span class="cov0" title="0">{
                ctx = rctx // use context from middleware stack in children
                return ec.resolvers.Mutation().SignIn(rctx, fc.Args["login"].(string), fc.Args["password"].(string))
        }</span>)
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                ec.Error(ctx, err)
                return graphql.Null
        }</span>
        <span class="cov0" title="0">if resTmp == nil </span><span class="cov0" title="0">{
                if !graphql.HasFieldError(ctx, fc) </span><span class="cov0" title="0">{
                        ec.Errorf(ctx, "must not be null")
                }</span>
                <span class="cov0" title="0">return graphql.Null</span>
        }
        <span class="cov0" title="0">res := resTmp.(*Token)
        fc.Result = res
        return ec.marshalNToken2ᚖgithubᚗcomᚋnmarsollierᚋauthgoᚋinternalᚋgraphᚋmodelᚐToken(ctx, field.Selections, res)</span>
}

func (ec *executionContext) fieldContext_Mutation_signIn(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) <span class="cov0" title="0">{
        fc = &amp;graphql.FieldContext{
                Object:     "Mutation",
                Field:      field,
                IsMethod:   true,
                IsResolver: true,
                Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) </span><span class="cov0" title="0">{
                        switch field.Name </span>{
                        case "token":<span class="cov0" title="0">
                                return ec.fieldContext_Token_token(ctx, field)</span>
                        }
                        <span class="cov0" title="0">return nil, fmt.Errorf("no field named %q was found under type Token", field.Name)</span>
                },
        }
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        err = ec.Recover(ctx, r)
                        ec.Error(ctx, err)
                }</span>
        }()
        <span class="cov0" title="0">ctx = graphql.WithFieldContext(ctx, fc)
        if fc.Args, err = ec.field_Mutation_signIn_args(ctx, field.ArgumentMap(ec.Variables)); err != nil </span><span class="cov0" title="0">{
                ec.Error(ctx, err)
                return fc, err
        }</span>
        <span class="cov0" title="0">return fc, nil</span>
}

func (ec *executionContext) _Mutation_signUp(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) <span class="cov0" title="0">{
        fc, err := ec.fieldContext_Mutation_signUp(ctx, field)
        if err != nil </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>
        <span class="cov0" title="0">ctx = graphql.WithFieldContext(ctx, fc)
        defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        ec.Error(ctx, ec.Recover(ctx, r))
                        ret = graphql.Null
                }</span>
        }()
        <span class="cov0" title="0">resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) </span><span class="cov0" title="0">{
                ctx = rctx // use context from middleware stack in children
                return ec.resolvers.Mutation().SignUp(rctx, fc.Args["name"].(string), fc.Args["login"].(string), fc.Args["password"].(string))
        }</span>)
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                ec.Error(ctx, err)
                return graphql.Null
        }</span>
        <span class="cov0" title="0">if resTmp == nil </span><span class="cov0" title="0">{
                if !graphql.HasFieldError(ctx, fc) </span><span class="cov0" title="0">{
                        ec.Errorf(ctx, "must not be null")
                }</span>
                <span class="cov0" title="0">return graphql.Null</span>
        }
        <span class="cov0" title="0">res := resTmp.(*Token)
        fc.Result = res
        return ec.marshalNToken2ᚖgithubᚗcomᚋnmarsollierᚋauthgoᚋinternalᚋgraphᚋmodelᚐToken(ctx, field.Selections, res)</span>
}

func (ec *executionContext) fieldContext_Mutation_signUp(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) <span class="cov0" title="0">{
        fc = &amp;graphql.FieldContext{
                Object:     "Mutation",
                Field:      field,
                IsMethod:   true,
                IsResolver: true,
                Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) </span><span class="cov0" title="0">{
                        switch field.Name </span>{
                        case "token":<span class="cov0" title="0">
                                return ec.fieldContext_Token_token(ctx, field)</span>
                        }
                        <span class="cov0" title="0">return nil, fmt.Errorf("no field named %q was found under type Token", field.Name)</span>
                },
        }
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        err = ec.Recover(ctx, r)
                        ec.Error(ctx, err)
                }</span>
        }()
        <span class="cov0" title="0">ctx = graphql.WithFieldContext(ctx, fc)
        if fc.Args, err = ec.field_Mutation_signUp_args(ctx, field.ArgumentMap(ec.Variables)); err != nil </span><span class="cov0" title="0">{
                ec.Error(ctx, err)
                return fc, err
        }</span>
        <span class="cov0" title="0">return fc, nil</span>
}

func (ec *executionContext) _Mutation_signOut(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) <span class="cov0" title="0">{
        fc, err := ec.fieldContext_Mutation_signOut(ctx, field)
        if err != nil </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>
        <span class="cov0" title="0">ctx = graphql.WithFieldContext(ctx, fc)
        defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        ec.Error(ctx, ec.Recover(ctx, r))
                        ret = graphql.Null
                }</span>
        }()
        <span class="cov0" title="0">resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) </span><span class="cov0" title="0">{
                ctx = rctx // use context from middleware stack in children
                return ec.resolvers.Mutation().SignOut(rctx)
        }</span>)
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                ec.Error(ctx, err)
                return graphql.Null
        }</span>
        <span class="cov0" title="0">if resTmp == nil </span><span class="cov0" title="0">{
                if !graphql.HasFieldError(ctx, fc) </span><span class="cov0" title="0">{
                        ec.Errorf(ctx, "must not be null")
                }</span>
                <span class="cov0" title="0">return graphql.Null</span>
        }
        <span class="cov0" title="0">res := resTmp.(bool)
        fc.Result = res
        return ec.marshalNBoolean2bool(ctx, field.Selections, res)</span>
}

func (ec *executionContext) fieldContext_Mutation_signOut(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) <span class="cov0" title="0">{
        fc = &amp;graphql.FieldContext{
                Object:     "Mutation",
                Field:      field,
                IsMethod:   true,
                IsResolver: true,
                Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) </span><span class="cov0" title="0">{
                        return nil, errors.New("field of type Boolean does not have child fields")
                }</span>,
        }
        <span class="cov0" title="0">return fc, nil</span>
}

func (ec *executionContext) _Mutation_changePassword(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) <span class="cov0" title="0">{
        fc, err := ec.fieldContext_Mutation_changePassword(ctx, field)
        if err != nil </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>
        <span class="cov0" title="0">ctx = graphql.WithFieldContext(ctx, fc)
        defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        ec.Error(ctx, ec.Recover(ctx, r))
                        ret = graphql.Null
                }</span>
        }()
        <span class="cov0" title="0">resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) </span><span class="cov0" title="0">{
                ctx = rctx // use context from middleware stack in children
                return ec.resolvers.Mutation().ChangePassword(rctx, fc.Args["oldPassword"].(string), fc.Args["newPassword"].(string))
        }</span>)
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                ec.Error(ctx, err)
                return graphql.Null
        }</span>
        <span class="cov0" title="0">if resTmp == nil </span><span class="cov0" title="0">{
                if !graphql.HasFieldError(ctx, fc) </span><span class="cov0" title="0">{
                        ec.Errorf(ctx, "must not be null")
                }</span>
                <span class="cov0" title="0">return graphql.Null</span>
        }
        <span class="cov0" title="0">res := resTmp.(bool)
        fc.Result = res
        return ec.marshalNBoolean2bool(ctx, field.Selections, res)</span>
}

func (ec *executionContext) fieldContext_Mutation_changePassword(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) <span class="cov0" title="0">{
        fc = &amp;graphql.FieldContext{
                Object:     "Mutation",
                Field:      field,
                IsMethod:   true,
                IsResolver: true,
                Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) </span><span class="cov0" title="0">{
                        return nil, errors.New("field of type Boolean does not have child fields")
                }</span>,
        }
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        err = ec.Recover(ctx, r)
                        ec.Error(ctx, err)
                }</span>
        }()
        <span class="cov0" title="0">ctx = graphql.WithFieldContext(ctx, fc)
        if fc.Args, err = ec.field_Mutation_changePassword_args(ctx, field.ArgumentMap(ec.Variables)); err != nil </span><span class="cov0" title="0">{
                ec.Error(ctx, err)
                return fc, err
        }</span>
        <span class="cov0" title="0">return fc, nil</span>
}

func (ec *executionContext) _Mutation_enable(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) <span class="cov0" title="0">{
        fc, err := ec.fieldContext_Mutation_enable(ctx, field)
        if err != nil </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>
        <span class="cov0" title="0">ctx = graphql.WithFieldContext(ctx, fc)
        defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        ec.Error(ctx, ec.Recover(ctx, r))
                        ret = graphql.Null
                }</span>
        }()
        <span class="cov0" title="0">resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) </span><span class="cov0" title="0">{
                ctx = rctx // use context from middleware stack in children
                return ec.resolvers.Mutation().Enable(rctx, fc.Args["userId"].(string))
        }</span>)
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                ec.Error(ctx, err)
                return graphql.Null
        }</span>
        <span class="cov0" title="0">if resTmp == nil </span><span class="cov0" title="0">{
                if !graphql.HasFieldError(ctx, fc) </span><span class="cov0" title="0">{
                        ec.Errorf(ctx, "must not be null")
                }</span>
                <span class="cov0" title="0">return graphql.Null</span>
        }
        <span class="cov0" title="0">res := resTmp.(bool)
        fc.Result = res
        return ec.marshalNBoolean2bool(ctx, field.Selections, res)</span>
}

func (ec *executionContext) fieldContext_Mutation_enable(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) <span class="cov0" title="0">{
        fc = &amp;graphql.FieldContext{
                Object:     "Mutation",
                Field:      field,
                IsMethod:   true,
                IsResolver: true,
                Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) </span><span class="cov0" title="0">{
                        return nil, errors.New("field of type Boolean does not have child fields")
                }</span>,
        }
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        err = ec.Recover(ctx, r)
                        ec.Error(ctx, err)
                }</span>
        }()
        <span class="cov0" title="0">ctx = graphql.WithFieldContext(ctx, fc)
        if fc.Args, err = ec.field_Mutation_enable_args(ctx, field.ArgumentMap(ec.Variables)); err != nil </span><span class="cov0" title="0">{
                ec.Error(ctx, err)
                return fc, err
        }</span>
        <span class="cov0" title="0">return fc, nil</span>
}

func (ec *executionContext) _Mutation_disable(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) <span class="cov0" title="0">{
        fc, err := ec.fieldContext_Mutation_disable(ctx, field)
        if err != nil </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>
        <span class="cov0" title="0">ctx = graphql.WithFieldContext(ctx, fc)
        defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        ec.Error(ctx, ec.Recover(ctx, r))
                        ret = graphql.Null
                }</span>
        }()
        <span class="cov0" title="0">resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) </span><span class="cov0" title="0">{
                ctx = rctx // use context from middleware stack in children
                return ec.resolvers.Mutation().Disable(rctx, fc.Args["userId"].(string))
        }</span>)
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                ec.Error(ctx, err)
                return graphql.Null
        }</span>
        <span class="cov0" title="0">if resTmp == nil </span><span class="cov0" title="0">{
                if !graphql.HasFieldError(ctx, fc) </span><span class="cov0" title="0">{
                        ec.Errorf(ctx, "must not be null")
                }</span>
                <span class="cov0" title="0">return graphql.Null</span>
        }
        <span class="cov0" title="0">res := resTmp.(bool)
        fc.Result = res
        return ec.marshalNBoolean2bool(ctx, field.Selections, res)</span>
}

func (ec *executionContext) fieldContext_Mutation_disable(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) <span class="cov0" title="0">{
        fc = &amp;graphql.FieldContext{
                Object:     "Mutation",
                Field:      field,
                IsMethod:   true,
                IsResolver: true,
                Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) </span><span class="cov0" title="0">{
                        return nil, errors.New("field of type Boolean does not have child fields")
                }</span>,
        }
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        err = ec.Recover(ctx, r)
                        ec.Error(ctx, err)
                }</span>
        }()
        <span class="cov0" title="0">ctx = graphql.WithFieldContext(ctx, fc)
        if fc.Args, err = ec.field_Mutation_disable_args(ctx, field.ArgumentMap(ec.Variables)); err != nil </span><span class="cov0" title="0">{
                ec.Error(ctx, err)
                return fc, err
        }</span>
        <span class="cov0" title="0">return fc, nil</span>
}

func (ec *executionContext) _Mutation_grant(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) <span class="cov0" title="0">{
        fc, err := ec.fieldContext_Mutation_grant(ctx, field)
        if err != nil </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>
        <span class="cov0" title="0">ctx = graphql.WithFieldContext(ctx, fc)
        defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        ec.Error(ctx, ec.Recover(ctx, r))
                        ret = graphql.Null
                }</span>
        }()
        <span class="cov0" title="0">resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) </span><span class="cov0" title="0">{
                ctx = rctx // use context from middleware stack in children
                return ec.resolvers.Mutation().Grant(rctx, fc.Args["userId"].(string), fc.Args["permissions"].([]string))
        }</span>)
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                ec.Error(ctx, err)
                return graphql.Null
        }</span>
        <span class="cov0" title="0">if resTmp == nil </span><span class="cov0" title="0">{
                if !graphql.HasFieldError(ctx, fc) </span><span class="cov0" title="0">{
                        ec.Errorf(ctx, "must not be null")
                }</span>
                <span class="cov0" title="0">return graphql.Null</span>
        }
        <span class="cov0" title="0">res := resTmp.(bool)
        fc.Result = res
        return ec.marshalNBoolean2bool(ctx, field.Selections, res)</span>
}

func (ec *executionContext) fieldContext_Mutation_grant(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) <span class="cov0" title="0">{
        fc = &amp;graphql.FieldContext{
                Object:     "Mutation",
                Field:      field,
                IsMethod:   true,
                IsResolver: true,
                Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) </span><span class="cov0" title="0">{
                        return nil, errors.New("field of type Boolean does not have child fields")
                }</span>,
        }
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        err = ec.Recover(ctx, r)
                        ec.Error(ctx, err)
                }</span>
        }()
        <span class="cov0" title="0">ctx = graphql.WithFieldContext(ctx, fc)
        if fc.Args, err = ec.field_Mutation_grant_args(ctx, field.ArgumentMap(ec.Variables)); err != nil </span><span class="cov0" title="0">{
                ec.Error(ctx, err)
                return fc, err
        }</span>
        <span class="cov0" title="0">return fc, nil</span>
}

func (ec *executionContext) _Mutation_revoke(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) <span class="cov0" title="0">{
        fc, err := ec.fieldContext_Mutation_revoke(ctx, field)
        if err != nil </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>
        <span class="cov0" title="0">ctx = graphql.WithFieldContext(ctx, fc)
        defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        ec.Error(ctx, ec.Recover(ctx, r))
                        ret = graphql.Null
                }</span>
        }()
        <span class="cov0" title="0">resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) </span><span class="cov0" title="0">{
                ctx = rctx // use context from middleware stack in children
                return ec.resolvers.Mutation().Revoke(rctx, fc.Args["userId"].(string), fc.Args["permissions"].([]string))
        }</span>)
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                ec.Error(ctx, err)
                return graphql.Null
        }</span>
        <span class="cov0" title="0">if resTmp == nil </span><span class="cov0" title="0">{
                if !graphql.HasFieldError(ctx, fc) </span><span class="cov0" title="0">{
                        ec.Errorf(ctx, "must not be null")
                }</span>
                <span class="cov0" title="0">return graphql.Null</span>
        }
        <span class="cov0" title="0">res := resTmp.(bool)
        fc.Result = res
        return ec.marshalNBoolean2bool(ctx, field.Selections, res)</span>
}

func (ec *executionContext) fieldContext_Mutation_revoke(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) <span class="cov0" title="0">{
        fc = &amp;graphql.FieldContext{
                Object:     "Mutation",
                Field:      field,
                IsMethod:   true,
                IsResolver: true,
                Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) </span><span class="cov0" title="0">{
                        return nil, errors.New("field of type Boolean does not have child fields")
                }</span>,
        }
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        err = ec.Recover(ctx, r)
                        ec.Error(ctx, err)
                }</span>
        }()
        <span class="cov0" title="0">ctx = graphql.WithFieldContext(ctx, fc)
        if fc.Args, err = ec.field_Mutation_revoke_args(ctx, field.ArgumentMap(ec.Variables)); err != nil </span><span class="cov0" title="0">{
                ec.Error(ctx, err)
                return fc, err
        }</span>
        <span class="cov0" title="0">return fc, nil</span>
}

func (ec *executionContext) _Query_currentUser(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) <span class="cov0" title="0">{
        fc, err := ec.fieldContext_Query_currentUser(ctx, field)
        if err != nil </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>
        <span class="cov0" title="0">ctx = graphql.WithFieldContext(ctx, fc)
        defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        ec.Error(ctx, ec.Recover(ctx, r))
                        ret = graphql.Null
                }</span>
        }()
        <span class="cov0" title="0">resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) </span><span class="cov0" title="0">{
                ctx = rctx // use context from middleware stack in children
                return ec.resolvers.Query().CurrentUser(rctx)
        }</span>)
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                ec.Error(ctx, err)
                return graphql.Null
        }</span>
        <span class="cov0" title="0">if resTmp == nil </span><span class="cov0" title="0">{
                if !graphql.HasFieldError(ctx, fc) </span><span class="cov0" title="0">{
                        ec.Errorf(ctx, "must not be null")
                }</span>
                <span class="cov0" title="0">return graphql.Null</span>
        }
        <span class="cov0" title="0">res := resTmp.(*User)
        fc.Result = res
        return ec.marshalNUser2ᚖgithubᚗcomᚋnmarsollierᚋauthgoᚋinternalᚋgraphᚋmodelᚐUser(ctx, field.Selections, res)</span>
}

func (ec *executionContext) fieldContext_Query_currentUser(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) <span class="cov0" title="0">{
        fc = &amp;graphql.FieldContext{
                Object:     "Query",
                Field:      field,
                IsMethod:   true,
                IsResolver: true,
                Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) </span><span class="cov0" title="0">{
                        switch field.Name </span>{
                        case "id":<span class="cov0" title="0">
                                return ec.fieldContext_User_id(ctx, field)</span>
                        case "name":<span class="cov0" title="0">
                                return ec.fieldContext_User_name(ctx, field)</span>
                        case "permissions":<span class="cov0" title="0">
                                return ec.fieldContext_User_permissions(ctx, field)</span>
                        case "login":<span class="cov0" title="0">
                                return ec.fieldContext_User_login(ctx, field)</span>
                        case "enabled":<span class="cov0" title="0">
                                return ec.fieldContext_User_enabled(ctx, field)</span>
                        }
                        <span class="cov0" title="0">return nil, fmt.Errorf("no field named %q was found under type User", field.Name)</span>
                },
        }
        <span class="cov0" title="0">return fc, nil</span>
}

func (ec *executionContext) _Query_users(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) <span class="cov0" title="0">{
        fc, err := ec.fieldContext_Query_users(ctx, field)
        if err != nil </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>
        <span class="cov0" title="0">ctx = graphql.WithFieldContext(ctx, fc)
        defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        ec.Error(ctx, ec.Recover(ctx, r))
                        ret = graphql.Null
                }</span>
        }()
        <span class="cov0" title="0">resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) </span><span class="cov0" title="0">{
                ctx = rctx // use context from middleware stack in children
                return ec.resolvers.Query().Users(rctx)
        }</span>)
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                ec.Error(ctx, err)
                return graphql.Null
        }</span>
        <span class="cov0" title="0">if resTmp == nil </span><span class="cov0" title="0">{
                if !graphql.HasFieldError(ctx, fc) </span><span class="cov0" title="0">{
                        ec.Errorf(ctx, "must not be null")
                }</span>
                <span class="cov0" title="0">return graphql.Null</span>
        }
        <span class="cov0" title="0">res := resTmp.([]*User)
        fc.Result = res
        return ec.marshalNUser2ᚕᚖgithubᚗcomᚋnmarsollierᚋauthgoᚋinternalᚋgraphᚋmodelᚐUserᚄ(ctx, field.Selections, res)</span>
}

func (ec *executionContext) fieldContext_Query_users(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) <span class="cov0" title="0">{
        fc = &amp;graphql.FieldContext{
                Object:     "Query",
                Field:      field,
                IsMethod:   true,
                IsResolver: true,
                Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) </span><span class="cov0" title="0">{
                        switch field.Name </span>{
                        case "id":<span class="cov0" title="0">
                                return ec.fieldContext_User_id(ctx, field)</span>
                        case "name":<span class="cov0" title="0">
                                return ec.fieldContext_User_name(ctx, field)</span>
                        case "permissions":<span class="cov0" title="0">
                                return ec.fieldContext_User_permissions(ctx, field)</span>
                        case "login":<span class="cov0" title="0">
                                return ec.fieldContext_User_login(ctx, field)</span>
                        case "enabled":<span class="cov0" title="0">
                                return ec.fieldContext_User_enabled(ctx, field)</span>
                        }
                        <span class="cov0" title="0">return nil, fmt.Errorf("no field named %q was found under type User", field.Name)</span>
                },
        }
        <span class="cov0" title="0">return fc, nil</span>
}

func (ec *executionContext) _Query__entities(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) <span class="cov0" title="0">{
        fc, err := ec.fieldContext_Query__entities(ctx, field)
        if err != nil </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>
        <span class="cov0" title="0">ctx = graphql.WithFieldContext(ctx, fc)
        defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        ec.Error(ctx, ec.Recover(ctx, r))
                        ret = graphql.Null
                }</span>
        }()
        <span class="cov0" title="0">resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) </span><span class="cov0" title="0">{
                ctx = rctx // use context from middleware stack in children
                return ec.__resolve_entities(ctx, fc.Args["representations"].([]map[string]interface{})), nil
        }</span>)
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                ec.Error(ctx, err)
                return graphql.Null
        }</span>
        <span class="cov0" title="0">if resTmp == nil </span><span class="cov0" title="0">{
                if !graphql.HasFieldError(ctx, fc) </span><span class="cov0" title="0">{
                        ec.Errorf(ctx, "must not be null")
                }</span>
                <span class="cov0" title="0">return graphql.Null</span>
        }
        <span class="cov0" title="0">res := resTmp.([]fedruntime.Entity)
        fc.Result = res
        return ec.marshalN_Entity2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋpluginᚋfederationᚋfedruntimeᚐEntity(ctx, field.Selections, res)</span>
}

func (ec *executionContext) fieldContext_Query__entities(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) <span class="cov0" title="0">{
        fc = &amp;graphql.FieldContext{
                Object:     "Query",
                Field:      field,
                IsMethod:   true,
                IsResolver: false,
                Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) </span><span class="cov0" title="0">{
                        return nil, errors.New("field of type _Entity does not have child fields")
                }</span>,
        }
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        err = ec.Recover(ctx, r)
                        ec.Error(ctx, err)
                }</span>
        }()
        <span class="cov0" title="0">ctx = graphql.WithFieldContext(ctx, fc)
        if fc.Args, err = ec.field_Query__entities_args(ctx, field.ArgumentMap(ec.Variables)); err != nil </span><span class="cov0" title="0">{
                ec.Error(ctx, err)
                return fc, err
        }</span>
        <span class="cov0" title="0">return fc, nil</span>
}

func (ec *executionContext) _Query__service(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) <span class="cov0" title="0">{
        fc, err := ec.fieldContext_Query__service(ctx, field)
        if err != nil </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>
        <span class="cov0" title="0">ctx = graphql.WithFieldContext(ctx, fc)
        defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        ec.Error(ctx, ec.Recover(ctx, r))
                        ret = graphql.Null
                }</span>
        }()
        <span class="cov0" title="0">resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) </span><span class="cov0" title="0">{
                ctx = rctx // use context from middleware stack in children
                return ec.__resolve__service(ctx)
        }</span>)
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                ec.Error(ctx, err)
                return graphql.Null
        }</span>
        <span class="cov0" title="0">if resTmp == nil </span><span class="cov0" title="0">{
                if !graphql.HasFieldError(ctx, fc) </span><span class="cov0" title="0">{
                        ec.Errorf(ctx, "must not be null")
                }</span>
                <span class="cov0" title="0">return graphql.Null</span>
        }
        <span class="cov0" title="0">res := resTmp.(fedruntime.Service)
        fc.Result = res
        return ec.marshalN_Service2githubᚗcomᚋ99designsᚋgqlgenᚋpluginᚋfederationᚋfedruntimeᚐService(ctx, field.Selections, res)</span>
}

func (ec *executionContext) fieldContext_Query__service(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) <span class="cov0" title="0">{
        fc = &amp;graphql.FieldContext{
                Object:     "Query",
                Field:      field,
                IsMethod:   true,
                IsResolver: false,
                Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) </span><span class="cov0" title="0">{
                        switch field.Name </span>{
                        case "sdl":<span class="cov0" title="0">
                                return ec.fieldContext__Service_sdl(ctx, field)</span>
                        }
                        <span class="cov0" title="0">return nil, fmt.Errorf("no field named %q was found under type _Service", field.Name)</span>
                },
        }
        <span class="cov0" title="0">return fc, nil</span>
}

func (ec *executionContext) _Query___type(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) <span class="cov0" title="0">{
        fc, err := ec.fieldContext_Query___type(ctx, field)
        if err != nil </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>
        <span class="cov0" title="0">ctx = graphql.WithFieldContext(ctx, fc)
        defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        ec.Error(ctx, ec.Recover(ctx, r))
                        ret = graphql.Null
                }</span>
        }()
        <span class="cov0" title="0">resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) </span><span class="cov0" title="0">{
                ctx = rctx // use context from middleware stack in children
                return ec.introspectType(fc.Args["name"].(string))
        }</span>)
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                ec.Error(ctx, err)
                return graphql.Null
        }</span>
        <span class="cov0" title="0">if resTmp == nil </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>
        <span class="cov0" title="0">res := resTmp.(*introspection.Type)
        fc.Result = res
        return ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)</span>
}

func (ec *executionContext) fieldContext_Query___type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) <span class="cov0" title="0">{
        fc = &amp;graphql.FieldContext{
                Object:     "Query",
                Field:      field,
                IsMethod:   true,
                IsResolver: false,
                Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) </span><span class="cov0" title="0">{
                        switch field.Name </span>{
                        case "kind":<span class="cov0" title="0">
                                return ec.fieldContext___Type_kind(ctx, field)</span>
                        case "name":<span class="cov0" title="0">
                                return ec.fieldContext___Type_name(ctx, field)</span>
                        case "description":<span class="cov0" title="0">
                                return ec.fieldContext___Type_description(ctx, field)</span>
                        case "fields":<span class="cov0" title="0">
                                return ec.fieldContext___Type_fields(ctx, field)</span>
                        case "interfaces":<span class="cov0" title="0">
                                return ec.fieldContext___Type_interfaces(ctx, field)</span>
                        case "possibleTypes":<span class="cov0" title="0">
                                return ec.fieldContext___Type_possibleTypes(ctx, field)</span>
                        case "enumValues":<span class="cov0" title="0">
                                return ec.fieldContext___Type_enumValues(ctx, field)</span>
                        case "inputFields":<span class="cov0" title="0">
                                return ec.fieldContext___Type_inputFields(ctx, field)</span>
                        case "ofType":<span class="cov0" title="0">
                                return ec.fieldContext___Type_ofType(ctx, field)</span>
                        case "specifiedByURL":<span class="cov0" title="0">
                                return ec.fieldContext___Type_specifiedByURL(ctx, field)</span>
                        }
                        <span class="cov0" title="0">return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)</span>
                },
        }
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        err = ec.Recover(ctx, r)
                        ec.Error(ctx, err)
                }</span>
        }()
        <span class="cov0" title="0">ctx = graphql.WithFieldContext(ctx, fc)
        if fc.Args, err = ec.field_Query___type_args(ctx, field.ArgumentMap(ec.Variables)); err != nil </span><span class="cov0" title="0">{
                ec.Error(ctx, err)
                return fc, err
        }</span>
        <span class="cov0" title="0">return fc, nil</span>
}

func (ec *executionContext) _Query___schema(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) <span class="cov0" title="0">{
        fc, err := ec.fieldContext_Query___schema(ctx, field)
        if err != nil </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>
        <span class="cov0" title="0">ctx = graphql.WithFieldContext(ctx, fc)
        defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        ec.Error(ctx, ec.Recover(ctx, r))
                        ret = graphql.Null
                }</span>
        }()
        <span class="cov0" title="0">resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) </span><span class="cov0" title="0">{
                ctx = rctx // use context from middleware stack in children
                return ec.introspectSchema()
        }</span>)
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                ec.Error(ctx, err)
                return graphql.Null
        }</span>
        <span class="cov0" title="0">if resTmp == nil </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>
        <span class="cov0" title="0">res := resTmp.(*introspection.Schema)
        fc.Result = res
        return ec.marshalO__Schema2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐSchema(ctx, field.Selections, res)</span>
}

func (ec *executionContext) fieldContext_Query___schema(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) <span class="cov0" title="0">{
        fc = &amp;graphql.FieldContext{
                Object:     "Query",
                Field:      field,
                IsMethod:   true,
                IsResolver: false,
                Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) </span><span class="cov0" title="0">{
                        switch field.Name </span>{
                        case "description":<span class="cov0" title="0">
                                return ec.fieldContext___Schema_description(ctx, field)</span>
                        case "types":<span class="cov0" title="0">
                                return ec.fieldContext___Schema_types(ctx, field)</span>
                        case "queryType":<span class="cov0" title="0">
                                return ec.fieldContext___Schema_queryType(ctx, field)</span>
                        case "mutationType":<span class="cov0" title="0">
                                return ec.fieldContext___Schema_mutationType(ctx, field)</span>
                        case "subscriptionType":<span class="cov0" title="0">
                                return ec.fieldContext___Schema_subscriptionType(ctx, field)</span>
                        case "directives":<span class="cov0" title="0">
                                return ec.fieldContext___Schema_directives(ctx, field)</span>
                        }
                        <span class="cov0" title="0">return nil, fmt.Errorf("no field named %q was found under type __Schema", field.Name)</span>
                },
        }
        <span class="cov0" title="0">return fc, nil</span>
}

func (ec *executionContext) _Token_token(ctx context.Context, field graphql.CollectedField, obj *Token) (ret graphql.Marshaler) <span class="cov0" title="0">{
        fc, err := ec.fieldContext_Token_token(ctx, field)
        if err != nil </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>
        <span class="cov0" title="0">ctx = graphql.WithFieldContext(ctx, fc)
        defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        ec.Error(ctx, ec.Recover(ctx, r))
                        ret = graphql.Null
                }</span>
        }()
        <span class="cov0" title="0">resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) </span><span class="cov0" title="0">{
                ctx = rctx // use context from middleware stack in children
                return obj.Token, nil
        }</span>)
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                ec.Error(ctx, err)
                return graphql.Null
        }</span>
        <span class="cov0" title="0">if resTmp == nil </span><span class="cov0" title="0">{
                if !graphql.HasFieldError(ctx, fc) </span><span class="cov0" title="0">{
                        ec.Errorf(ctx, "must not be null")
                }</span>
                <span class="cov0" title="0">return graphql.Null</span>
        }
        <span class="cov0" title="0">res := resTmp.(string)
        fc.Result = res
        return ec.marshalNString2string(ctx, field.Selections, res)</span>
}

func (ec *executionContext) fieldContext_Token_token(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) <span class="cov0" title="0">{
        fc = &amp;graphql.FieldContext{
                Object:     "Token",
                Field:      field,
                IsMethod:   false,
                IsResolver: false,
                Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) </span><span class="cov0" title="0">{
                        return nil, errors.New("field of type String does not have child fields")
                }</span>,
        }
        <span class="cov0" title="0">return fc, nil</span>
}

func (ec *executionContext) _User_id(ctx context.Context, field graphql.CollectedField, obj *User) (ret graphql.Marshaler) <span class="cov0" title="0">{
        fc, err := ec.fieldContext_User_id(ctx, field)
        if err != nil </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>
        <span class="cov0" title="0">ctx = graphql.WithFieldContext(ctx, fc)
        defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        ec.Error(ctx, ec.Recover(ctx, r))
                        ret = graphql.Null
                }</span>
        }()
        <span class="cov0" title="0">resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) </span><span class="cov0" title="0">{
                ctx = rctx // use context from middleware stack in children
                return obj.ID, nil
        }</span>)
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                ec.Error(ctx, err)
                return graphql.Null
        }</span>
        <span class="cov0" title="0">if resTmp == nil </span><span class="cov0" title="0">{
                if !graphql.HasFieldError(ctx, fc) </span><span class="cov0" title="0">{
                        ec.Errorf(ctx, "must not be null")
                }</span>
                <span class="cov0" title="0">return graphql.Null</span>
        }
        <span class="cov0" title="0">res := resTmp.(string)
        fc.Result = res
        return ec.marshalNString2string(ctx, field.Selections, res)</span>
}

func (ec *executionContext) fieldContext_User_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) <span class="cov0" title="0">{
        fc = &amp;graphql.FieldContext{
                Object:     "User",
                Field:      field,
                IsMethod:   false,
                IsResolver: false,
                Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) </span><span class="cov0" title="0">{
                        return nil, errors.New("field of type String does not have child fields")
                }</span>,
        }
        <span class="cov0" title="0">return fc, nil</span>
}

func (ec *executionContext) _User_name(ctx context.Context, field graphql.CollectedField, obj *User) (ret graphql.Marshaler) <span class="cov0" title="0">{
        fc, err := ec.fieldContext_User_name(ctx, field)
        if err != nil </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>
        <span class="cov0" title="0">ctx = graphql.WithFieldContext(ctx, fc)
        defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        ec.Error(ctx, ec.Recover(ctx, r))
                        ret = graphql.Null
                }</span>
        }()
        <span class="cov0" title="0">resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) </span><span class="cov0" title="0">{
                ctx = rctx // use context from middleware stack in children
                return obj.Name, nil
        }</span>)
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                ec.Error(ctx, err)
                return graphql.Null
        }</span>
        <span class="cov0" title="0">if resTmp == nil </span><span class="cov0" title="0">{
                if !graphql.HasFieldError(ctx, fc) </span><span class="cov0" title="0">{
                        ec.Errorf(ctx, "must not be null")
                }</span>
                <span class="cov0" title="0">return graphql.Null</span>
        }
        <span class="cov0" title="0">res := resTmp.(string)
        fc.Result = res
        return ec.marshalNString2string(ctx, field.Selections, res)</span>
}

func (ec *executionContext) fieldContext_User_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) <span class="cov0" title="0">{
        fc = &amp;graphql.FieldContext{
                Object:     "User",
                Field:      field,
                IsMethod:   false,
                IsResolver: false,
                Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) </span><span class="cov0" title="0">{
                        return nil, errors.New("field of type String does not have child fields")
                }</span>,
        }
        <span class="cov0" title="0">return fc, nil</span>
}

func (ec *executionContext) _User_permissions(ctx context.Context, field graphql.CollectedField, obj *User) (ret graphql.Marshaler) <span class="cov0" title="0">{
        fc, err := ec.fieldContext_User_permissions(ctx, field)
        if err != nil </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>
        <span class="cov0" title="0">ctx = graphql.WithFieldContext(ctx, fc)
        defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        ec.Error(ctx, ec.Recover(ctx, r))
                        ret = graphql.Null
                }</span>
        }()
        <span class="cov0" title="0">resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) </span><span class="cov0" title="0">{
                ctx = rctx // use context from middleware stack in children
                return obj.Permissions, nil
        }</span>)
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                ec.Error(ctx, err)
                return graphql.Null
        }</span>
        <span class="cov0" title="0">if resTmp == nil </span><span class="cov0" title="0">{
                if !graphql.HasFieldError(ctx, fc) </span><span class="cov0" title="0">{
                        ec.Errorf(ctx, "must not be null")
                }</span>
                <span class="cov0" title="0">return graphql.Null</span>
        }
        <span class="cov0" title="0">res := resTmp.([]string)
        fc.Result = res
        return ec.marshalNString2ᚕstringᚄ(ctx, field.Selections, res)</span>
}

func (ec *executionContext) fieldContext_User_permissions(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) <span class="cov0" title="0">{
        fc = &amp;graphql.FieldContext{
                Object:     "User",
                Field:      field,
                IsMethod:   false,
                IsResolver: false,
                Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) </span><span class="cov0" title="0">{
                        return nil, errors.New("field of type String does not have child fields")
                }</span>,
        }
        <span class="cov0" title="0">return fc, nil</span>
}

func (ec *executionContext) _User_login(ctx context.Context, field graphql.CollectedField, obj *User) (ret graphql.Marshaler) <span class="cov0" title="0">{
        fc, err := ec.fieldContext_User_login(ctx, field)
        if err != nil </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>
        <span class="cov0" title="0">ctx = graphql.WithFieldContext(ctx, fc)
        defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        ec.Error(ctx, ec.Recover(ctx, r))
                        ret = graphql.Null
                }</span>
        }()
        <span class="cov0" title="0">resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) </span><span class="cov0" title="0">{
                ctx = rctx // use context from middleware stack in children
                return obj.Login, nil
        }</span>)
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                ec.Error(ctx, err)
                return graphql.Null
        }</span>
        <span class="cov0" title="0">if resTmp == nil </span><span class="cov0" title="0">{
                if !graphql.HasFieldError(ctx, fc) </span><span class="cov0" title="0">{
                        ec.Errorf(ctx, "must not be null")
                }</span>
                <span class="cov0" title="0">return graphql.Null</span>
        }
        <span class="cov0" title="0">res := resTmp.(string)
        fc.Result = res
        return ec.marshalNString2string(ctx, field.Selections, res)</span>
}

func (ec *executionContext) fieldContext_User_login(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) <span class="cov0" title="0">{
        fc = &amp;graphql.FieldContext{
                Object:     "User",
                Field:      field,
                IsMethod:   false,
                IsResolver: false,
                Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) </span><span class="cov0" title="0">{
                        return nil, errors.New("field of type String does not have child fields")
                }</span>,
        }
        <span class="cov0" title="0">return fc, nil</span>
}

func (ec *executionContext) _User_enabled(ctx context.Context, field graphql.CollectedField, obj *User) (ret graphql.Marshaler) <span class="cov0" title="0">{
        fc, err := ec.fieldContext_User_enabled(ctx, field)
        if err != nil </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>
        <span class="cov0" title="0">ctx = graphql.WithFieldContext(ctx, fc)
        defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        ec.Error(ctx, ec.Recover(ctx, r))
                        ret = graphql.Null
                }</span>
        }()
        <span class="cov0" title="0">resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) </span><span class="cov0" title="0">{
                ctx = rctx // use context from middleware stack in children
                return obj.Enabled, nil
        }</span>)
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                ec.Error(ctx, err)
                return graphql.Null
        }</span>
        <span class="cov0" title="0">if resTmp == nil </span><span class="cov0" title="0">{
                if !graphql.HasFieldError(ctx, fc) </span><span class="cov0" title="0">{
                        ec.Errorf(ctx, "must not be null")
                }</span>
                <span class="cov0" title="0">return graphql.Null</span>
        }
        <span class="cov0" title="0">res := resTmp.(bool)
        fc.Result = res
        return ec.marshalNBoolean2bool(ctx, field.Selections, res)</span>
}

func (ec *executionContext) fieldContext_User_enabled(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) <span class="cov0" title="0">{
        fc = &amp;graphql.FieldContext{
                Object:     "User",
                Field:      field,
                IsMethod:   false,
                IsResolver: false,
                Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) </span><span class="cov0" title="0">{
                        return nil, errors.New("field of type Boolean does not have child fields")
                }</span>,
        }
        <span class="cov0" title="0">return fc, nil</span>
}

func (ec *executionContext) __Service_sdl(ctx context.Context, field graphql.CollectedField, obj *fedruntime.Service) (ret graphql.Marshaler) <span class="cov0" title="0">{
        fc, err := ec.fieldContext__Service_sdl(ctx, field)
        if err != nil </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>
        <span class="cov0" title="0">ctx = graphql.WithFieldContext(ctx, fc)
        defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        ec.Error(ctx, ec.Recover(ctx, r))
                        ret = graphql.Null
                }</span>
        }()
        <span class="cov0" title="0">resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) </span><span class="cov0" title="0">{
                ctx = rctx // use context from middleware stack in children
                return obj.SDL, nil
        }</span>)
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                ec.Error(ctx, err)
                return graphql.Null
        }</span>
        <span class="cov0" title="0">if resTmp == nil </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>
        <span class="cov0" title="0">res := resTmp.(string)
        fc.Result = res
        return ec.marshalOString2string(ctx, field.Selections, res)</span>
}

func (ec *executionContext) fieldContext__Service_sdl(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) <span class="cov0" title="0">{
        fc = &amp;graphql.FieldContext{
                Object:     "_Service",
                Field:      field,
                IsMethod:   false,
                IsResolver: false,
                Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) </span><span class="cov0" title="0">{
                        return nil, errors.New("field of type String does not have child fields")
                }</span>,
        }
        <span class="cov0" title="0">return fc, nil</span>
}

func (ec *executionContext) ___Directive_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) <span class="cov0" title="0">{
        fc, err := ec.fieldContext___Directive_name(ctx, field)
        if err != nil </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>
        <span class="cov0" title="0">ctx = graphql.WithFieldContext(ctx, fc)
        defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        ec.Error(ctx, ec.Recover(ctx, r))
                        ret = graphql.Null
                }</span>
        }()
        <span class="cov0" title="0">resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) </span><span class="cov0" title="0">{
                ctx = rctx // use context from middleware stack in children
                return obj.Name, nil
        }</span>)
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                ec.Error(ctx, err)
                return graphql.Null
        }</span>
        <span class="cov0" title="0">if resTmp == nil </span><span class="cov0" title="0">{
                if !graphql.HasFieldError(ctx, fc) </span><span class="cov0" title="0">{
                        ec.Errorf(ctx, "must not be null")
                }</span>
                <span class="cov0" title="0">return graphql.Null</span>
        }
        <span class="cov0" title="0">res := resTmp.(string)
        fc.Result = res
        return ec.marshalNString2string(ctx, field.Selections, res)</span>
}

func (ec *executionContext) fieldContext___Directive_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) <span class="cov0" title="0">{
        fc = &amp;graphql.FieldContext{
                Object:     "__Directive",
                Field:      field,
                IsMethod:   false,
                IsResolver: false,
                Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) </span><span class="cov0" title="0">{
                        return nil, errors.New("field of type String does not have child fields")
                }</span>,
        }
        <span class="cov0" title="0">return fc, nil</span>
}

func (ec *executionContext) ___Directive_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) <span class="cov0" title="0">{
        fc, err := ec.fieldContext___Directive_description(ctx, field)
        if err != nil </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>
        <span class="cov0" title="0">ctx = graphql.WithFieldContext(ctx, fc)
        defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        ec.Error(ctx, ec.Recover(ctx, r))
                        ret = graphql.Null
                }</span>
        }()
        <span class="cov0" title="0">resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) </span><span class="cov0" title="0">{
                ctx = rctx // use context from middleware stack in children
                return obj.Description(), nil
        }</span>)
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                ec.Error(ctx, err)
                return graphql.Null
        }</span>
        <span class="cov0" title="0">if resTmp == nil </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>
        <span class="cov0" title="0">res := resTmp.(*string)
        fc.Result = res
        return ec.marshalOString2ᚖstring(ctx, field.Selections, res)</span>
}

func (ec *executionContext) fieldContext___Directive_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) <span class="cov0" title="0">{
        fc = &amp;graphql.FieldContext{
                Object:     "__Directive",
                Field:      field,
                IsMethod:   true,
                IsResolver: false,
                Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) </span><span class="cov0" title="0">{
                        return nil, errors.New("field of type String does not have child fields")
                }</span>,
        }
        <span class="cov0" title="0">return fc, nil</span>
}

func (ec *executionContext) ___Directive_locations(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) <span class="cov0" title="0">{
        fc, err := ec.fieldContext___Directive_locations(ctx, field)
        if err != nil </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>
        <span class="cov0" title="0">ctx = graphql.WithFieldContext(ctx, fc)
        defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        ec.Error(ctx, ec.Recover(ctx, r))
                        ret = graphql.Null
                }</span>
        }()
        <span class="cov0" title="0">resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) </span><span class="cov0" title="0">{
                ctx = rctx // use context from middleware stack in children
                return obj.Locations, nil
        }</span>)
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                ec.Error(ctx, err)
                return graphql.Null
        }</span>
        <span class="cov0" title="0">if resTmp == nil </span><span class="cov0" title="0">{
                if !graphql.HasFieldError(ctx, fc) </span><span class="cov0" title="0">{
                        ec.Errorf(ctx, "must not be null")
                }</span>
                <span class="cov0" title="0">return graphql.Null</span>
        }
        <span class="cov0" title="0">res := resTmp.([]string)
        fc.Result = res
        return ec.marshalN__DirectiveLocation2ᚕstringᚄ(ctx, field.Selections, res)</span>
}

func (ec *executionContext) fieldContext___Directive_locations(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) <span class="cov0" title="0">{
        fc = &amp;graphql.FieldContext{
                Object:     "__Directive",
                Field:      field,
                IsMethod:   false,
                IsResolver: false,
                Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) </span><span class="cov0" title="0">{
                        return nil, errors.New("field of type __DirectiveLocation does not have child fields")
                }</span>,
        }
        <span class="cov0" title="0">return fc, nil</span>
}

func (ec *executionContext) ___Directive_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) <span class="cov0" title="0">{
        fc, err := ec.fieldContext___Directive_args(ctx, field)
        if err != nil </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>
        <span class="cov0" title="0">ctx = graphql.WithFieldContext(ctx, fc)
        defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        ec.Error(ctx, ec.Recover(ctx, r))
                        ret = graphql.Null
                }</span>
        }()
        <span class="cov0" title="0">resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) </span><span class="cov0" title="0">{
                ctx = rctx // use context from middleware stack in children
                return obj.Args, nil
        }</span>)
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                ec.Error(ctx, err)
                return graphql.Null
        }</span>
        <span class="cov0" title="0">if resTmp == nil </span><span class="cov0" title="0">{
                if !graphql.HasFieldError(ctx, fc) </span><span class="cov0" title="0">{
                        ec.Errorf(ctx, "must not be null")
                }</span>
                <span class="cov0" title="0">return graphql.Null</span>
        }
        <span class="cov0" title="0">res := resTmp.([]introspection.InputValue)
        fc.Result = res
        return ec.marshalN__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx, field.Selections, res)</span>
}

func (ec *executionContext) fieldContext___Directive_args(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) <span class="cov0" title="0">{
        fc = &amp;graphql.FieldContext{
                Object:     "__Directive",
                Field:      field,
                IsMethod:   false,
                IsResolver: false,
                Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) </span><span class="cov0" title="0">{
                        switch field.Name </span>{
                        case "name":<span class="cov0" title="0">
                                return ec.fieldContext___InputValue_name(ctx, field)</span>
                        case "description":<span class="cov0" title="0">
                                return ec.fieldContext___InputValue_description(ctx, field)</span>
                        case "type":<span class="cov0" title="0">
                                return ec.fieldContext___InputValue_type(ctx, field)</span>
                        case "defaultValue":<span class="cov0" title="0">
                                return ec.fieldContext___InputValue_defaultValue(ctx, field)</span>
                        }
                        <span class="cov0" title="0">return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)</span>
                },
        }
        <span class="cov0" title="0">return fc, nil</span>
}

func (ec *executionContext) ___Directive_isRepeatable(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) <span class="cov0" title="0">{
        fc, err := ec.fieldContext___Directive_isRepeatable(ctx, field)
        if err != nil </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>
        <span class="cov0" title="0">ctx = graphql.WithFieldContext(ctx, fc)
        defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        ec.Error(ctx, ec.Recover(ctx, r))
                        ret = graphql.Null
                }</span>
        }()
        <span class="cov0" title="0">resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) </span><span class="cov0" title="0">{
                ctx = rctx // use context from middleware stack in children
                return obj.IsRepeatable, nil
        }</span>)
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                ec.Error(ctx, err)
                return graphql.Null
        }</span>
        <span class="cov0" title="0">if resTmp == nil </span><span class="cov0" title="0">{
                if !graphql.HasFieldError(ctx, fc) </span><span class="cov0" title="0">{
                        ec.Errorf(ctx, "must not be null")
                }</span>
                <span class="cov0" title="0">return graphql.Null</span>
        }
        <span class="cov0" title="0">res := resTmp.(bool)
        fc.Result = res
        return ec.marshalNBoolean2bool(ctx, field.Selections, res)</span>
}

func (ec *executionContext) fieldContext___Directive_isRepeatable(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) <span class="cov0" title="0">{
        fc = &amp;graphql.FieldContext{
                Object:     "__Directive",
                Field:      field,
                IsMethod:   false,
                IsResolver: false,
                Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) </span><span class="cov0" title="0">{
                        return nil, errors.New("field of type Boolean does not have child fields")
                }</span>,
        }
        <span class="cov0" title="0">return fc, nil</span>
}

func (ec *executionContext) ___EnumValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) <span class="cov0" title="0">{
        fc, err := ec.fieldContext___EnumValue_name(ctx, field)
        if err != nil </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>
        <span class="cov0" title="0">ctx = graphql.WithFieldContext(ctx, fc)
        defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        ec.Error(ctx, ec.Recover(ctx, r))
                        ret = graphql.Null
                }</span>
        }()
        <span class="cov0" title="0">resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) </span><span class="cov0" title="0">{
                ctx = rctx // use context from middleware stack in children
                return obj.Name, nil
        }</span>)
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                ec.Error(ctx, err)
                return graphql.Null
        }</span>
        <span class="cov0" title="0">if resTmp == nil </span><span class="cov0" title="0">{
                if !graphql.HasFieldError(ctx, fc) </span><span class="cov0" title="0">{
                        ec.Errorf(ctx, "must not be null")
                }</span>
                <span class="cov0" title="0">return graphql.Null</span>
        }
        <span class="cov0" title="0">res := resTmp.(string)
        fc.Result = res
        return ec.marshalNString2string(ctx, field.Selections, res)</span>
}

func (ec *executionContext) fieldContext___EnumValue_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) <span class="cov0" title="0">{
        fc = &amp;graphql.FieldContext{
                Object:     "__EnumValue",
                Field:      field,
                IsMethod:   false,
                IsResolver: false,
                Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) </span><span class="cov0" title="0">{
                        return nil, errors.New("field of type String does not have child fields")
                }</span>,
        }
        <span class="cov0" title="0">return fc, nil</span>
}

func (ec *executionContext) ___EnumValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) <span class="cov0" title="0">{
        fc, err := ec.fieldContext___EnumValue_description(ctx, field)
        if err != nil </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>
        <span class="cov0" title="0">ctx = graphql.WithFieldContext(ctx, fc)
        defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        ec.Error(ctx, ec.Recover(ctx, r))
                        ret = graphql.Null
                }</span>
        }()
        <span class="cov0" title="0">resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) </span><span class="cov0" title="0">{
                ctx = rctx // use context from middleware stack in children
                return obj.Description(), nil
        }</span>)
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                ec.Error(ctx, err)
                return graphql.Null
        }</span>
        <span class="cov0" title="0">if resTmp == nil </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>
        <span class="cov0" title="0">res := resTmp.(*string)
        fc.Result = res
        return ec.marshalOString2ᚖstring(ctx, field.Selections, res)</span>
}

func (ec *executionContext) fieldContext___EnumValue_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) <span class="cov0" title="0">{
        fc = &amp;graphql.FieldContext{
                Object:     "__EnumValue",
                Field:      field,
                IsMethod:   true,
                IsResolver: false,
                Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) </span><span class="cov0" title="0">{
                        return nil, errors.New("field of type String does not have child fields")
                }</span>,
        }
        <span class="cov0" title="0">return fc, nil</span>
}

func (ec *executionContext) ___EnumValue_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) <span class="cov0" title="0">{
        fc, err := ec.fieldContext___EnumValue_isDeprecated(ctx, field)
        if err != nil </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>
        <span class="cov0" title="0">ctx = graphql.WithFieldContext(ctx, fc)
        defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        ec.Error(ctx, ec.Recover(ctx, r))
                        ret = graphql.Null
                }</span>
        }()
        <span class="cov0" title="0">resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) </span><span class="cov0" title="0">{
                ctx = rctx // use context from middleware stack in children
                return obj.IsDeprecated(), nil
        }</span>)
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                ec.Error(ctx, err)
                return graphql.Null
        }</span>
        <span class="cov0" title="0">if resTmp == nil </span><span class="cov0" title="0">{
                if !graphql.HasFieldError(ctx, fc) </span><span class="cov0" title="0">{
                        ec.Errorf(ctx, "must not be null")
                }</span>
                <span class="cov0" title="0">return graphql.Null</span>
        }
        <span class="cov0" title="0">res := resTmp.(bool)
        fc.Result = res
        return ec.marshalNBoolean2bool(ctx, field.Selections, res)</span>
}

func (ec *executionContext) fieldContext___EnumValue_isDeprecated(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) <span class="cov0" title="0">{
        fc = &amp;graphql.FieldContext{
                Object:     "__EnumValue",
                Field:      field,
                IsMethod:   true,
                IsResolver: false,
                Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) </span><span class="cov0" title="0">{
                        return nil, errors.New("field of type Boolean does not have child fields")
                }</span>,
        }
        <span class="cov0" title="0">return fc, nil</span>
}

func (ec *executionContext) ___EnumValue_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) <span class="cov0" title="0">{
        fc, err := ec.fieldContext___EnumValue_deprecationReason(ctx, field)
        if err != nil </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>
        <span class="cov0" title="0">ctx = graphql.WithFieldContext(ctx, fc)
        defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        ec.Error(ctx, ec.Recover(ctx, r))
                        ret = graphql.Null
                }</span>
        }()
        <span class="cov0" title="0">resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) </span><span class="cov0" title="0">{
                ctx = rctx // use context from middleware stack in children
                return obj.DeprecationReason(), nil
        }</span>)
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                ec.Error(ctx, err)
                return graphql.Null
        }</span>
        <span class="cov0" title="0">if resTmp == nil </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>
        <span class="cov0" title="0">res := resTmp.(*string)
        fc.Result = res
        return ec.marshalOString2ᚖstring(ctx, field.Selections, res)</span>
}

func (ec *executionContext) fieldContext___EnumValue_deprecationReason(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) <span class="cov0" title="0">{
        fc = &amp;graphql.FieldContext{
                Object:     "__EnumValue",
                Field:      field,
                IsMethod:   true,
                IsResolver: false,
                Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) </span><span class="cov0" title="0">{
                        return nil, errors.New("field of type String does not have child fields")
                }</span>,
        }
        <span class="cov0" title="0">return fc, nil</span>
}

func (ec *executionContext) ___Field_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) <span class="cov0" title="0">{
        fc, err := ec.fieldContext___Field_name(ctx, field)
        if err != nil </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>
        <span class="cov0" title="0">ctx = graphql.WithFieldContext(ctx, fc)
        defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        ec.Error(ctx, ec.Recover(ctx, r))
                        ret = graphql.Null
                }</span>
        }()
        <span class="cov0" title="0">resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) </span><span class="cov0" title="0">{
                ctx = rctx // use context from middleware stack in children
                return obj.Name, nil
        }</span>)
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                ec.Error(ctx, err)
                return graphql.Null
        }</span>
        <span class="cov0" title="0">if resTmp == nil </span><span class="cov0" title="0">{
                if !graphql.HasFieldError(ctx, fc) </span><span class="cov0" title="0">{
                        ec.Errorf(ctx, "must not be null")
                }</span>
                <span class="cov0" title="0">return graphql.Null</span>
        }
        <span class="cov0" title="0">res := resTmp.(string)
        fc.Result = res
        return ec.marshalNString2string(ctx, field.Selections, res)</span>
}

func (ec *executionContext) fieldContext___Field_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) <span class="cov0" title="0">{
        fc = &amp;graphql.FieldContext{
                Object:     "__Field",
                Field:      field,
                IsMethod:   false,
                IsResolver: false,
                Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) </span><span class="cov0" title="0">{
                        return nil, errors.New("field of type String does not have child fields")
                }</span>,
        }
        <span class="cov0" title="0">return fc, nil</span>
}

func (ec *executionContext) ___Field_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) <span class="cov0" title="0">{
        fc, err := ec.fieldContext___Field_description(ctx, field)
        if err != nil </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>
        <span class="cov0" title="0">ctx = graphql.WithFieldContext(ctx, fc)
        defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        ec.Error(ctx, ec.Recover(ctx, r))
                        ret = graphql.Null
                }</span>
        }()
        <span class="cov0" title="0">resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) </span><span class="cov0" title="0">{
                ctx = rctx // use context from middleware stack in children
                return obj.Description(), nil
        }</span>)
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                ec.Error(ctx, err)
                return graphql.Null
        }</span>
        <span class="cov0" title="0">if resTmp == nil </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>
        <span class="cov0" title="0">res := resTmp.(*string)
        fc.Result = res
        return ec.marshalOString2ᚖstring(ctx, field.Selections, res)</span>
}

func (ec *executionContext) fieldContext___Field_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) <span class="cov0" title="0">{
        fc = &amp;graphql.FieldContext{
                Object:     "__Field",
                Field:      field,
                IsMethod:   true,
                IsResolver: false,
                Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) </span><span class="cov0" title="0">{
                        return nil, errors.New("field of type String does not have child fields")
                }</span>,
        }
        <span class="cov0" title="0">return fc, nil</span>
}

func (ec *executionContext) ___Field_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) <span class="cov0" title="0">{
        fc, err := ec.fieldContext___Field_args(ctx, field)
        if err != nil </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>
        <span class="cov0" title="0">ctx = graphql.WithFieldContext(ctx, fc)
        defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        ec.Error(ctx, ec.Recover(ctx, r))
                        ret = graphql.Null
                }</span>
        }()
        <span class="cov0" title="0">resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) </span><span class="cov0" title="0">{
                ctx = rctx // use context from middleware stack in children
                return obj.Args, nil
        }</span>)
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                ec.Error(ctx, err)
                return graphql.Null
        }</span>
        <span class="cov0" title="0">if resTmp == nil </span><span class="cov0" title="0">{
                if !graphql.HasFieldError(ctx, fc) </span><span class="cov0" title="0">{
                        ec.Errorf(ctx, "must not be null")
                }</span>
                <span class="cov0" title="0">return graphql.Null</span>
        }
        <span class="cov0" title="0">res := resTmp.([]introspection.InputValue)
        fc.Result = res
        return ec.marshalN__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx, field.Selections, res)</span>
}

func (ec *executionContext) fieldContext___Field_args(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) <span class="cov0" title="0">{
        fc = &amp;graphql.FieldContext{
                Object:     "__Field",
                Field:      field,
                IsMethod:   false,
                IsResolver: false,
                Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) </span><span class="cov0" title="0">{
                        switch field.Name </span>{
                        case "name":<span class="cov0" title="0">
                                return ec.fieldContext___InputValue_name(ctx, field)</span>
                        case "description":<span class="cov0" title="0">
                                return ec.fieldContext___InputValue_description(ctx, field)</span>
                        case "type":<span class="cov0" title="0">
                                return ec.fieldContext___InputValue_type(ctx, field)</span>
                        case "defaultValue":<span class="cov0" title="0">
                                return ec.fieldContext___InputValue_defaultValue(ctx, field)</span>
                        }
                        <span class="cov0" title="0">return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)</span>
                },
        }
        <span class="cov0" title="0">return fc, nil</span>
}

func (ec *executionContext) ___Field_type(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) <span class="cov0" title="0">{
        fc, err := ec.fieldContext___Field_type(ctx, field)
        if err != nil </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>
        <span class="cov0" title="0">ctx = graphql.WithFieldContext(ctx, fc)
        defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        ec.Error(ctx, ec.Recover(ctx, r))
                        ret = graphql.Null
                }</span>
        }()
        <span class="cov0" title="0">resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) </span><span class="cov0" title="0">{
                ctx = rctx // use context from middleware stack in children
                return obj.Type, nil
        }</span>)
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                ec.Error(ctx, err)
                return graphql.Null
        }</span>
        <span class="cov0" title="0">if resTmp == nil </span><span class="cov0" title="0">{
                if !graphql.HasFieldError(ctx, fc) </span><span class="cov0" title="0">{
                        ec.Errorf(ctx, "must not be null")
                }</span>
                <span class="cov0" title="0">return graphql.Null</span>
        }
        <span class="cov0" title="0">res := resTmp.(*introspection.Type)
        fc.Result = res
        return ec.marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)</span>
}

func (ec *executionContext) fieldContext___Field_type(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) <span class="cov0" title="0">{
        fc = &amp;graphql.FieldContext{
                Object:     "__Field",
                Field:      field,
                IsMethod:   false,
                IsResolver: false,
                Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) </span><span class="cov0" title="0">{
                        switch field.Name </span>{
                        case "kind":<span class="cov0" title="0">
                                return ec.fieldContext___Type_kind(ctx, field)</span>
                        case "name":<span class="cov0" title="0">
                                return ec.fieldContext___Type_name(ctx, field)</span>
                        case "description":<span class="cov0" title="0">
                                return ec.fieldContext___Type_description(ctx, field)</span>
                        case "fields":<span class="cov0" title="0">
                                return ec.fieldContext___Type_fields(ctx, field)</span>
                        case "interfaces":<span class="cov0" title="0">
                                return ec.fieldContext___Type_interfaces(ctx, field)</span>
                        case "possibleTypes":<span class="cov0" title="0">
                                return ec.fieldContext___Type_possibleTypes(ctx, field)</span>
                        case "enumValues":<span class="cov0" title="0">
                                return ec.fieldContext___Type_enumValues(ctx, field)</span>
                        case "inputFields":<span class="cov0" title="0">
                                return ec.fieldContext___Type_inputFields(ctx, field)</span>
                        case "ofType":<span class="cov0" title="0">
                                return ec.fieldContext___Type_ofType(ctx, field)</span>
                        case "specifiedByURL":<span class="cov0" title="0">
                                return ec.fieldContext___Type_specifiedByURL(ctx, field)</span>
                        }
                        <span class="cov0" title="0">return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)</span>
                },
        }
        <span class="cov0" title="0">return fc, nil</span>
}

func (ec *executionContext) ___Field_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) <span class="cov0" title="0">{
        fc, err := ec.fieldContext___Field_isDeprecated(ctx, field)
        if err != nil </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>
        <span class="cov0" title="0">ctx = graphql.WithFieldContext(ctx, fc)
        defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        ec.Error(ctx, ec.Recover(ctx, r))
                        ret = graphql.Null
                }</span>
        }()
        <span class="cov0" title="0">resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) </span><span class="cov0" title="0">{
                ctx = rctx // use context from middleware stack in children
                return obj.IsDeprecated(), nil
        }</span>)
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                ec.Error(ctx, err)
                return graphql.Null
        }</span>
        <span class="cov0" title="0">if resTmp == nil </span><span class="cov0" title="0">{
                if !graphql.HasFieldError(ctx, fc) </span><span class="cov0" title="0">{
                        ec.Errorf(ctx, "must not be null")
                }</span>
                <span class="cov0" title="0">return graphql.Null</span>
        }
        <span class="cov0" title="0">res := resTmp.(bool)
        fc.Result = res
        return ec.marshalNBoolean2bool(ctx, field.Selections, res)</span>
}

func (ec *executionContext) fieldContext___Field_isDeprecated(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) <span class="cov0" title="0">{
        fc = &amp;graphql.FieldContext{
                Object:     "__Field",
                Field:      field,
                IsMethod:   true,
                IsResolver: false,
                Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) </span><span class="cov0" title="0">{
                        return nil, errors.New("field of type Boolean does not have child fields")
                }</span>,
        }
        <span class="cov0" title="0">return fc, nil</span>
}

func (ec *executionContext) ___Field_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) <span class="cov0" title="0">{
        fc, err := ec.fieldContext___Field_deprecationReason(ctx, field)
        if err != nil </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>
        <span class="cov0" title="0">ctx = graphql.WithFieldContext(ctx, fc)
        defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        ec.Error(ctx, ec.Recover(ctx, r))
                        ret = graphql.Null
                }</span>
        }()
        <span class="cov0" title="0">resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) </span><span class="cov0" title="0">{
                ctx = rctx // use context from middleware stack in children
                return obj.DeprecationReason(), nil
        }</span>)
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                ec.Error(ctx, err)
                return graphql.Null
        }</span>
        <span class="cov0" title="0">if resTmp == nil </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>
        <span class="cov0" title="0">res := resTmp.(*string)
        fc.Result = res
        return ec.marshalOString2ᚖstring(ctx, field.Selections, res)</span>
}

func (ec *executionContext) fieldContext___Field_deprecationReason(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) <span class="cov0" title="0">{
        fc = &amp;graphql.FieldContext{
                Object:     "__Field",
                Field:      field,
                IsMethod:   true,
                IsResolver: false,
                Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) </span><span class="cov0" title="0">{
                        return nil, errors.New("field of type String does not have child fields")
                }</span>,
        }
        <span class="cov0" title="0">return fc, nil</span>
}

func (ec *executionContext) ___InputValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) <span class="cov0" title="0">{
        fc, err := ec.fieldContext___InputValue_name(ctx, field)
        if err != nil </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>
        <span class="cov0" title="0">ctx = graphql.WithFieldContext(ctx, fc)
        defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        ec.Error(ctx, ec.Recover(ctx, r))
                        ret = graphql.Null
                }</span>
        }()
        <span class="cov0" title="0">resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) </span><span class="cov0" title="0">{
                ctx = rctx // use context from middleware stack in children
                return obj.Name, nil
        }</span>)
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                ec.Error(ctx, err)
                return graphql.Null
        }</span>
        <span class="cov0" title="0">if resTmp == nil </span><span class="cov0" title="0">{
                if !graphql.HasFieldError(ctx, fc) </span><span class="cov0" title="0">{
                        ec.Errorf(ctx, "must not be null")
                }</span>
                <span class="cov0" title="0">return graphql.Null</span>
        }
        <span class="cov0" title="0">res := resTmp.(string)
        fc.Result = res
        return ec.marshalNString2string(ctx, field.Selections, res)</span>
}

func (ec *executionContext) fieldContext___InputValue_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) <span class="cov0" title="0">{
        fc = &amp;graphql.FieldContext{
                Object:     "__InputValue",
                Field:      field,
                IsMethod:   false,
                IsResolver: false,
                Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) </span><span class="cov0" title="0">{
                        return nil, errors.New("field of type String does not have child fields")
                }</span>,
        }
        <span class="cov0" title="0">return fc, nil</span>
}

func (ec *executionContext) ___InputValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) <span class="cov0" title="0">{
        fc, err := ec.fieldContext___InputValue_description(ctx, field)
        if err != nil </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>
        <span class="cov0" title="0">ctx = graphql.WithFieldContext(ctx, fc)
        defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        ec.Error(ctx, ec.Recover(ctx, r))
                        ret = graphql.Null
                }</span>
        }()
        <span class="cov0" title="0">resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) </span><span class="cov0" title="0">{
                ctx = rctx // use context from middleware stack in children
                return obj.Description(), nil
        }</span>)
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                ec.Error(ctx, err)
                return graphql.Null
        }</span>
        <span class="cov0" title="0">if resTmp == nil </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>
        <span class="cov0" title="0">res := resTmp.(*string)
        fc.Result = res
        return ec.marshalOString2ᚖstring(ctx, field.Selections, res)</span>
}

func (ec *executionContext) fieldContext___InputValue_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) <span class="cov0" title="0">{
        fc = &amp;graphql.FieldContext{
                Object:     "__InputValue",
                Field:      field,
                IsMethod:   true,
                IsResolver: false,
                Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) </span><span class="cov0" title="0">{
                        return nil, errors.New("field of type String does not have child fields")
                }</span>,
        }
        <span class="cov0" title="0">return fc, nil</span>
}

func (ec *executionContext) ___InputValue_type(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) <span class="cov0" title="0">{
        fc, err := ec.fieldContext___InputValue_type(ctx, field)
        if err != nil </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>
        <span class="cov0" title="0">ctx = graphql.WithFieldContext(ctx, fc)
        defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        ec.Error(ctx, ec.Recover(ctx, r))
                        ret = graphql.Null
                }</span>
        }()
        <span class="cov0" title="0">resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) </span><span class="cov0" title="0">{
                ctx = rctx // use context from middleware stack in children
                return obj.Type, nil
        }</span>)
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                ec.Error(ctx, err)
                return graphql.Null
        }</span>
        <span class="cov0" title="0">if resTmp == nil </span><span class="cov0" title="0">{
                if !graphql.HasFieldError(ctx, fc) </span><span class="cov0" title="0">{
                        ec.Errorf(ctx, "must not be null")
                }</span>
                <span class="cov0" title="0">return graphql.Null</span>
        }
        <span class="cov0" title="0">res := resTmp.(*introspection.Type)
        fc.Result = res
        return ec.marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)</span>
}

func (ec *executionContext) fieldContext___InputValue_type(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) <span class="cov0" title="0">{
        fc = &amp;graphql.FieldContext{
                Object:     "__InputValue",
                Field:      field,
                IsMethod:   false,
                IsResolver: false,
                Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) </span><span class="cov0" title="0">{
                        switch field.Name </span>{
                        case "kind":<span class="cov0" title="0">
                                return ec.fieldContext___Type_kind(ctx, field)</span>
                        case "name":<span class="cov0" title="0">
                                return ec.fieldContext___Type_name(ctx, field)</span>
                        case "description":<span class="cov0" title="0">
                                return ec.fieldContext___Type_description(ctx, field)</span>
                        case "fields":<span class="cov0" title="0">
                                return ec.fieldContext___Type_fields(ctx, field)</span>
                        case "interfaces":<span class="cov0" title="0">
                                return ec.fieldContext___Type_interfaces(ctx, field)</span>
                        case "possibleTypes":<span class="cov0" title="0">
                                return ec.fieldContext___Type_possibleTypes(ctx, field)</span>
                        case "enumValues":<span class="cov0" title="0">
                                return ec.fieldContext___Type_enumValues(ctx, field)</span>
                        case "inputFields":<span class="cov0" title="0">
                                return ec.fieldContext___Type_inputFields(ctx, field)</span>
                        case "ofType":<span class="cov0" title="0">
                                return ec.fieldContext___Type_ofType(ctx, field)</span>
                        case "specifiedByURL":<span class="cov0" title="0">
                                return ec.fieldContext___Type_specifiedByURL(ctx, field)</span>
                        }
                        <span class="cov0" title="0">return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)</span>
                },
        }
        <span class="cov0" title="0">return fc, nil</span>
}

func (ec *executionContext) ___InputValue_defaultValue(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) <span class="cov0" title="0">{
        fc, err := ec.fieldContext___InputValue_defaultValue(ctx, field)
        if err != nil </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>
        <span class="cov0" title="0">ctx = graphql.WithFieldContext(ctx, fc)
        defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        ec.Error(ctx, ec.Recover(ctx, r))
                        ret = graphql.Null
                }</span>
        }()
        <span class="cov0" title="0">resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) </span><span class="cov0" title="0">{
                ctx = rctx // use context from middleware stack in children
                return obj.DefaultValue, nil
        }</span>)
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                ec.Error(ctx, err)
                return graphql.Null
        }</span>
        <span class="cov0" title="0">if resTmp == nil </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>
        <span class="cov0" title="0">res := resTmp.(*string)
        fc.Result = res
        return ec.marshalOString2ᚖstring(ctx, field.Selections, res)</span>
}

func (ec *executionContext) fieldContext___InputValue_defaultValue(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) <span class="cov0" title="0">{
        fc = &amp;graphql.FieldContext{
                Object:     "__InputValue",
                Field:      field,
                IsMethod:   false,
                IsResolver: false,
                Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) </span><span class="cov0" title="0">{
                        return nil, errors.New("field of type String does not have child fields")
                }</span>,
        }
        <span class="cov0" title="0">return fc, nil</span>
}

func (ec *executionContext) ___Schema_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) <span class="cov0" title="0">{
        fc, err := ec.fieldContext___Schema_description(ctx, field)
        if err != nil </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>
        <span class="cov0" title="0">ctx = graphql.WithFieldContext(ctx, fc)
        defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        ec.Error(ctx, ec.Recover(ctx, r))
                        ret = graphql.Null
                }</span>
        }()
        <span class="cov0" title="0">resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) </span><span class="cov0" title="0">{
                ctx = rctx // use context from middleware stack in children
                return obj.Description(), nil
        }</span>)
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                ec.Error(ctx, err)
                return graphql.Null
        }</span>
        <span class="cov0" title="0">if resTmp == nil </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>
        <span class="cov0" title="0">res := resTmp.(*string)
        fc.Result = res
        return ec.marshalOString2ᚖstring(ctx, field.Selections, res)</span>
}

func (ec *executionContext) fieldContext___Schema_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) <span class="cov0" title="0">{
        fc = &amp;graphql.FieldContext{
                Object:     "__Schema",
                Field:      field,
                IsMethod:   true,
                IsResolver: false,
                Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) </span><span class="cov0" title="0">{
                        return nil, errors.New("field of type String does not have child fields")
                }</span>,
        }
        <span class="cov0" title="0">return fc, nil</span>
}

func (ec *executionContext) ___Schema_types(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) <span class="cov0" title="0">{
        fc, err := ec.fieldContext___Schema_types(ctx, field)
        if err != nil </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>
        <span class="cov0" title="0">ctx = graphql.WithFieldContext(ctx, fc)
        defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        ec.Error(ctx, ec.Recover(ctx, r))
                        ret = graphql.Null
                }</span>
        }()
        <span class="cov0" title="0">resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) </span><span class="cov0" title="0">{
                ctx = rctx // use context from middleware stack in children
                return obj.Types(), nil
        }</span>)
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                ec.Error(ctx, err)
                return graphql.Null
        }</span>
        <span class="cov0" title="0">if resTmp == nil </span><span class="cov0" title="0">{
                if !graphql.HasFieldError(ctx, fc) </span><span class="cov0" title="0">{
                        ec.Errorf(ctx, "must not be null")
                }</span>
                <span class="cov0" title="0">return graphql.Null</span>
        }
        <span class="cov0" title="0">res := resTmp.([]introspection.Type)
        fc.Result = res
        return ec.marshalN__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx, field.Selections, res)</span>
}

func (ec *executionContext) fieldContext___Schema_types(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) <span class="cov0" title="0">{
        fc = &amp;graphql.FieldContext{
                Object:     "__Schema",
                Field:      field,
                IsMethod:   true,
                IsResolver: false,
                Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) </span><span class="cov0" title="0">{
                        switch field.Name </span>{
                        case "kind":<span class="cov0" title="0">
                                return ec.fieldContext___Type_kind(ctx, field)</span>
                        case "name":<span class="cov0" title="0">
                                return ec.fieldContext___Type_name(ctx, field)</span>
                        case "description":<span class="cov0" title="0">
                                return ec.fieldContext___Type_description(ctx, field)</span>
                        case "fields":<span class="cov0" title="0">
                                return ec.fieldContext___Type_fields(ctx, field)</span>
                        case "interfaces":<span class="cov0" title="0">
                                return ec.fieldContext___Type_interfaces(ctx, field)</span>
                        case "possibleTypes":<span class="cov0" title="0">
                                return ec.fieldContext___Type_possibleTypes(ctx, field)</span>
                        case "enumValues":<span class="cov0" title="0">
                                return ec.fieldContext___Type_enumValues(ctx, field)</span>
                        case "inputFields":<span class="cov0" title="0">
                                return ec.fieldContext___Type_inputFields(ctx, field)</span>
                        case "ofType":<span class="cov0" title="0">
                                return ec.fieldContext___Type_ofType(ctx, field)</span>
                        case "specifiedByURL":<span class="cov0" title="0">
                                return ec.fieldContext___Type_specifiedByURL(ctx, field)</span>
                        }
                        <span class="cov0" title="0">return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)</span>
                },
        }
        <span class="cov0" title="0">return fc, nil</span>
}

func (ec *executionContext) ___Schema_queryType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) <span class="cov0" title="0">{
        fc, err := ec.fieldContext___Schema_queryType(ctx, field)
        if err != nil </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>
        <span class="cov0" title="0">ctx = graphql.WithFieldContext(ctx, fc)
        defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        ec.Error(ctx, ec.Recover(ctx, r))
                        ret = graphql.Null
                }</span>
        }()
        <span class="cov0" title="0">resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) </span><span class="cov0" title="0">{
                ctx = rctx // use context from middleware stack in children
                return obj.QueryType(), nil
        }</span>)
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                ec.Error(ctx, err)
                return graphql.Null
        }</span>
        <span class="cov0" title="0">if resTmp == nil </span><span class="cov0" title="0">{
                if !graphql.HasFieldError(ctx, fc) </span><span class="cov0" title="0">{
                        ec.Errorf(ctx, "must not be null")
                }</span>
                <span class="cov0" title="0">return graphql.Null</span>
        }
        <span class="cov0" title="0">res := resTmp.(*introspection.Type)
        fc.Result = res
        return ec.marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)</span>
}

func (ec *executionContext) fieldContext___Schema_queryType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) <span class="cov0" title="0">{
        fc = &amp;graphql.FieldContext{
                Object:     "__Schema",
                Field:      field,
                IsMethod:   true,
                IsResolver: false,
                Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) </span><span class="cov0" title="0">{
                        switch field.Name </span>{
                        case "kind":<span class="cov0" title="0">
                                return ec.fieldContext___Type_kind(ctx, field)</span>
                        case "name":<span class="cov0" title="0">
                                return ec.fieldContext___Type_name(ctx, field)</span>
                        case "description":<span class="cov0" title="0">
                                return ec.fieldContext___Type_description(ctx, field)</span>
                        case "fields":<span class="cov0" title="0">
                                return ec.fieldContext___Type_fields(ctx, field)</span>
                        case "interfaces":<span class="cov0" title="0">
                                return ec.fieldContext___Type_interfaces(ctx, field)</span>
                        case "possibleTypes":<span class="cov0" title="0">
                                return ec.fieldContext___Type_possibleTypes(ctx, field)</span>
                        case "enumValues":<span class="cov0" title="0">
                                return ec.fieldContext___Type_enumValues(ctx, field)</span>
                        case "inputFields":<span class="cov0" title="0">
                                return ec.fieldContext___Type_inputFields(ctx, field)</span>
                        case "ofType":<span class="cov0" title="0">
                                return ec.fieldContext___Type_ofType(ctx, field)</span>
                        case "specifiedByURL":<span class="cov0" title="0">
                                return ec.fieldContext___Type_specifiedByURL(ctx, field)</span>
                        }
                        <span class="cov0" title="0">return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)</span>
                },
        }
        <span class="cov0" title="0">return fc, nil</span>
}

func (ec *executionContext) ___Schema_mutationType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) <span class="cov0" title="0">{
        fc, err := ec.fieldContext___Schema_mutationType(ctx, field)
        if err != nil </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>
        <span class="cov0" title="0">ctx = graphql.WithFieldContext(ctx, fc)
        defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        ec.Error(ctx, ec.Recover(ctx, r))
                        ret = graphql.Null
                }</span>
        }()
        <span class="cov0" title="0">resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) </span><span class="cov0" title="0">{
                ctx = rctx // use context from middleware stack in children
                return obj.MutationType(), nil
        }</span>)
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                ec.Error(ctx, err)
                return graphql.Null
        }</span>
        <span class="cov0" title="0">if resTmp == nil </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>
        <span class="cov0" title="0">res := resTmp.(*introspection.Type)
        fc.Result = res
        return ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)</span>
}

func (ec *executionContext) fieldContext___Schema_mutationType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) <span class="cov0" title="0">{
        fc = &amp;graphql.FieldContext{
                Object:     "__Schema",
                Field:      field,
                IsMethod:   true,
                IsResolver: false,
                Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) </span><span class="cov0" title="0">{
                        switch field.Name </span>{
                        case "kind":<span class="cov0" title="0">
                                return ec.fieldContext___Type_kind(ctx, field)</span>
                        case "name":<span class="cov0" title="0">
                                return ec.fieldContext___Type_name(ctx, field)</span>
                        case "description":<span class="cov0" title="0">
                                return ec.fieldContext___Type_description(ctx, field)</span>
                        case "fields":<span class="cov0" title="0">
                                return ec.fieldContext___Type_fields(ctx, field)</span>
                        case "interfaces":<span class="cov0" title="0">
                                return ec.fieldContext___Type_interfaces(ctx, field)</span>
                        case "possibleTypes":<span class="cov0" title="0">
                                return ec.fieldContext___Type_possibleTypes(ctx, field)</span>
                        case "enumValues":<span class="cov0" title="0">
                                return ec.fieldContext___Type_enumValues(ctx, field)</span>
                        case "inputFields":<span class="cov0" title="0">
                                return ec.fieldContext___Type_inputFields(ctx, field)</span>
                        case "ofType":<span class="cov0" title="0">
                                return ec.fieldContext___Type_ofType(ctx, field)</span>
                        case "specifiedByURL":<span class="cov0" title="0">
                                return ec.fieldContext___Type_specifiedByURL(ctx, field)</span>
                        }
                        <span class="cov0" title="0">return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)</span>
                },
        }
        <span class="cov0" title="0">return fc, nil</span>
}

func (ec *executionContext) ___Schema_subscriptionType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) <span class="cov0" title="0">{
        fc, err := ec.fieldContext___Schema_subscriptionType(ctx, field)
        if err != nil </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>
        <span class="cov0" title="0">ctx = graphql.WithFieldContext(ctx, fc)
        defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        ec.Error(ctx, ec.Recover(ctx, r))
                        ret = graphql.Null
                }</span>
        }()
        <span class="cov0" title="0">resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) </span><span class="cov0" title="0">{
                ctx = rctx // use context from middleware stack in children
                return obj.SubscriptionType(), nil
        }</span>)
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                ec.Error(ctx, err)
                return graphql.Null
        }</span>
        <span class="cov0" title="0">if resTmp == nil </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>
        <span class="cov0" title="0">res := resTmp.(*introspection.Type)
        fc.Result = res
        return ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)</span>
}

func (ec *executionContext) fieldContext___Schema_subscriptionType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) <span class="cov0" title="0">{
        fc = &amp;graphql.FieldContext{
                Object:     "__Schema",
                Field:      field,
                IsMethod:   true,
                IsResolver: false,
                Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) </span><span class="cov0" title="0">{
                        switch field.Name </span>{
                        case "kind":<span class="cov0" title="0">
                                return ec.fieldContext___Type_kind(ctx, field)</span>
                        case "name":<span class="cov0" title="0">
                                return ec.fieldContext___Type_name(ctx, field)</span>
                        case "description":<span class="cov0" title="0">
                                return ec.fieldContext___Type_description(ctx, field)</span>
                        case "fields":<span class="cov0" title="0">
                                return ec.fieldContext___Type_fields(ctx, field)</span>
                        case "interfaces":<span class="cov0" title="0">
                                return ec.fieldContext___Type_interfaces(ctx, field)</span>
                        case "possibleTypes":<span class="cov0" title="0">
                                return ec.fieldContext___Type_possibleTypes(ctx, field)</span>
                        case "enumValues":<span class="cov0" title="0">
                                return ec.fieldContext___Type_enumValues(ctx, field)</span>
                        case "inputFields":<span class="cov0" title="0">
                                return ec.fieldContext___Type_inputFields(ctx, field)</span>
                        case "ofType":<span class="cov0" title="0">
                                return ec.fieldContext___Type_ofType(ctx, field)</span>
                        case "specifiedByURL":<span class="cov0" title="0">
                                return ec.fieldContext___Type_specifiedByURL(ctx, field)</span>
                        }
                        <span class="cov0" title="0">return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)</span>
                },
        }
        <span class="cov0" title="0">return fc, nil</span>
}

func (ec *executionContext) ___Schema_directives(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) <span class="cov0" title="0">{
        fc, err := ec.fieldContext___Schema_directives(ctx, field)
        if err != nil </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>
        <span class="cov0" title="0">ctx = graphql.WithFieldContext(ctx, fc)
        defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        ec.Error(ctx, ec.Recover(ctx, r))
                        ret = graphql.Null
                }</span>
        }()
        <span class="cov0" title="0">resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) </span><span class="cov0" title="0">{
                ctx = rctx // use context from middleware stack in children
                return obj.Directives(), nil
        }</span>)
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                ec.Error(ctx, err)
                return graphql.Null
        }</span>
        <span class="cov0" title="0">if resTmp == nil </span><span class="cov0" title="0">{
                if !graphql.HasFieldError(ctx, fc) </span><span class="cov0" title="0">{
                        ec.Errorf(ctx, "must not be null")
                }</span>
                <span class="cov0" title="0">return graphql.Null</span>
        }
        <span class="cov0" title="0">res := resTmp.([]introspection.Directive)
        fc.Result = res
        return ec.marshalN__Directive2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirectiveᚄ(ctx, field.Selections, res)</span>
}

func (ec *executionContext) fieldContext___Schema_directives(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) <span class="cov0" title="0">{
        fc = &amp;graphql.FieldContext{
                Object:     "__Schema",
                Field:      field,
                IsMethod:   true,
                IsResolver: false,
                Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) </span><span class="cov0" title="0">{
                        switch field.Name </span>{
                        case "name":<span class="cov0" title="0">
                                return ec.fieldContext___Directive_name(ctx, field)</span>
                        case "description":<span class="cov0" title="0">
                                return ec.fieldContext___Directive_description(ctx, field)</span>
                        case "locations":<span class="cov0" title="0">
                                return ec.fieldContext___Directive_locations(ctx, field)</span>
                        case "args":<span class="cov0" title="0">
                                return ec.fieldContext___Directive_args(ctx, field)</span>
                        case "isRepeatable":<span class="cov0" title="0">
                                return ec.fieldContext___Directive_isRepeatable(ctx, field)</span>
                        }
                        <span class="cov0" title="0">return nil, fmt.Errorf("no field named %q was found under type __Directive", field.Name)</span>
                },
        }
        <span class="cov0" title="0">return fc, nil</span>
}

func (ec *executionContext) ___Type_kind(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) <span class="cov0" title="0">{
        fc, err := ec.fieldContext___Type_kind(ctx, field)
        if err != nil </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>
        <span class="cov0" title="0">ctx = graphql.WithFieldContext(ctx, fc)
        defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        ec.Error(ctx, ec.Recover(ctx, r))
                        ret = graphql.Null
                }</span>
        }()
        <span class="cov0" title="0">resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) </span><span class="cov0" title="0">{
                ctx = rctx // use context from middleware stack in children
                return obj.Kind(), nil
        }</span>)
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                ec.Error(ctx, err)
                return graphql.Null
        }</span>
        <span class="cov0" title="0">if resTmp == nil </span><span class="cov0" title="0">{
                if !graphql.HasFieldError(ctx, fc) </span><span class="cov0" title="0">{
                        ec.Errorf(ctx, "must not be null")
                }</span>
                <span class="cov0" title="0">return graphql.Null</span>
        }
        <span class="cov0" title="0">res := resTmp.(string)
        fc.Result = res
        return ec.marshalN__TypeKind2string(ctx, field.Selections, res)</span>
}

func (ec *executionContext) fieldContext___Type_kind(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) <span class="cov0" title="0">{
        fc = &amp;graphql.FieldContext{
                Object:     "__Type",
                Field:      field,
                IsMethod:   true,
                IsResolver: false,
                Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) </span><span class="cov0" title="0">{
                        return nil, errors.New("field of type __TypeKind does not have child fields")
                }</span>,
        }
        <span class="cov0" title="0">return fc, nil</span>
}

func (ec *executionContext) ___Type_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) <span class="cov0" title="0">{
        fc, err := ec.fieldContext___Type_name(ctx, field)
        if err != nil </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>
        <span class="cov0" title="0">ctx = graphql.WithFieldContext(ctx, fc)
        defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        ec.Error(ctx, ec.Recover(ctx, r))
                        ret = graphql.Null
                }</span>
        }()
        <span class="cov0" title="0">resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) </span><span class="cov0" title="0">{
                ctx = rctx // use context from middleware stack in children
                return obj.Name(), nil
        }</span>)
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                ec.Error(ctx, err)
                return graphql.Null
        }</span>
        <span class="cov0" title="0">if resTmp == nil </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>
        <span class="cov0" title="0">res := resTmp.(*string)
        fc.Result = res
        return ec.marshalOString2ᚖstring(ctx, field.Selections, res)</span>
}

func (ec *executionContext) fieldContext___Type_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) <span class="cov0" title="0">{
        fc = &amp;graphql.FieldContext{
                Object:     "__Type",
                Field:      field,
                IsMethod:   true,
                IsResolver: false,
                Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) </span><span class="cov0" title="0">{
                        return nil, errors.New("field of type String does not have child fields")
                }</span>,
        }
        <span class="cov0" title="0">return fc, nil</span>
}

func (ec *executionContext) ___Type_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) <span class="cov0" title="0">{
        fc, err := ec.fieldContext___Type_description(ctx, field)
        if err != nil </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>
        <span class="cov0" title="0">ctx = graphql.WithFieldContext(ctx, fc)
        defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        ec.Error(ctx, ec.Recover(ctx, r))
                        ret = graphql.Null
                }</span>
        }()
        <span class="cov0" title="0">resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) </span><span class="cov0" title="0">{
                ctx = rctx // use context from middleware stack in children
                return obj.Description(), nil
        }</span>)
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                ec.Error(ctx, err)
                return graphql.Null
        }</span>
        <span class="cov0" title="0">if resTmp == nil </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>
        <span class="cov0" title="0">res := resTmp.(*string)
        fc.Result = res
        return ec.marshalOString2ᚖstring(ctx, field.Selections, res)</span>
}

func (ec *executionContext) fieldContext___Type_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) <span class="cov0" title="0">{
        fc = &amp;graphql.FieldContext{
                Object:     "__Type",
                Field:      field,
                IsMethod:   true,
                IsResolver: false,
                Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) </span><span class="cov0" title="0">{
                        return nil, errors.New("field of type String does not have child fields")
                }</span>,
        }
        <span class="cov0" title="0">return fc, nil</span>
}

func (ec *executionContext) ___Type_fields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) <span class="cov0" title="0">{
        fc, err := ec.fieldContext___Type_fields(ctx, field)
        if err != nil </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>
        <span class="cov0" title="0">ctx = graphql.WithFieldContext(ctx, fc)
        defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        ec.Error(ctx, ec.Recover(ctx, r))
                        ret = graphql.Null
                }</span>
        }()
        <span class="cov0" title="0">resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) </span><span class="cov0" title="0">{
                ctx = rctx // use context from middleware stack in children
                return obj.Fields(fc.Args["includeDeprecated"].(bool)), nil
        }</span>)
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                ec.Error(ctx, err)
                return graphql.Null
        }</span>
        <span class="cov0" title="0">if resTmp == nil </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>
        <span class="cov0" title="0">res := resTmp.([]introspection.Field)
        fc.Result = res
        return ec.marshalO__Field2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐFieldᚄ(ctx, field.Selections, res)</span>
}

func (ec *executionContext) fieldContext___Type_fields(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) <span class="cov0" title="0">{
        fc = &amp;graphql.FieldContext{
                Object:     "__Type",
                Field:      field,
                IsMethod:   true,
                IsResolver: false,
                Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) </span><span class="cov0" title="0">{
                        switch field.Name </span>{
                        case "name":<span class="cov0" title="0">
                                return ec.fieldContext___Field_name(ctx, field)</span>
                        case "description":<span class="cov0" title="0">
                                return ec.fieldContext___Field_description(ctx, field)</span>
                        case "args":<span class="cov0" title="0">
                                return ec.fieldContext___Field_args(ctx, field)</span>
                        case "type":<span class="cov0" title="0">
                                return ec.fieldContext___Field_type(ctx, field)</span>
                        case "isDeprecated":<span class="cov0" title="0">
                                return ec.fieldContext___Field_isDeprecated(ctx, field)</span>
                        case "deprecationReason":<span class="cov0" title="0">
                                return ec.fieldContext___Field_deprecationReason(ctx, field)</span>
                        }
                        <span class="cov0" title="0">return nil, fmt.Errorf("no field named %q was found under type __Field", field.Name)</span>
                },
        }
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        err = ec.Recover(ctx, r)
                        ec.Error(ctx, err)
                }</span>
        }()
        <span class="cov0" title="0">ctx = graphql.WithFieldContext(ctx, fc)
        if fc.Args, err = ec.field___Type_fields_args(ctx, field.ArgumentMap(ec.Variables)); err != nil </span><span class="cov0" title="0">{
                ec.Error(ctx, err)
                return fc, err
        }</span>
        <span class="cov0" title="0">return fc, nil</span>
}

func (ec *executionContext) ___Type_interfaces(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) <span class="cov0" title="0">{
        fc, err := ec.fieldContext___Type_interfaces(ctx, field)
        if err != nil </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>
        <span class="cov0" title="0">ctx = graphql.WithFieldContext(ctx, fc)
        defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        ec.Error(ctx, ec.Recover(ctx, r))
                        ret = graphql.Null
                }</span>
        }()
        <span class="cov0" title="0">resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) </span><span class="cov0" title="0">{
                ctx = rctx // use context from middleware stack in children
                return obj.Interfaces(), nil
        }</span>)
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                ec.Error(ctx, err)
                return graphql.Null
        }</span>
        <span class="cov0" title="0">if resTmp == nil </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>
        <span class="cov0" title="0">res := resTmp.([]introspection.Type)
        fc.Result = res
        return ec.marshalO__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx, field.Selections, res)</span>
}

func (ec *executionContext) fieldContext___Type_interfaces(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) <span class="cov0" title="0">{
        fc = &amp;graphql.FieldContext{
                Object:     "__Type",
                Field:      field,
                IsMethod:   true,
                IsResolver: false,
                Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) </span><span class="cov0" title="0">{
                        switch field.Name </span>{
                        case "kind":<span class="cov0" title="0">
                                return ec.fieldContext___Type_kind(ctx, field)</span>
                        case "name":<span class="cov0" title="0">
                                return ec.fieldContext___Type_name(ctx, field)</span>
                        case "description":<span class="cov0" title="0">
                                return ec.fieldContext___Type_description(ctx, field)</span>
                        case "fields":<span class="cov0" title="0">
                                return ec.fieldContext___Type_fields(ctx, field)</span>
                        case "interfaces":<span class="cov0" title="0">
                                return ec.fieldContext___Type_interfaces(ctx, field)</span>
                        case "possibleTypes":<span class="cov0" title="0">
                                return ec.fieldContext___Type_possibleTypes(ctx, field)</span>
                        case "enumValues":<span class="cov0" title="0">
                                return ec.fieldContext___Type_enumValues(ctx, field)</span>
                        case "inputFields":<span class="cov0" title="0">
                                return ec.fieldContext___Type_inputFields(ctx, field)</span>
                        case "ofType":<span class="cov0" title="0">
                                return ec.fieldContext___Type_ofType(ctx, field)</span>
                        case "specifiedByURL":<span class="cov0" title="0">
                                return ec.fieldContext___Type_specifiedByURL(ctx, field)</span>
                        }
                        <span class="cov0" title="0">return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)</span>
                },
        }
        <span class="cov0" title="0">return fc, nil</span>
}

func (ec *executionContext) ___Type_possibleTypes(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) <span class="cov0" title="0">{
        fc, err := ec.fieldContext___Type_possibleTypes(ctx, field)
        if err != nil </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>
        <span class="cov0" title="0">ctx = graphql.WithFieldContext(ctx, fc)
        defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        ec.Error(ctx, ec.Recover(ctx, r))
                        ret = graphql.Null
                }</span>
        }()
        <span class="cov0" title="0">resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) </span><span class="cov0" title="0">{
                ctx = rctx // use context from middleware stack in children
                return obj.PossibleTypes(), nil
        }</span>)
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                ec.Error(ctx, err)
                return graphql.Null
        }</span>
        <span class="cov0" title="0">if resTmp == nil </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>
        <span class="cov0" title="0">res := resTmp.([]introspection.Type)
        fc.Result = res
        return ec.marshalO__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx, field.Selections, res)</span>
}

func (ec *executionContext) fieldContext___Type_possibleTypes(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) <span class="cov0" title="0">{
        fc = &amp;graphql.FieldContext{
                Object:     "__Type",
                Field:      field,
                IsMethod:   true,
                IsResolver: false,
                Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) </span><span class="cov0" title="0">{
                        switch field.Name </span>{
                        case "kind":<span class="cov0" title="0">
                                return ec.fieldContext___Type_kind(ctx, field)</span>
                        case "name":<span class="cov0" title="0">
                                return ec.fieldContext___Type_name(ctx, field)</span>
                        case "description":<span class="cov0" title="0">
                                return ec.fieldContext___Type_description(ctx, field)</span>
                        case "fields":<span class="cov0" title="0">
                                return ec.fieldContext___Type_fields(ctx, field)</span>
                        case "interfaces":<span class="cov0" title="0">
                                return ec.fieldContext___Type_interfaces(ctx, field)</span>
                        case "possibleTypes":<span class="cov0" title="0">
                                return ec.fieldContext___Type_possibleTypes(ctx, field)</span>
                        case "enumValues":<span class="cov0" title="0">
                                return ec.fieldContext___Type_enumValues(ctx, field)</span>
                        case "inputFields":<span class="cov0" title="0">
                                return ec.fieldContext___Type_inputFields(ctx, field)</span>
                        case "ofType":<span class="cov0" title="0">
                                return ec.fieldContext___Type_ofType(ctx, field)</span>
                        case "specifiedByURL":<span class="cov0" title="0">
                                return ec.fieldContext___Type_specifiedByURL(ctx, field)</span>
                        }
                        <span class="cov0" title="0">return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)</span>
                },
        }
        <span class="cov0" title="0">return fc, nil</span>
}

func (ec *executionContext) ___Type_enumValues(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) <span class="cov0" title="0">{
        fc, err := ec.fieldContext___Type_enumValues(ctx, field)
        if err != nil </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>
        <span class="cov0" title="0">ctx = graphql.WithFieldContext(ctx, fc)
        defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        ec.Error(ctx, ec.Recover(ctx, r))
                        ret = graphql.Null
                }</span>
        }()
        <span class="cov0" title="0">resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) </span><span class="cov0" title="0">{
                ctx = rctx // use context from middleware stack in children
                return obj.EnumValues(fc.Args["includeDeprecated"].(bool)), nil
        }</span>)
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                ec.Error(ctx, err)
                return graphql.Null
        }</span>
        <span class="cov0" title="0">if resTmp == nil </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>
        <span class="cov0" title="0">res := resTmp.([]introspection.EnumValue)
        fc.Result = res
        return ec.marshalO__EnumValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValueᚄ(ctx, field.Selections, res)</span>
}

func (ec *executionContext) fieldContext___Type_enumValues(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) <span class="cov0" title="0">{
        fc = &amp;graphql.FieldContext{
                Object:     "__Type",
                Field:      field,
                IsMethod:   true,
                IsResolver: false,
                Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) </span><span class="cov0" title="0">{
                        switch field.Name </span>{
                        case "name":<span class="cov0" title="0">
                                return ec.fieldContext___EnumValue_name(ctx, field)</span>
                        case "description":<span class="cov0" title="0">
                                return ec.fieldContext___EnumValue_description(ctx, field)</span>
                        case "isDeprecated":<span class="cov0" title="0">
                                return ec.fieldContext___EnumValue_isDeprecated(ctx, field)</span>
                        case "deprecationReason":<span class="cov0" title="0">
                                return ec.fieldContext___EnumValue_deprecationReason(ctx, field)</span>
                        }
                        <span class="cov0" title="0">return nil, fmt.Errorf("no field named %q was found under type __EnumValue", field.Name)</span>
                },
        }
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        err = ec.Recover(ctx, r)
                        ec.Error(ctx, err)
                }</span>
        }()
        <span class="cov0" title="0">ctx = graphql.WithFieldContext(ctx, fc)
        if fc.Args, err = ec.field___Type_enumValues_args(ctx, field.ArgumentMap(ec.Variables)); err != nil </span><span class="cov0" title="0">{
                ec.Error(ctx, err)
                return fc, err
        }</span>
        <span class="cov0" title="0">return fc, nil</span>
}

func (ec *executionContext) ___Type_inputFields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) <span class="cov0" title="0">{
        fc, err := ec.fieldContext___Type_inputFields(ctx, field)
        if err != nil </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>
        <span class="cov0" title="0">ctx = graphql.WithFieldContext(ctx, fc)
        defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        ec.Error(ctx, ec.Recover(ctx, r))
                        ret = graphql.Null
                }</span>
        }()
        <span class="cov0" title="0">resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) </span><span class="cov0" title="0">{
                ctx = rctx // use context from middleware stack in children
                return obj.InputFields(), nil
        }</span>)
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                ec.Error(ctx, err)
                return graphql.Null
        }</span>
        <span class="cov0" title="0">if resTmp == nil </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>
        <span class="cov0" title="0">res := resTmp.([]introspection.InputValue)
        fc.Result = res
        return ec.marshalO__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx, field.Selections, res)</span>
}

func (ec *executionContext) fieldContext___Type_inputFields(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) <span class="cov0" title="0">{
        fc = &amp;graphql.FieldContext{
                Object:     "__Type",
                Field:      field,
                IsMethod:   true,
                IsResolver: false,
                Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) </span><span class="cov0" title="0">{
                        switch field.Name </span>{
                        case "name":<span class="cov0" title="0">
                                return ec.fieldContext___InputValue_name(ctx, field)</span>
                        case "description":<span class="cov0" title="0">
                                return ec.fieldContext___InputValue_description(ctx, field)</span>
                        case "type":<span class="cov0" title="0">
                                return ec.fieldContext___InputValue_type(ctx, field)</span>
                        case "defaultValue":<span class="cov0" title="0">
                                return ec.fieldContext___InputValue_defaultValue(ctx, field)</span>
                        }
                        <span class="cov0" title="0">return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)</span>
                },
        }
        <span class="cov0" title="0">return fc, nil</span>
}

func (ec *executionContext) ___Type_ofType(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) <span class="cov0" title="0">{
        fc, err := ec.fieldContext___Type_ofType(ctx, field)
        if err != nil </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>
        <span class="cov0" title="0">ctx = graphql.WithFieldContext(ctx, fc)
        defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        ec.Error(ctx, ec.Recover(ctx, r))
                        ret = graphql.Null
                }</span>
        }()
        <span class="cov0" title="0">resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) </span><span class="cov0" title="0">{
                ctx = rctx // use context from middleware stack in children
                return obj.OfType(), nil
        }</span>)
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                ec.Error(ctx, err)
                return graphql.Null
        }</span>
        <span class="cov0" title="0">if resTmp == nil </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>
        <span class="cov0" title="0">res := resTmp.(*introspection.Type)
        fc.Result = res
        return ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)</span>
}

func (ec *executionContext) fieldContext___Type_ofType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) <span class="cov0" title="0">{
        fc = &amp;graphql.FieldContext{
                Object:     "__Type",
                Field:      field,
                IsMethod:   true,
                IsResolver: false,
                Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) </span><span class="cov0" title="0">{
                        switch field.Name </span>{
                        case "kind":<span class="cov0" title="0">
                                return ec.fieldContext___Type_kind(ctx, field)</span>
                        case "name":<span class="cov0" title="0">
                                return ec.fieldContext___Type_name(ctx, field)</span>
                        case "description":<span class="cov0" title="0">
                                return ec.fieldContext___Type_description(ctx, field)</span>
                        case "fields":<span class="cov0" title="0">
                                return ec.fieldContext___Type_fields(ctx, field)</span>
                        case "interfaces":<span class="cov0" title="0">
                                return ec.fieldContext___Type_interfaces(ctx, field)</span>
                        case "possibleTypes":<span class="cov0" title="0">
                                return ec.fieldContext___Type_possibleTypes(ctx, field)</span>
                        case "enumValues":<span class="cov0" title="0">
                                return ec.fieldContext___Type_enumValues(ctx, field)</span>
                        case "inputFields":<span class="cov0" title="0">
                                return ec.fieldContext___Type_inputFields(ctx, field)</span>
                        case "ofType":<span class="cov0" title="0">
                                return ec.fieldContext___Type_ofType(ctx, field)</span>
                        case "specifiedByURL":<span class="cov0" title="0">
                                return ec.fieldContext___Type_specifiedByURL(ctx, field)</span>
                        }
                        <span class="cov0" title="0">return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)</span>
                },
        }
        <span class="cov0" title="0">return fc, nil</span>
}

func (ec *executionContext) ___Type_specifiedByURL(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) <span class="cov0" title="0">{
        fc, err := ec.fieldContext___Type_specifiedByURL(ctx, field)
        if err != nil </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>
        <span class="cov0" title="0">ctx = graphql.WithFieldContext(ctx, fc)
        defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        ec.Error(ctx, ec.Recover(ctx, r))
                        ret = graphql.Null
                }</span>
        }()
        <span class="cov0" title="0">resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) </span><span class="cov0" title="0">{
                ctx = rctx // use context from middleware stack in children
                return obj.SpecifiedByURL(), nil
        }</span>)
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                ec.Error(ctx, err)
                return graphql.Null
        }</span>
        <span class="cov0" title="0">if resTmp == nil </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>
        <span class="cov0" title="0">res := resTmp.(*string)
        fc.Result = res
        return ec.marshalOString2ᚖstring(ctx, field.Selections, res)</span>
}

func (ec *executionContext) fieldContext___Type_specifiedByURL(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) <span class="cov0" title="0">{
        fc = &amp;graphql.FieldContext{
                Object:     "__Type",
                Field:      field,
                IsMethod:   true,
                IsResolver: false,
                Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) </span><span class="cov0" title="0">{
                        return nil, errors.New("field of type String does not have child fields")
                }</span>,
        }
        <span class="cov0" title="0">return fc, nil</span>
}

// endregion **************************** field.gotpl *****************************

// region    **************************** input.gotpl *****************************

// endregion **************************** input.gotpl *****************************

// region    ************************** interface.gotpl ***************************

func (ec *executionContext) __Entity(ctx context.Context, sel ast.SelectionSet, obj fedruntime.Entity) graphql.Marshaler <span class="cov0" title="0">{
        switch obj := (obj).(type) </span>{
        case nil:<span class="cov0" title="0">
                return graphql.Null</span>
        case User:<span class="cov0" title="0">
                return ec._User(ctx, sel, &amp;obj)</span>
        case *User:<span class="cov0" title="0">
                if obj == nil </span><span class="cov0" title="0">{
                        return graphql.Null
                }</span>
                <span class="cov0" title="0">return ec._User(ctx, sel, obj)</span>
        default:<span class="cov0" title="0">
                panic(fmt.Errorf("unexpected type %T", obj))</span>
        }
}

// endregion ************************** interface.gotpl ***************************

// region    **************************** object.gotpl ****************************

var entityImplementors = []string{"Entity"}

func (ec *executionContext) _Entity(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler <span class="cov0" title="0">{
        fields := graphql.CollectFields(ec.OperationContext, sel, entityImplementors)
        ctx = graphql.WithFieldContext(ctx, &amp;graphql.FieldContext{
                Object: "Entity",
        })

        out := graphql.NewFieldSet(fields)
        deferred := make(map[string]*graphql.FieldSet)
        for i, field := range fields </span><span class="cov0" title="0">{
                innerCtx := graphql.WithRootFieldContext(ctx, &amp;graphql.RootFieldContext{
                        Object: field.Name,
                        Field:  field,
                })

                switch field.Name </span>{
                case "__typename":<span class="cov0" title="0">
                        out.Values[i] = graphql.MarshalString("Entity")</span>
                case "findUserByID":<span class="cov0" title="0">
                        field := field

                        innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) </span><span class="cov0" title="0">{
                                defer func() </span><span class="cov0" title="0">{
                                        if r := recover(); r != nil </span><span class="cov0" title="0">{
                                                ec.Error(ctx, ec.Recover(ctx, r))
                                        }</span>
                                }()
                                <span class="cov0" title="0">res = ec._Entity_findUserByID(ctx, field)
                                if res == graphql.Null </span><span class="cov0" title="0">{
                                        atomic.AddUint32(&amp;fs.Invalids, 1)
                                }</span>
                                <span class="cov0" title="0">return res</span>
                        }

                        <span class="cov0" title="0">rrm := func(ctx context.Context) graphql.Marshaler </span><span class="cov0" title="0">{
                                return ec.OperationContext.RootResolverMiddleware(ctx,
                                        func(ctx context.Context) graphql.Marshaler </span><span class="cov0" title="0">{ return innerFunc(ctx, out) }</span>)
                        }

                        <span class="cov0" title="0">out.Concurrently(i, func(ctx context.Context) graphql.Marshaler </span><span class="cov0" title="0">{ return rrm(innerCtx) }</span>)
                default:<span class="cov0" title="0">
                        panic("unknown field " + strconv.Quote(field.Name))</span>
                }
        }
        <span class="cov0" title="0">out.Dispatch(ctx)
        if out.Invalids &gt; 0 </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>

        <span class="cov0" title="0">atomic.AddInt32(&amp;ec.deferred, int32(len(deferred)))

        for label, dfs := range deferred </span><span class="cov0" title="0">{
                ec.processDeferredGroup(graphql.DeferredGroup{
                        Label:    label,
                        Path:     graphql.GetPath(ctx),
                        FieldSet: dfs,
                        Context:  ctx,
                })
        }</span>

        <span class="cov0" title="0">return out</span>
}

var mutationImplementors = []string{"Mutation"}

func (ec *executionContext) _Mutation(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler <span class="cov0" title="0">{
        fields := graphql.CollectFields(ec.OperationContext, sel, mutationImplementors)
        ctx = graphql.WithFieldContext(ctx, &amp;graphql.FieldContext{
                Object: "Mutation",
        })

        out := graphql.NewFieldSet(fields)
        deferred := make(map[string]*graphql.FieldSet)
        for i, field := range fields </span><span class="cov0" title="0">{
                innerCtx := graphql.WithRootFieldContext(ctx, &amp;graphql.RootFieldContext{
                        Object: field.Name,
                        Field:  field,
                })

                switch field.Name </span>{
                case "__typename":<span class="cov0" title="0">
                        out.Values[i] = graphql.MarshalString("Mutation")</span>
                case "signIn":<span class="cov0" title="0">
                        out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) </span><span class="cov0" title="0">{
                                return ec._Mutation_signIn(ctx, field)
                        }</span>)
                        <span class="cov0" title="0">if out.Values[i] == graphql.Null </span><span class="cov0" title="0">{
                                out.Invalids++
                        }</span>
                case "signUp":<span class="cov0" title="0">
                        out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) </span><span class="cov0" title="0">{
                                return ec._Mutation_signUp(ctx, field)
                        }</span>)
                        <span class="cov0" title="0">if out.Values[i] == graphql.Null </span><span class="cov0" title="0">{
                                out.Invalids++
                        }</span>
                case "signOut":<span class="cov0" title="0">
                        out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) </span><span class="cov0" title="0">{
                                return ec._Mutation_signOut(ctx, field)
                        }</span>)
                        <span class="cov0" title="0">if out.Values[i] == graphql.Null </span><span class="cov0" title="0">{
                                out.Invalids++
                        }</span>
                case "changePassword":<span class="cov0" title="0">
                        out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) </span><span class="cov0" title="0">{
                                return ec._Mutation_changePassword(ctx, field)
                        }</span>)
                        <span class="cov0" title="0">if out.Values[i] == graphql.Null </span><span class="cov0" title="0">{
                                out.Invalids++
                        }</span>
                case "enable":<span class="cov0" title="0">
                        out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) </span><span class="cov0" title="0">{
                                return ec._Mutation_enable(ctx, field)
                        }</span>)
                        <span class="cov0" title="0">if out.Values[i] == graphql.Null </span><span class="cov0" title="0">{
                                out.Invalids++
                        }</span>
                case "disable":<span class="cov0" title="0">
                        out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) </span><span class="cov0" title="0">{
                                return ec._Mutation_disable(ctx, field)
                        }</span>)
                        <span class="cov0" title="0">if out.Values[i] == graphql.Null </span><span class="cov0" title="0">{
                                out.Invalids++
                        }</span>
                case "grant":<span class="cov0" title="0">
                        out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) </span><span class="cov0" title="0">{
                                return ec._Mutation_grant(ctx, field)
                        }</span>)
                        <span class="cov0" title="0">if out.Values[i] == graphql.Null </span><span class="cov0" title="0">{
                                out.Invalids++
                        }</span>
                case "revoke":<span class="cov0" title="0">
                        out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) </span><span class="cov0" title="0">{
                                return ec._Mutation_revoke(ctx, field)
                        }</span>)
                        <span class="cov0" title="0">if out.Values[i] == graphql.Null </span><span class="cov0" title="0">{
                                out.Invalids++
                        }</span>
                default:<span class="cov0" title="0">
                        panic("unknown field " + strconv.Quote(field.Name))</span>
                }
        }
        <span class="cov0" title="0">out.Dispatch(ctx)
        if out.Invalids &gt; 0 </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>

        <span class="cov0" title="0">atomic.AddInt32(&amp;ec.deferred, int32(len(deferred)))

        for label, dfs := range deferred </span><span class="cov0" title="0">{
                ec.processDeferredGroup(graphql.DeferredGroup{
                        Label:    label,
                        Path:     graphql.GetPath(ctx),
                        FieldSet: dfs,
                        Context:  ctx,
                })
        }</span>

        <span class="cov0" title="0">return out</span>
}

var queryImplementors = []string{"Query"}

func (ec *executionContext) _Query(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler <span class="cov0" title="0">{
        fields := graphql.CollectFields(ec.OperationContext, sel, queryImplementors)
        ctx = graphql.WithFieldContext(ctx, &amp;graphql.FieldContext{
                Object: "Query",
        })

        out := graphql.NewFieldSet(fields)
        deferred := make(map[string]*graphql.FieldSet)
        for i, field := range fields </span><span class="cov0" title="0">{
                innerCtx := graphql.WithRootFieldContext(ctx, &amp;graphql.RootFieldContext{
                        Object: field.Name,
                        Field:  field,
                })

                switch field.Name </span>{
                case "__typename":<span class="cov0" title="0">
                        out.Values[i] = graphql.MarshalString("Query")</span>
                case "currentUser":<span class="cov0" title="0">
                        field := field

                        innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) </span><span class="cov0" title="0">{
                                defer func() </span><span class="cov0" title="0">{
                                        if r := recover(); r != nil </span><span class="cov0" title="0">{
                                                ec.Error(ctx, ec.Recover(ctx, r))
                                        }</span>
                                }()
                                <span class="cov0" title="0">res = ec._Query_currentUser(ctx, field)
                                if res == graphql.Null </span><span class="cov0" title="0">{
                                        atomic.AddUint32(&amp;fs.Invalids, 1)
                                }</span>
                                <span class="cov0" title="0">return res</span>
                        }

                        <span class="cov0" title="0">rrm := func(ctx context.Context) graphql.Marshaler </span><span class="cov0" title="0">{
                                return ec.OperationContext.RootResolverMiddleware(ctx,
                                        func(ctx context.Context) graphql.Marshaler </span><span class="cov0" title="0">{ return innerFunc(ctx, out) }</span>)
                        }

                        <span class="cov0" title="0">out.Concurrently(i, func(ctx context.Context) graphql.Marshaler </span><span class="cov0" title="0">{ return rrm(innerCtx) }</span>)
                case "users":<span class="cov0" title="0">
                        field := field

                        innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) </span><span class="cov0" title="0">{
                                defer func() </span><span class="cov0" title="0">{
                                        if r := recover(); r != nil </span><span class="cov0" title="0">{
                                                ec.Error(ctx, ec.Recover(ctx, r))
                                        }</span>
                                }()
                                <span class="cov0" title="0">res = ec._Query_users(ctx, field)
                                if res == graphql.Null </span><span class="cov0" title="0">{
                                        atomic.AddUint32(&amp;fs.Invalids, 1)
                                }</span>
                                <span class="cov0" title="0">return res</span>
                        }

                        <span class="cov0" title="0">rrm := func(ctx context.Context) graphql.Marshaler </span><span class="cov0" title="0">{
                                return ec.OperationContext.RootResolverMiddleware(ctx,
                                        func(ctx context.Context) graphql.Marshaler </span><span class="cov0" title="0">{ return innerFunc(ctx, out) }</span>)
                        }

                        <span class="cov0" title="0">out.Concurrently(i, func(ctx context.Context) graphql.Marshaler </span><span class="cov0" title="0">{ return rrm(innerCtx) }</span>)
                case "_entities":<span class="cov0" title="0">
                        field := field

                        innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) </span><span class="cov0" title="0">{
                                defer func() </span><span class="cov0" title="0">{
                                        if r := recover(); r != nil </span><span class="cov0" title="0">{
                                                ec.Error(ctx, ec.Recover(ctx, r))
                                        }</span>
                                }()
                                <span class="cov0" title="0">res = ec._Query__entities(ctx, field)
                                if res == graphql.Null </span><span class="cov0" title="0">{
                                        atomic.AddUint32(&amp;fs.Invalids, 1)
                                }</span>
                                <span class="cov0" title="0">return res</span>
                        }

                        <span class="cov0" title="0">rrm := func(ctx context.Context) graphql.Marshaler </span><span class="cov0" title="0">{
                                return ec.OperationContext.RootResolverMiddleware(ctx,
                                        func(ctx context.Context) graphql.Marshaler </span><span class="cov0" title="0">{ return innerFunc(ctx, out) }</span>)
                        }

                        <span class="cov0" title="0">out.Concurrently(i, func(ctx context.Context) graphql.Marshaler </span><span class="cov0" title="0">{ return rrm(innerCtx) }</span>)
                case "_service":<span class="cov0" title="0">
                        field := field

                        innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) </span><span class="cov0" title="0">{
                                defer func() </span><span class="cov0" title="0">{
                                        if r := recover(); r != nil </span><span class="cov0" title="0">{
                                                ec.Error(ctx, ec.Recover(ctx, r))
                                        }</span>
                                }()
                                <span class="cov0" title="0">res = ec._Query__service(ctx, field)
                                if res == graphql.Null </span><span class="cov0" title="0">{
                                        atomic.AddUint32(&amp;fs.Invalids, 1)
                                }</span>
                                <span class="cov0" title="0">return res</span>
                        }

                        <span class="cov0" title="0">rrm := func(ctx context.Context) graphql.Marshaler </span><span class="cov0" title="0">{
                                return ec.OperationContext.RootResolverMiddleware(ctx,
                                        func(ctx context.Context) graphql.Marshaler </span><span class="cov0" title="0">{ return innerFunc(ctx, out) }</span>)
                        }

                        <span class="cov0" title="0">out.Concurrently(i, func(ctx context.Context) graphql.Marshaler </span><span class="cov0" title="0">{ return rrm(innerCtx) }</span>)
                case "__type":<span class="cov0" title="0">
                        out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) </span><span class="cov0" title="0">{
                                return ec._Query___type(ctx, field)
                        }</span>)
                case "__schema":<span class="cov0" title="0">
                        out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) </span><span class="cov0" title="0">{
                                return ec._Query___schema(ctx, field)
                        }</span>)
                default:<span class="cov0" title="0">
                        panic("unknown field " + strconv.Quote(field.Name))</span>
                }
        }
        <span class="cov0" title="0">out.Dispatch(ctx)
        if out.Invalids &gt; 0 </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>

        <span class="cov0" title="0">atomic.AddInt32(&amp;ec.deferred, int32(len(deferred)))

        for label, dfs := range deferred </span><span class="cov0" title="0">{
                ec.processDeferredGroup(graphql.DeferredGroup{
                        Label:    label,
                        Path:     graphql.GetPath(ctx),
                        FieldSet: dfs,
                        Context:  ctx,
                })
        }</span>

        <span class="cov0" title="0">return out</span>
}

var tokenImplementors = []string{"Token"}

func (ec *executionContext) _Token(ctx context.Context, sel ast.SelectionSet, obj *Token) graphql.Marshaler <span class="cov0" title="0">{
        fields := graphql.CollectFields(ec.OperationContext, sel, tokenImplementors)

        out := graphql.NewFieldSet(fields)
        deferred := make(map[string]*graphql.FieldSet)
        for i, field := range fields </span><span class="cov0" title="0">{
                switch field.Name </span>{
                case "__typename":<span class="cov0" title="0">
                        out.Values[i] = graphql.MarshalString("Token")</span>
                case "token":<span class="cov0" title="0">
                        out.Values[i] = ec._Token_token(ctx, field, obj)
                        if out.Values[i] == graphql.Null </span><span class="cov0" title="0">{
                                out.Invalids++
                        }</span>
                default:<span class="cov0" title="0">
                        panic("unknown field " + strconv.Quote(field.Name))</span>
                }
        }
        <span class="cov0" title="0">out.Dispatch(ctx)
        if out.Invalids &gt; 0 </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>

        <span class="cov0" title="0">atomic.AddInt32(&amp;ec.deferred, int32(len(deferred)))

        for label, dfs := range deferred </span><span class="cov0" title="0">{
                ec.processDeferredGroup(graphql.DeferredGroup{
                        Label:    label,
                        Path:     graphql.GetPath(ctx),
                        FieldSet: dfs,
                        Context:  ctx,
                })
        }</span>

        <span class="cov0" title="0">return out</span>
}

var userImplementors = []string{"User", "_Entity"}

func (ec *executionContext) _User(ctx context.Context, sel ast.SelectionSet, obj *User) graphql.Marshaler <span class="cov0" title="0">{
        fields := graphql.CollectFields(ec.OperationContext, sel, userImplementors)

        out := graphql.NewFieldSet(fields)
        deferred := make(map[string]*graphql.FieldSet)
        for i, field := range fields </span><span class="cov0" title="0">{
                switch field.Name </span>{
                case "__typename":<span class="cov0" title="0">
                        out.Values[i] = graphql.MarshalString("User")</span>
                case "id":<span class="cov0" title="0">
                        out.Values[i] = ec._User_id(ctx, field, obj)
                        if out.Values[i] == graphql.Null </span><span class="cov0" title="0">{
                                out.Invalids++
                        }</span>
                case "name":<span class="cov0" title="0">
                        out.Values[i] = ec._User_name(ctx, field, obj)
                        if out.Values[i] == graphql.Null </span><span class="cov0" title="0">{
                                out.Invalids++
                        }</span>
                case "permissions":<span class="cov0" title="0">
                        out.Values[i] = ec._User_permissions(ctx, field, obj)
                        if out.Values[i] == graphql.Null </span><span class="cov0" title="0">{
                                out.Invalids++
                        }</span>
                case "login":<span class="cov0" title="0">
                        out.Values[i] = ec._User_login(ctx, field, obj)
                        if out.Values[i] == graphql.Null </span><span class="cov0" title="0">{
                                out.Invalids++
                        }</span>
                case "enabled":<span class="cov0" title="0">
                        out.Values[i] = ec._User_enabled(ctx, field, obj)
                        if out.Values[i] == graphql.Null </span><span class="cov0" title="0">{
                                out.Invalids++
                        }</span>
                default:<span class="cov0" title="0">
                        panic("unknown field " + strconv.Quote(field.Name))</span>
                }
        }
        <span class="cov0" title="0">out.Dispatch(ctx)
        if out.Invalids &gt; 0 </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>

        <span class="cov0" title="0">atomic.AddInt32(&amp;ec.deferred, int32(len(deferred)))

        for label, dfs := range deferred </span><span class="cov0" title="0">{
                ec.processDeferredGroup(graphql.DeferredGroup{
                        Label:    label,
                        Path:     graphql.GetPath(ctx),
                        FieldSet: dfs,
                        Context:  ctx,
                })
        }</span>

        <span class="cov0" title="0">return out</span>
}

var _ServiceImplementors = []string{"_Service"}

func (ec *executionContext) __Service(ctx context.Context, sel ast.SelectionSet, obj *fedruntime.Service) graphql.Marshaler <span class="cov0" title="0">{
        fields := graphql.CollectFields(ec.OperationContext, sel, _ServiceImplementors)

        out := graphql.NewFieldSet(fields)
        deferred := make(map[string]*graphql.FieldSet)
        for i, field := range fields </span><span class="cov0" title="0">{
                switch field.Name </span>{
                case "__typename":<span class="cov0" title="0">
                        out.Values[i] = graphql.MarshalString("_Service")</span>
                case "sdl":<span class="cov0" title="0">
                        out.Values[i] = ec.__Service_sdl(ctx, field, obj)</span>
                default:<span class="cov0" title="0">
                        panic("unknown field " + strconv.Quote(field.Name))</span>
                }
        }
        <span class="cov0" title="0">out.Dispatch(ctx)
        if out.Invalids &gt; 0 </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>

        <span class="cov0" title="0">atomic.AddInt32(&amp;ec.deferred, int32(len(deferred)))

        for label, dfs := range deferred </span><span class="cov0" title="0">{
                ec.processDeferredGroup(graphql.DeferredGroup{
                        Label:    label,
                        Path:     graphql.GetPath(ctx),
                        FieldSet: dfs,
                        Context:  ctx,
                })
        }</span>

        <span class="cov0" title="0">return out</span>
}

var __DirectiveImplementors = []string{"__Directive"}

func (ec *executionContext) ___Directive(ctx context.Context, sel ast.SelectionSet, obj *introspection.Directive) graphql.Marshaler <span class="cov0" title="0">{
        fields := graphql.CollectFields(ec.OperationContext, sel, __DirectiveImplementors)

        out := graphql.NewFieldSet(fields)
        deferred := make(map[string]*graphql.FieldSet)
        for i, field := range fields </span><span class="cov0" title="0">{
                switch field.Name </span>{
                case "__typename":<span class="cov0" title="0">
                        out.Values[i] = graphql.MarshalString("__Directive")</span>
                case "name":<span class="cov0" title="0">
                        out.Values[i] = ec.___Directive_name(ctx, field, obj)
                        if out.Values[i] == graphql.Null </span><span class="cov0" title="0">{
                                out.Invalids++
                        }</span>
                case "description":<span class="cov0" title="0">
                        out.Values[i] = ec.___Directive_description(ctx, field, obj)</span>
                case "locations":<span class="cov0" title="0">
                        out.Values[i] = ec.___Directive_locations(ctx, field, obj)
                        if out.Values[i] == graphql.Null </span><span class="cov0" title="0">{
                                out.Invalids++
                        }</span>
                case "args":<span class="cov0" title="0">
                        out.Values[i] = ec.___Directive_args(ctx, field, obj)
                        if out.Values[i] == graphql.Null </span><span class="cov0" title="0">{
                                out.Invalids++
                        }</span>
                case "isRepeatable":<span class="cov0" title="0">
                        out.Values[i] = ec.___Directive_isRepeatable(ctx, field, obj)
                        if out.Values[i] == graphql.Null </span><span class="cov0" title="0">{
                                out.Invalids++
                        }</span>
                default:<span class="cov0" title="0">
                        panic("unknown field " + strconv.Quote(field.Name))</span>
                }
        }
        <span class="cov0" title="0">out.Dispatch(ctx)
        if out.Invalids &gt; 0 </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>

        <span class="cov0" title="0">atomic.AddInt32(&amp;ec.deferred, int32(len(deferred)))

        for label, dfs := range deferred </span><span class="cov0" title="0">{
                ec.processDeferredGroup(graphql.DeferredGroup{
                        Label:    label,
                        Path:     graphql.GetPath(ctx),
                        FieldSet: dfs,
                        Context:  ctx,
                })
        }</span>

        <span class="cov0" title="0">return out</span>
}

var __EnumValueImplementors = []string{"__EnumValue"}

func (ec *executionContext) ___EnumValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.EnumValue) graphql.Marshaler <span class="cov0" title="0">{
        fields := graphql.CollectFields(ec.OperationContext, sel, __EnumValueImplementors)

        out := graphql.NewFieldSet(fields)
        deferred := make(map[string]*graphql.FieldSet)
        for i, field := range fields </span><span class="cov0" title="0">{
                switch field.Name </span>{
                case "__typename":<span class="cov0" title="0">
                        out.Values[i] = graphql.MarshalString("__EnumValue")</span>
                case "name":<span class="cov0" title="0">
                        out.Values[i] = ec.___EnumValue_name(ctx, field, obj)
                        if out.Values[i] == graphql.Null </span><span class="cov0" title="0">{
                                out.Invalids++
                        }</span>
                case "description":<span class="cov0" title="0">
                        out.Values[i] = ec.___EnumValue_description(ctx, field, obj)</span>
                case "isDeprecated":<span class="cov0" title="0">
                        out.Values[i] = ec.___EnumValue_isDeprecated(ctx, field, obj)
                        if out.Values[i] == graphql.Null </span><span class="cov0" title="0">{
                                out.Invalids++
                        }</span>
                case "deprecationReason":<span class="cov0" title="0">
                        out.Values[i] = ec.___EnumValue_deprecationReason(ctx, field, obj)</span>
                default:<span class="cov0" title="0">
                        panic("unknown field " + strconv.Quote(field.Name))</span>
                }
        }
        <span class="cov0" title="0">out.Dispatch(ctx)
        if out.Invalids &gt; 0 </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>

        <span class="cov0" title="0">atomic.AddInt32(&amp;ec.deferred, int32(len(deferred)))

        for label, dfs := range deferred </span><span class="cov0" title="0">{
                ec.processDeferredGroup(graphql.DeferredGroup{
                        Label:    label,
                        Path:     graphql.GetPath(ctx),
                        FieldSet: dfs,
                        Context:  ctx,
                })
        }</span>

        <span class="cov0" title="0">return out</span>
}

var __FieldImplementors = []string{"__Field"}

func (ec *executionContext) ___Field(ctx context.Context, sel ast.SelectionSet, obj *introspection.Field) graphql.Marshaler <span class="cov0" title="0">{
        fields := graphql.CollectFields(ec.OperationContext, sel, __FieldImplementors)

        out := graphql.NewFieldSet(fields)
        deferred := make(map[string]*graphql.FieldSet)
        for i, field := range fields </span><span class="cov0" title="0">{
                switch field.Name </span>{
                case "__typename":<span class="cov0" title="0">
                        out.Values[i] = graphql.MarshalString("__Field")</span>
                case "name":<span class="cov0" title="0">
                        out.Values[i] = ec.___Field_name(ctx, field, obj)
                        if out.Values[i] == graphql.Null </span><span class="cov0" title="0">{
                                out.Invalids++
                        }</span>
                case "description":<span class="cov0" title="0">
                        out.Values[i] = ec.___Field_description(ctx, field, obj)</span>
                case "args":<span class="cov0" title="0">
                        out.Values[i] = ec.___Field_args(ctx, field, obj)
                        if out.Values[i] == graphql.Null </span><span class="cov0" title="0">{
                                out.Invalids++
                        }</span>
                case "type":<span class="cov0" title="0">
                        out.Values[i] = ec.___Field_type(ctx, field, obj)
                        if out.Values[i] == graphql.Null </span><span class="cov0" title="0">{
                                out.Invalids++
                        }</span>
                case "isDeprecated":<span class="cov0" title="0">
                        out.Values[i] = ec.___Field_isDeprecated(ctx, field, obj)
                        if out.Values[i] == graphql.Null </span><span class="cov0" title="0">{
                                out.Invalids++
                        }</span>
                case "deprecationReason":<span class="cov0" title="0">
                        out.Values[i] = ec.___Field_deprecationReason(ctx, field, obj)</span>
                default:<span class="cov0" title="0">
                        panic("unknown field " + strconv.Quote(field.Name))</span>
                }
        }
        <span class="cov0" title="0">out.Dispatch(ctx)
        if out.Invalids &gt; 0 </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>

        <span class="cov0" title="0">atomic.AddInt32(&amp;ec.deferred, int32(len(deferred)))

        for label, dfs := range deferred </span><span class="cov0" title="0">{
                ec.processDeferredGroup(graphql.DeferredGroup{
                        Label:    label,
                        Path:     graphql.GetPath(ctx),
                        FieldSet: dfs,
                        Context:  ctx,
                })
        }</span>

        <span class="cov0" title="0">return out</span>
}

var __InputValueImplementors = []string{"__InputValue"}

func (ec *executionContext) ___InputValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.InputValue) graphql.Marshaler <span class="cov0" title="0">{
        fields := graphql.CollectFields(ec.OperationContext, sel, __InputValueImplementors)

        out := graphql.NewFieldSet(fields)
        deferred := make(map[string]*graphql.FieldSet)
        for i, field := range fields </span><span class="cov0" title="0">{
                switch field.Name </span>{
                case "__typename":<span class="cov0" title="0">
                        out.Values[i] = graphql.MarshalString("__InputValue")</span>
                case "name":<span class="cov0" title="0">
                        out.Values[i] = ec.___InputValue_name(ctx, field, obj)
                        if out.Values[i] == graphql.Null </span><span class="cov0" title="0">{
                                out.Invalids++
                        }</span>
                case "description":<span class="cov0" title="0">
                        out.Values[i] = ec.___InputValue_description(ctx, field, obj)</span>
                case "type":<span class="cov0" title="0">
                        out.Values[i] = ec.___InputValue_type(ctx, field, obj)
                        if out.Values[i] == graphql.Null </span><span class="cov0" title="0">{
                                out.Invalids++
                        }</span>
                case "defaultValue":<span class="cov0" title="0">
                        out.Values[i] = ec.___InputValue_defaultValue(ctx, field, obj)</span>
                default:<span class="cov0" title="0">
                        panic("unknown field " + strconv.Quote(field.Name))</span>
                }
        }
        <span class="cov0" title="0">out.Dispatch(ctx)
        if out.Invalids &gt; 0 </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>

        <span class="cov0" title="0">atomic.AddInt32(&amp;ec.deferred, int32(len(deferred)))

        for label, dfs := range deferred </span><span class="cov0" title="0">{
                ec.processDeferredGroup(graphql.DeferredGroup{
                        Label:    label,
                        Path:     graphql.GetPath(ctx),
                        FieldSet: dfs,
                        Context:  ctx,
                })
        }</span>

        <span class="cov0" title="0">return out</span>
}

var __SchemaImplementors = []string{"__Schema"}

func (ec *executionContext) ___Schema(ctx context.Context, sel ast.SelectionSet, obj *introspection.Schema) graphql.Marshaler <span class="cov0" title="0">{
        fields := graphql.CollectFields(ec.OperationContext, sel, __SchemaImplementors)

        out := graphql.NewFieldSet(fields)
        deferred := make(map[string]*graphql.FieldSet)
        for i, field := range fields </span><span class="cov0" title="0">{
                switch field.Name </span>{
                case "__typename":<span class="cov0" title="0">
                        out.Values[i] = graphql.MarshalString("__Schema")</span>
                case "description":<span class="cov0" title="0">
                        out.Values[i] = ec.___Schema_description(ctx, field, obj)</span>
                case "types":<span class="cov0" title="0">
                        out.Values[i] = ec.___Schema_types(ctx, field, obj)
                        if out.Values[i] == graphql.Null </span><span class="cov0" title="0">{
                                out.Invalids++
                        }</span>
                case "queryType":<span class="cov0" title="0">
                        out.Values[i] = ec.___Schema_queryType(ctx, field, obj)
                        if out.Values[i] == graphql.Null </span><span class="cov0" title="0">{
                                out.Invalids++
                        }</span>
                case "mutationType":<span class="cov0" title="0">
                        out.Values[i] = ec.___Schema_mutationType(ctx, field, obj)</span>
                case "subscriptionType":<span class="cov0" title="0">
                        out.Values[i] = ec.___Schema_subscriptionType(ctx, field, obj)</span>
                case "directives":<span class="cov0" title="0">
                        out.Values[i] = ec.___Schema_directives(ctx, field, obj)
                        if out.Values[i] == graphql.Null </span><span class="cov0" title="0">{
                                out.Invalids++
                        }</span>
                default:<span class="cov0" title="0">
                        panic("unknown field " + strconv.Quote(field.Name))</span>
                }
        }
        <span class="cov0" title="0">out.Dispatch(ctx)
        if out.Invalids &gt; 0 </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>

        <span class="cov0" title="0">atomic.AddInt32(&amp;ec.deferred, int32(len(deferred)))

        for label, dfs := range deferred </span><span class="cov0" title="0">{
                ec.processDeferredGroup(graphql.DeferredGroup{
                        Label:    label,
                        Path:     graphql.GetPath(ctx),
                        FieldSet: dfs,
                        Context:  ctx,
                })
        }</span>

        <span class="cov0" title="0">return out</span>
}

var __TypeImplementors = []string{"__Type"}

func (ec *executionContext) ___Type(ctx context.Context, sel ast.SelectionSet, obj *introspection.Type) graphql.Marshaler <span class="cov0" title="0">{
        fields := graphql.CollectFields(ec.OperationContext, sel, __TypeImplementors)

        out := graphql.NewFieldSet(fields)
        deferred := make(map[string]*graphql.FieldSet)
        for i, field := range fields </span><span class="cov0" title="0">{
                switch field.Name </span>{
                case "__typename":<span class="cov0" title="0">
                        out.Values[i] = graphql.MarshalString("__Type")</span>
                case "kind":<span class="cov0" title="0">
                        out.Values[i] = ec.___Type_kind(ctx, field, obj)
                        if out.Values[i] == graphql.Null </span><span class="cov0" title="0">{
                                out.Invalids++
                        }</span>
                case "name":<span class="cov0" title="0">
                        out.Values[i] = ec.___Type_name(ctx, field, obj)</span>
                case "description":<span class="cov0" title="0">
                        out.Values[i] = ec.___Type_description(ctx, field, obj)</span>
                case "fields":<span class="cov0" title="0">
                        out.Values[i] = ec.___Type_fields(ctx, field, obj)</span>
                case "interfaces":<span class="cov0" title="0">
                        out.Values[i] = ec.___Type_interfaces(ctx, field, obj)</span>
                case "possibleTypes":<span class="cov0" title="0">
                        out.Values[i] = ec.___Type_possibleTypes(ctx, field, obj)</span>
                case "enumValues":<span class="cov0" title="0">
                        out.Values[i] = ec.___Type_enumValues(ctx, field, obj)</span>
                case "inputFields":<span class="cov0" title="0">
                        out.Values[i] = ec.___Type_inputFields(ctx, field, obj)</span>
                case "ofType":<span class="cov0" title="0">
                        out.Values[i] = ec.___Type_ofType(ctx, field, obj)</span>
                case "specifiedByURL":<span class="cov0" title="0">
                        out.Values[i] = ec.___Type_specifiedByURL(ctx, field, obj)</span>
                default:<span class="cov0" title="0">
                        panic("unknown field " + strconv.Quote(field.Name))</span>
                }
        }
        <span class="cov0" title="0">out.Dispatch(ctx)
        if out.Invalids &gt; 0 </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>

        <span class="cov0" title="0">atomic.AddInt32(&amp;ec.deferred, int32(len(deferred)))

        for label, dfs := range deferred </span><span class="cov0" title="0">{
                ec.processDeferredGroup(graphql.DeferredGroup{
                        Label:    label,
                        Path:     graphql.GetPath(ctx),
                        FieldSet: dfs,
                        Context:  ctx,
                })
        }</span>

        <span class="cov0" title="0">return out</span>
}

// endregion **************************** object.gotpl ****************************

// region    ***************************** type.gotpl *****************************

func (ec *executionContext) unmarshalNBoolean2bool(ctx context.Context, v interface{}) (bool, error) <span class="cov0" title="0">{
        res, err := graphql.UnmarshalBoolean(v)
        return res, graphql.ErrorOnPath(ctx, err)
}</span>

func (ec *executionContext) marshalNBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler <span class="cov0" title="0">{
        res := graphql.MarshalBoolean(v)
        if res == graphql.Null </span><span class="cov0" title="0">{
                if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) </span><span class="cov0" title="0">{
                        ec.Errorf(ctx, "the requested element is null which the schema does not allow")
                }</span>
        }
        <span class="cov0" title="0">return res</span>
}

func (ec *executionContext) unmarshalNString2string(ctx context.Context, v interface{}) (string, error) <span class="cov0" title="0">{
        res, err := graphql.UnmarshalString(v)
        return res, graphql.ErrorOnPath(ctx, err)
}</span>

func (ec *executionContext) marshalNString2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler <span class="cov0" title="0">{
        res := graphql.MarshalString(v)
        if res == graphql.Null </span><span class="cov0" title="0">{
                if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) </span><span class="cov0" title="0">{
                        ec.Errorf(ctx, "the requested element is null which the schema does not allow")
                }</span>
        }
        <span class="cov0" title="0">return res</span>
}

func (ec *executionContext) unmarshalNString2ᚕstringᚄ(ctx context.Context, v interface{}) ([]string, error) <span class="cov0" title="0">{
        var vSlice []interface{}
        if v != nil </span><span class="cov0" title="0">{
                vSlice = graphql.CoerceList(v)
        }</span>
        <span class="cov0" title="0">var err error
        res := make([]string, len(vSlice))
        for i := range vSlice </span><span class="cov0" title="0">{
                ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
                res[i], err = ec.unmarshalNString2string(ctx, vSlice[i])
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }
        <span class="cov0" title="0">return res, nil</span>
}

func (ec *executionContext) marshalNString2ᚕstringᚄ(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler <span class="cov0" title="0">{
        ret := make(graphql.Array, len(v))
        for i := range v </span><span class="cov0" title="0">{
                ret[i] = ec.marshalNString2string(ctx, sel, v[i])
        }</span>

        <span class="cov0" title="0">for _, e := range ret </span><span class="cov0" title="0">{
                if e == graphql.Null </span><span class="cov0" title="0">{
                        return graphql.Null
                }</span>
        }

        <span class="cov0" title="0">return ret</span>
}

func (ec *executionContext) marshalNToken2githubᚗcomᚋnmarsollierᚋauthgoᚋinternalᚋgraphᚋmodelᚐToken(ctx context.Context, sel ast.SelectionSet, v Token) graphql.Marshaler <span class="cov0" title="0">{
        return ec._Token(ctx, sel, &amp;v)
}</span>

func (ec *executionContext) marshalNToken2ᚖgithubᚗcomᚋnmarsollierᚋauthgoᚋinternalᚋgraphᚋmodelᚐToken(ctx context.Context, sel ast.SelectionSet, v *Token) graphql.Marshaler <span class="cov0" title="0">{
        if v == nil </span><span class="cov0" title="0">{
                if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) </span><span class="cov0" title="0">{
                        ec.Errorf(ctx, "the requested element is null which the schema does not allow")
                }</span>
                <span class="cov0" title="0">return graphql.Null</span>
        }
        <span class="cov0" title="0">return ec._Token(ctx, sel, v)</span>
}

func (ec *executionContext) marshalNUser2githubᚗcomᚋnmarsollierᚋauthgoᚋinternalᚋgraphᚋmodelᚐUser(ctx context.Context, sel ast.SelectionSet, v User) graphql.Marshaler <span class="cov0" title="0">{
        return ec._User(ctx, sel, &amp;v)
}</span>

func (ec *executionContext) marshalNUser2ᚕᚖgithubᚗcomᚋnmarsollierᚋauthgoᚋinternalᚋgraphᚋmodelᚐUserᚄ(ctx context.Context, sel ast.SelectionSet, v []*User) graphql.Marshaler <span class="cov0" title="0">{
        ret := make(graphql.Array, len(v))
        var wg sync.WaitGroup
        isLen1 := len(v) == 1
        if !isLen1 </span><span class="cov0" title="0">{
                wg.Add(len(v))
        }</span>
        <span class="cov0" title="0">for i := range v </span><span class="cov0" title="0">{
                i := i
                fc := &amp;graphql.FieldContext{
                        Index:  &amp;i,
                        Result: &amp;v[i],
                }
                ctx := graphql.WithFieldContext(ctx, fc)
                f := func(i int) </span><span class="cov0" title="0">{
                        defer func() </span><span class="cov0" title="0">{
                                if r := recover(); r != nil </span><span class="cov0" title="0">{
                                        ec.Error(ctx, ec.Recover(ctx, r))
                                        ret = nil
                                }</span>
                        }()
                        <span class="cov0" title="0">if !isLen1 </span><span class="cov0" title="0">{
                                defer wg.Done()
                        }</span>
                        <span class="cov0" title="0">ret[i] = ec.marshalNUser2ᚖgithubᚗcomᚋnmarsollierᚋauthgoᚋinternalᚋgraphᚋmodelᚐUser(ctx, sel, v[i])</span>
                }
                <span class="cov0" title="0">if isLen1 </span><span class="cov0" title="0">{
                        f(i)
                }</span> else<span class="cov0" title="0"> {
                        go f(i)
                }</span>

        }
        <span class="cov0" title="0">wg.Wait()

        for _, e := range ret </span><span class="cov0" title="0">{
                if e == graphql.Null </span><span class="cov0" title="0">{
                        return graphql.Null
                }</span>
        }

        <span class="cov0" title="0">return ret</span>
}

func (ec *executionContext) marshalNUser2ᚖgithubᚗcomᚋnmarsollierᚋauthgoᚋinternalᚋgraphᚋmodelᚐUser(ctx context.Context, sel ast.SelectionSet, v *User) graphql.Marshaler <span class="cov0" title="0">{
        if v == nil </span><span class="cov0" title="0">{
                if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) </span><span class="cov0" title="0">{
                        ec.Errorf(ctx, "the requested element is null which the schema does not allow")
                }</span>
                <span class="cov0" title="0">return graphql.Null</span>
        }
        <span class="cov0" title="0">return ec._User(ctx, sel, v)</span>
}

func (ec *executionContext) unmarshalN_Any2map(ctx context.Context, v interface{}) (map[string]interface{}, error) <span class="cov0" title="0">{
        res, err := graphql.UnmarshalMap(v)
        return res, graphql.ErrorOnPath(ctx, err)
}</span>

func (ec *executionContext) marshalN_Any2map(ctx context.Context, sel ast.SelectionSet, v map[string]interface{}) graphql.Marshaler <span class="cov0" title="0">{
        if v == nil </span><span class="cov0" title="0">{
                if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) </span><span class="cov0" title="0">{
                        ec.Errorf(ctx, "the requested element is null which the schema does not allow")
                }</span>
                <span class="cov0" title="0">return graphql.Null</span>
        }
        <span class="cov0" title="0">res := graphql.MarshalMap(v)
        if res == graphql.Null </span><span class="cov0" title="0">{
                if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) </span><span class="cov0" title="0">{
                        ec.Errorf(ctx, "the requested element is null which the schema does not allow")
                }</span>
        }
        <span class="cov0" title="0">return res</span>
}

func (ec *executionContext) unmarshalN_Any2ᚕmapᚄ(ctx context.Context, v interface{}) ([]map[string]interface{}, error) <span class="cov0" title="0">{
        var vSlice []interface{}
        if v != nil </span><span class="cov0" title="0">{
                vSlice = graphql.CoerceList(v)
        }</span>
        <span class="cov0" title="0">var err error
        res := make([]map[string]interface{}, len(vSlice))
        for i := range vSlice </span><span class="cov0" title="0">{
                ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
                res[i], err = ec.unmarshalN_Any2map(ctx, vSlice[i])
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }
        <span class="cov0" title="0">return res, nil</span>
}

func (ec *executionContext) marshalN_Any2ᚕmapᚄ(ctx context.Context, sel ast.SelectionSet, v []map[string]interface{}) graphql.Marshaler <span class="cov0" title="0">{
        ret := make(graphql.Array, len(v))
        for i := range v </span><span class="cov0" title="0">{
                ret[i] = ec.marshalN_Any2map(ctx, sel, v[i])
        }</span>

        <span class="cov0" title="0">for _, e := range ret </span><span class="cov0" title="0">{
                if e == graphql.Null </span><span class="cov0" title="0">{
                        return graphql.Null
                }</span>
        }

        <span class="cov0" title="0">return ret</span>
}

func (ec *executionContext) marshalN_Entity2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋpluginᚋfederationᚋfedruntimeᚐEntity(ctx context.Context, sel ast.SelectionSet, v []fedruntime.Entity) graphql.Marshaler <span class="cov0" title="0">{
        ret := make(graphql.Array, len(v))
        var wg sync.WaitGroup
        isLen1 := len(v) == 1
        if !isLen1 </span><span class="cov0" title="0">{
                wg.Add(len(v))
        }</span>
        <span class="cov0" title="0">for i := range v </span><span class="cov0" title="0">{
                i := i
                fc := &amp;graphql.FieldContext{
                        Index:  &amp;i,
                        Result: &amp;v[i],
                }
                ctx := graphql.WithFieldContext(ctx, fc)
                f := func(i int) </span><span class="cov0" title="0">{
                        defer func() </span><span class="cov0" title="0">{
                                if r := recover(); r != nil </span><span class="cov0" title="0">{
                                        ec.Error(ctx, ec.Recover(ctx, r))
                                        ret = nil
                                }</span>
                        }()
                        <span class="cov0" title="0">if !isLen1 </span><span class="cov0" title="0">{
                                defer wg.Done()
                        }</span>
                        <span class="cov0" title="0">ret[i] = ec.marshalO_Entity2githubᚗcomᚋ99designsᚋgqlgenᚋpluginᚋfederationᚋfedruntimeᚐEntity(ctx, sel, v[i])</span>
                }
                <span class="cov0" title="0">if isLen1 </span><span class="cov0" title="0">{
                        f(i)
                }</span> else<span class="cov0" title="0"> {
                        go f(i)
                }</span>

        }
        <span class="cov0" title="0">wg.Wait()

        return ret</span>
}

func (ec *executionContext) unmarshalN_FieldSet2string(ctx context.Context, v interface{}) (string, error) <span class="cov0" title="0">{
        res, err := graphql.UnmarshalString(v)
        return res, graphql.ErrorOnPath(ctx, err)
}</span>

func (ec *executionContext) marshalN_FieldSet2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler <span class="cov0" title="0">{
        res := graphql.MarshalString(v)
        if res == graphql.Null </span><span class="cov0" title="0">{
                if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) </span><span class="cov0" title="0">{
                        ec.Errorf(ctx, "the requested element is null which the schema does not allow")
                }</span>
        }
        <span class="cov0" title="0">return res</span>
}

func (ec *executionContext) marshalN_Service2githubᚗcomᚋ99designsᚋgqlgenᚋpluginᚋfederationᚋfedruntimeᚐService(ctx context.Context, sel ast.SelectionSet, v fedruntime.Service) graphql.Marshaler <span class="cov0" title="0">{
        return ec.__Service(ctx, sel, &amp;v)
}</span>

func (ec *executionContext) marshalN__Directive2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirective(ctx context.Context, sel ast.SelectionSet, v introspection.Directive) graphql.Marshaler <span class="cov0" title="0">{
        return ec.___Directive(ctx, sel, &amp;v)
}</span>

func (ec *executionContext) marshalN__Directive2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirectiveᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.Directive) graphql.Marshaler <span class="cov0" title="0">{
        ret := make(graphql.Array, len(v))
        var wg sync.WaitGroup
        isLen1 := len(v) == 1
        if !isLen1 </span><span class="cov0" title="0">{
                wg.Add(len(v))
        }</span>
        <span class="cov0" title="0">for i := range v </span><span class="cov0" title="0">{
                i := i
                fc := &amp;graphql.FieldContext{
                        Index:  &amp;i,
                        Result: &amp;v[i],
                }
                ctx := graphql.WithFieldContext(ctx, fc)
                f := func(i int) </span><span class="cov0" title="0">{
                        defer func() </span><span class="cov0" title="0">{
                                if r := recover(); r != nil </span><span class="cov0" title="0">{
                                        ec.Error(ctx, ec.Recover(ctx, r))
                                        ret = nil
                                }</span>
                        }()
                        <span class="cov0" title="0">if !isLen1 </span><span class="cov0" title="0">{
                                defer wg.Done()
                        }</span>
                        <span class="cov0" title="0">ret[i] = ec.marshalN__Directive2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirective(ctx, sel, v[i])</span>
                }
                <span class="cov0" title="0">if isLen1 </span><span class="cov0" title="0">{
                        f(i)
                }</span> else<span class="cov0" title="0"> {
                        go f(i)
                }</span>

        }
        <span class="cov0" title="0">wg.Wait()

        for _, e := range ret </span><span class="cov0" title="0">{
                if e == graphql.Null </span><span class="cov0" title="0">{
                        return graphql.Null
                }</span>
        }

        <span class="cov0" title="0">return ret</span>
}

func (ec *executionContext) unmarshalN__DirectiveLocation2string(ctx context.Context, v interface{}) (string, error) <span class="cov0" title="0">{
        res, err := graphql.UnmarshalString(v)
        return res, graphql.ErrorOnPath(ctx, err)
}</span>

func (ec *executionContext) marshalN__DirectiveLocation2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler <span class="cov0" title="0">{
        res := graphql.MarshalString(v)
        if res == graphql.Null </span><span class="cov0" title="0">{
                if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) </span><span class="cov0" title="0">{
                        ec.Errorf(ctx, "the requested element is null which the schema does not allow")
                }</span>
        }
        <span class="cov0" title="0">return res</span>
}

func (ec *executionContext) unmarshalN__DirectiveLocation2ᚕstringᚄ(ctx context.Context, v interface{}) ([]string, error) <span class="cov0" title="0">{
        var vSlice []interface{}
        if v != nil </span><span class="cov0" title="0">{
                vSlice = graphql.CoerceList(v)
        }</span>
        <span class="cov0" title="0">var err error
        res := make([]string, len(vSlice))
        for i := range vSlice </span><span class="cov0" title="0">{
                ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
                res[i], err = ec.unmarshalN__DirectiveLocation2string(ctx, vSlice[i])
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }
        <span class="cov0" title="0">return res, nil</span>
}

func (ec *executionContext) marshalN__DirectiveLocation2ᚕstringᚄ(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler <span class="cov0" title="0">{
        ret := make(graphql.Array, len(v))
        var wg sync.WaitGroup
        isLen1 := len(v) == 1
        if !isLen1 </span><span class="cov0" title="0">{
                wg.Add(len(v))
        }</span>
        <span class="cov0" title="0">for i := range v </span><span class="cov0" title="0">{
                i := i
                fc := &amp;graphql.FieldContext{
                        Index:  &amp;i,
                        Result: &amp;v[i],
                }
                ctx := graphql.WithFieldContext(ctx, fc)
                f := func(i int) </span><span class="cov0" title="0">{
                        defer func() </span><span class="cov0" title="0">{
                                if r := recover(); r != nil </span><span class="cov0" title="0">{
                                        ec.Error(ctx, ec.Recover(ctx, r))
                                        ret = nil
                                }</span>
                        }()
                        <span class="cov0" title="0">if !isLen1 </span><span class="cov0" title="0">{
                                defer wg.Done()
                        }</span>
                        <span class="cov0" title="0">ret[i] = ec.marshalN__DirectiveLocation2string(ctx, sel, v[i])</span>
                }
                <span class="cov0" title="0">if isLen1 </span><span class="cov0" title="0">{
                        f(i)
                }</span> else<span class="cov0" title="0"> {
                        go f(i)
                }</span>

        }
        <span class="cov0" title="0">wg.Wait()

        for _, e := range ret </span><span class="cov0" title="0">{
                if e == graphql.Null </span><span class="cov0" title="0">{
                        return graphql.Null
                }</span>
        }

        <span class="cov0" title="0">return ret</span>
}

func (ec *executionContext) marshalN__EnumValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValue(ctx context.Context, sel ast.SelectionSet, v introspection.EnumValue) graphql.Marshaler <span class="cov0" title="0">{
        return ec.___EnumValue(ctx, sel, &amp;v)
}</span>

func (ec *executionContext) marshalN__Field2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐField(ctx context.Context, sel ast.SelectionSet, v introspection.Field) graphql.Marshaler <span class="cov0" title="0">{
        return ec.___Field(ctx, sel, &amp;v)
}</span>

func (ec *executionContext) marshalN__InputValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValue(ctx context.Context, sel ast.SelectionSet, v introspection.InputValue) graphql.Marshaler <span class="cov0" title="0">{
        return ec.___InputValue(ctx, sel, &amp;v)
}</span>

func (ec *executionContext) marshalN__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler <span class="cov0" title="0">{
        ret := make(graphql.Array, len(v))
        var wg sync.WaitGroup
        isLen1 := len(v) == 1
        if !isLen1 </span><span class="cov0" title="0">{
                wg.Add(len(v))
        }</span>
        <span class="cov0" title="0">for i := range v </span><span class="cov0" title="0">{
                i := i
                fc := &amp;graphql.FieldContext{
                        Index:  &amp;i,
                        Result: &amp;v[i],
                }
                ctx := graphql.WithFieldContext(ctx, fc)
                f := func(i int) </span><span class="cov0" title="0">{
                        defer func() </span><span class="cov0" title="0">{
                                if r := recover(); r != nil </span><span class="cov0" title="0">{
                                        ec.Error(ctx, ec.Recover(ctx, r))
                                        ret = nil
                                }</span>
                        }()
                        <span class="cov0" title="0">if !isLen1 </span><span class="cov0" title="0">{
                                defer wg.Done()
                        }</span>
                        <span class="cov0" title="0">ret[i] = ec.marshalN__InputValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValue(ctx, sel, v[i])</span>
                }
                <span class="cov0" title="0">if isLen1 </span><span class="cov0" title="0">{
                        f(i)
                }</span> else<span class="cov0" title="0"> {
                        go f(i)
                }</span>

        }
        <span class="cov0" title="0">wg.Wait()

        for _, e := range ret </span><span class="cov0" title="0">{
                if e == graphql.Null </span><span class="cov0" title="0">{
                        return graphql.Null
                }</span>
        }

        <span class="cov0" title="0">return ret</span>
}

func (ec *executionContext) marshalN__Type2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx context.Context, sel ast.SelectionSet, v introspection.Type) graphql.Marshaler <span class="cov0" title="0">{
        return ec.___Type(ctx, sel, &amp;v)
}</span>

func (ec *executionContext) marshalN__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler <span class="cov0" title="0">{
        ret := make(graphql.Array, len(v))
        var wg sync.WaitGroup
        isLen1 := len(v) == 1
        if !isLen1 </span><span class="cov0" title="0">{
                wg.Add(len(v))
        }</span>
        <span class="cov0" title="0">for i := range v </span><span class="cov0" title="0">{
                i := i
                fc := &amp;graphql.FieldContext{
                        Index:  &amp;i,
                        Result: &amp;v[i],
                }
                ctx := graphql.WithFieldContext(ctx, fc)
                f := func(i int) </span><span class="cov0" title="0">{
                        defer func() </span><span class="cov0" title="0">{
                                if r := recover(); r != nil </span><span class="cov0" title="0">{
                                        ec.Error(ctx, ec.Recover(ctx, r))
                                        ret = nil
                                }</span>
                        }()
                        <span class="cov0" title="0">if !isLen1 </span><span class="cov0" title="0">{
                                defer wg.Done()
                        }</span>
                        <span class="cov0" title="0">ret[i] = ec.marshalN__Type2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, sel, v[i])</span>
                }
                <span class="cov0" title="0">if isLen1 </span><span class="cov0" title="0">{
                        f(i)
                }</span> else<span class="cov0" title="0"> {
                        go f(i)
                }</span>

        }
        <span class="cov0" title="0">wg.Wait()

        for _, e := range ret </span><span class="cov0" title="0">{
                if e == graphql.Null </span><span class="cov0" title="0">{
                        return graphql.Null
                }</span>
        }

        <span class="cov0" title="0">return ret</span>
}

func (ec *executionContext) marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler <span class="cov0" title="0">{
        if v == nil </span><span class="cov0" title="0">{
                if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) </span><span class="cov0" title="0">{
                        ec.Errorf(ctx, "the requested element is null which the schema does not allow")
                }</span>
                <span class="cov0" title="0">return graphql.Null</span>
        }
        <span class="cov0" title="0">return ec.___Type(ctx, sel, v)</span>
}

func (ec *executionContext) unmarshalN__TypeKind2string(ctx context.Context, v interface{}) (string, error) <span class="cov0" title="0">{
        res, err := graphql.UnmarshalString(v)
        return res, graphql.ErrorOnPath(ctx, err)
}</span>

func (ec *executionContext) marshalN__TypeKind2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler <span class="cov0" title="0">{
        res := graphql.MarshalString(v)
        if res == graphql.Null </span><span class="cov0" title="0">{
                if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) </span><span class="cov0" title="0">{
                        ec.Errorf(ctx, "the requested element is null which the schema does not allow")
                }</span>
        }
        <span class="cov0" title="0">return res</span>
}

func (ec *executionContext) unmarshalOBoolean2bool(ctx context.Context, v interface{}) (bool, error) <span class="cov0" title="0">{
        res, err := graphql.UnmarshalBoolean(v)
        return res, graphql.ErrorOnPath(ctx, err)
}</span>

func (ec *executionContext) marshalOBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler <span class="cov0" title="0">{
        res := graphql.MarshalBoolean(v)
        return res
}</span>

func (ec *executionContext) unmarshalOBoolean2ᚖbool(ctx context.Context, v interface{}) (*bool, error) <span class="cov0" title="0">{
        if v == nil </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov0" title="0">res, err := graphql.UnmarshalBoolean(v)
        return &amp;res, graphql.ErrorOnPath(ctx, err)</span>
}

func (ec *executionContext) marshalOBoolean2ᚖbool(ctx context.Context, sel ast.SelectionSet, v *bool) graphql.Marshaler <span class="cov0" title="0">{
        if v == nil </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>
        <span class="cov0" title="0">res := graphql.MarshalBoolean(*v)
        return res</span>
}

func (ec *executionContext) unmarshalOString2string(ctx context.Context, v interface{}) (string, error) <span class="cov0" title="0">{
        res, err := graphql.UnmarshalString(v)
        return res, graphql.ErrorOnPath(ctx, err)
}</span>

func (ec *executionContext) marshalOString2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler <span class="cov0" title="0">{
        res := graphql.MarshalString(v)
        return res
}</span>

func (ec *executionContext) unmarshalOString2ᚕstringᚄ(ctx context.Context, v interface{}) ([]string, error) <span class="cov0" title="0">{
        if v == nil </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov0" title="0">var vSlice []interface{}
        if v != nil </span><span class="cov0" title="0">{
                vSlice = graphql.CoerceList(v)
        }</span>
        <span class="cov0" title="0">var err error
        res := make([]string, len(vSlice))
        for i := range vSlice </span><span class="cov0" title="0">{
                ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
                res[i], err = ec.unmarshalNString2string(ctx, vSlice[i])
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }
        <span class="cov0" title="0">return res, nil</span>
}

func (ec *executionContext) marshalOString2ᚕstringᚄ(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler <span class="cov0" title="0">{
        if v == nil </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>
        <span class="cov0" title="0">ret := make(graphql.Array, len(v))
        for i := range v </span><span class="cov0" title="0">{
                ret[i] = ec.marshalNString2string(ctx, sel, v[i])
        }</span>

        <span class="cov0" title="0">for _, e := range ret </span><span class="cov0" title="0">{
                if e == graphql.Null </span><span class="cov0" title="0">{
                        return graphql.Null
                }</span>
        }

        <span class="cov0" title="0">return ret</span>
}

func (ec *executionContext) unmarshalOString2ᚖstring(ctx context.Context, v interface{}) (*string, error) <span class="cov0" title="0">{
        if v == nil </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov0" title="0">res, err := graphql.UnmarshalString(v)
        return &amp;res, graphql.ErrorOnPath(ctx, err)</span>
}

func (ec *executionContext) marshalOString2ᚖstring(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler <span class="cov0" title="0">{
        if v == nil </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>
        <span class="cov0" title="0">res := graphql.MarshalString(*v)
        return res</span>
}

func (ec *executionContext) marshalO_Entity2githubᚗcomᚋ99designsᚋgqlgenᚋpluginᚋfederationᚋfedruntimeᚐEntity(ctx context.Context, sel ast.SelectionSet, v fedruntime.Entity) graphql.Marshaler <span class="cov0" title="0">{
        if v == nil </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>
        <span class="cov0" title="0">return ec.__Entity(ctx, sel, v)</span>
}

func (ec *executionContext) marshalO__EnumValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValueᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.EnumValue) graphql.Marshaler <span class="cov0" title="0">{
        if v == nil </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>
        <span class="cov0" title="0">ret := make(graphql.Array, len(v))
        var wg sync.WaitGroup
        isLen1 := len(v) == 1
        if !isLen1 </span><span class="cov0" title="0">{
                wg.Add(len(v))
        }</span>
        <span class="cov0" title="0">for i := range v </span><span class="cov0" title="0">{
                i := i
                fc := &amp;graphql.FieldContext{
                        Index:  &amp;i,
                        Result: &amp;v[i],
                }
                ctx := graphql.WithFieldContext(ctx, fc)
                f := func(i int) </span><span class="cov0" title="0">{
                        defer func() </span><span class="cov0" title="0">{
                                if r := recover(); r != nil </span><span class="cov0" title="0">{
                                        ec.Error(ctx, ec.Recover(ctx, r))
                                        ret = nil
                                }</span>
                        }()
                        <span class="cov0" title="0">if !isLen1 </span><span class="cov0" title="0">{
                                defer wg.Done()
                        }</span>
                        <span class="cov0" title="0">ret[i] = ec.marshalN__EnumValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValue(ctx, sel, v[i])</span>
                }
                <span class="cov0" title="0">if isLen1 </span><span class="cov0" title="0">{
                        f(i)
                }</span> else<span class="cov0" title="0"> {
                        go f(i)
                }</span>

        }
        <span class="cov0" title="0">wg.Wait()

        for _, e := range ret </span><span class="cov0" title="0">{
                if e == graphql.Null </span><span class="cov0" title="0">{
                        return graphql.Null
                }</span>
        }

        <span class="cov0" title="0">return ret</span>
}

func (ec *executionContext) marshalO__Field2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐFieldᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.Field) graphql.Marshaler <span class="cov0" title="0">{
        if v == nil </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>
        <span class="cov0" title="0">ret := make(graphql.Array, len(v))
        var wg sync.WaitGroup
        isLen1 := len(v) == 1
        if !isLen1 </span><span class="cov0" title="0">{
                wg.Add(len(v))
        }</span>
        <span class="cov0" title="0">for i := range v </span><span class="cov0" title="0">{
                i := i
                fc := &amp;graphql.FieldContext{
                        Index:  &amp;i,
                        Result: &amp;v[i],
                }
                ctx := graphql.WithFieldContext(ctx, fc)
                f := func(i int) </span><span class="cov0" title="0">{
                        defer func() </span><span class="cov0" title="0">{
                                if r := recover(); r != nil </span><span class="cov0" title="0">{
                                        ec.Error(ctx, ec.Recover(ctx, r))
                                        ret = nil
                                }</span>
                        }()
                        <span class="cov0" title="0">if !isLen1 </span><span class="cov0" title="0">{
                                defer wg.Done()
                        }</span>
                        <span class="cov0" title="0">ret[i] = ec.marshalN__Field2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐField(ctx, sel, v[i])</span>
                }
                <span class="cov0" title="0">if isLen1 </span><span class="cov0" title="0">{
                        f(i)
                }</span> else<span class="cov0" title="0"> {
                        go f(i)
                }</span>

        }
        <span class="cov0" title="0">wg.Wait()

        for _, e := range ret </span><span class="cov0" title="0">{
                if e == graphql.Null </span><span class="cov0" title="0">{
                        return graphql.Null
                }</span>
        }

        <span class="cov0" title="0">return ret</span>
}

func (ec *executionContext) marshalO__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler <span class="cov0" title="0">{
        if v == nil </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>
        <span class="cov0" title="0">ret := make(graphql.Array, len(v))
        var wg sync.WaitGroup
        isLen1 := len(v) == 1
        if !isLen1 </span><span class="cov0" title="0">{
                wg.Add(len(v))
        }</span>
        <span class="cov0" title="0">for i := range v </span><span class="cov0" title="0">{
                i := i
                fc := &amp;graphql.FieldContext{
                        Index:  &amp;i,
                        Result: &amp;v[i],
                }
                ctx := graphql.WithFieldContext(ctx, fc)
                f := func(i int) </span><span class="cov0" title="0">{
                        defer func() </span><span class="cov0" title="0">{
                                if r := recover(); r != nil </span><span class="cov0" title="0">{
                                        ec.Error(ctx, ec.Recover(ctx, r))
                                        ret = nil
                                }</span>
                        }()
                        <span class="cov0" title="0">if !isLen1 </span><span class="cov0" title="0">{
                                defer wg.Done()
                        }</span>
                        <span class="cov0" title="0">ret[i] = ec.marshalN__InputValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValue(ctx, sel, v[i])</span>
                }
                <span class="cov0" title="0">if isLen1 </span><span class="cov0" title="0">{
                        f(i)
                }</span> else<span class="cov0" title="0"> {
                        go f(i)
                }</span>

        }
        <span class="cov0" title="0">wg.Wait()

        for _, e := range ret </span><span class="cov0" title="0">{
                if e == graphql.Null </span><span class="cov0" title="0">{
                        return graphql.Null
                }</span>
        }

        <span class="cov0" title="0">return ret</span>
}

func (ec *executionContext) marshalO__Schema2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐSchema(ctx context.Context, sel ast.SelectionSet, v *introspection.Schema) graphql.Marshaler <span class="cov0" title="0">{
        if v == nil </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>
        <span class="cov0" title="0">return ec.___Schema(ctx, sel, v)</span>
}

func (ec *executionContext) marshalO__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler <span class="cov0" title="0">{
        if v == nil </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>
        <span class="cov0" title="0">ret := make(graphql.Array, len(v))
        var wg sync.WaitGroup
        isLen1 := len(v) == 1
        if !isLen1 </span><span class="cov0" title="0">{
                wg.Add(len(v))
        }</span>
        <span class="cov0" title="0">for i := range v </span><span class="cov0" title="0">{
                i := i
                fc := &amp;graphql.FieldContext{
                        Index:  &amp;i,
                        Result: &amp;v[i],
                }
                ctx := graphql.WithFieldContext(ctx, fc)
                f := func(i int) </span><span class="cov0" title="0">{
                        defer func() </span><span class="cov0" title="0">{
                                if r := recover(); r != nil </span><span class="cov0" title="0">{
                                        ec.Error(ctx, ec.Recover(ctx, r))
                                        ret = nil
                                }</span>
                        }()
                        <span class="cov0" title="0">if !isLen1 </span><span class="cov0" title="0">{
                                defer wg.Done()
                        }</span>
                        <span class="cov0" title="0">ret[i] = ec.marshalN__Type2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, sel, v[i])</span>
                }
                <span class="cov0" title="0">if isLen1 </span><span class="cov0" title="0">{
                        f(i)
                }</span> else<span class="cov0" title="0"> {
                        go f(i)
                }</span>

        }
        <span class="cov0" title="0">wg.Wait()

        for _, e := range ret </span><span class="cov0" title="0">{
                if e == graphql.Null </span><span class="cov0" title="0">{
                        return graphql.Null
                }</span>
        }

        <span class="cov0" title="0">return ret</span>
}

func (ec *executionContext) marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler <span class="cov0" title="0">{
        if v == nil </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>
        <span class="cov0" title="0">return ec.___Type(ctx, sel, v)</span>
}

// endregion ***************************** type.gotpl *****************************
</pre>
		
		<pre class="file" id="file14" style="display: none">package resolvers

import (
        "context"

        "github.com/nmarsollier/authgo/internal/graph/tools"
)

func ChangePassword(ctx context.Context, oldPassword string, newPassword string) (bool, error) <span class="cov0" title="0">{
        token, err := tools.HeaderToken(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov0" title="0">di := tools.GqlDi(ctx)
        if err := di.UserService().ChangePassword(token.UserID.Hex(), oldPassword, newPassword); err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov0" title="0">return true, nil</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package resolvers

import (
        "context"

        "github.com/nmarsollier/authgo/internal/graph/model"
        "github.com/nmarsollier/authgo/internal/graph/tools"
)

func CurrentUser(ctx context.Context) (*model.User, error) <span class="cov0" title="0">{
        token, err := tools.HeaderToken(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">di := tools.GqlDi(ctx)
        user, err := di.UserService().FindById(token.UserID.Hex())
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return ToUser(user), nil</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package resolvers

import (
        "context"

        "github.com/nmarsollier/authgo/internal/graph/tools"
)

func Disable(ctx context.Context, userID string) (bool, error) <span class="cov0" title="0">{
        if err := tools.ValidateAdmin(ctx); err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov0" title="0">di := tools.GqlDi(ctx)

        if err := di.UserService().Disable(userID); err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov0" title="0">return true, nil</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package resolvers

import (
        "context"

        "github.com/nmarsollier/authgo/internal/graph/tools"
)

func Enable(ctx context.Context, userID string) (bool, error) <span class="cov0" title="0">{
        if err := tools.ValidateAdmin(ctx); err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov0" title="0">di := tools.GqlDi(ctx)

        if err := di.UserService().Enable(userID); err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov0" title="0">return true, nil</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package resolvers

import (
        "context"

        "github.com/nmarsollier/authgo/internal/graph/model"
        "github.com/nmarsollier/authgo/internal/graph/tools"
)

func FindAllUsers(ctx context.Context) ([]*model.User, error) <span class="cov0" title="0">{
        if err := tools.ValidateAdmin(ctx); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">env := tools.GqlDi(ctx)
        users, err := env.UserService().FindAllUsers()

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">result := make([]*model.User, len(users))
        for i := range users </span><span class="cov0" title="0">{
                result[i] = ToUser(users[i])
        }</span>

        <span class="cov0" title="0">return result, nil</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package resolvers

import (
        "context"

        "github.com/nmarsollier/authgo/internal/graph/model"
        "github.com/nmarsollier/authgo/internal/graph/tools"
)

func FindUserByID(ctx context.Context, id string) (*model.User, error) <span class="cov0" title="0">{
        di := tools.GqlDi(ctx)
        user, err := di.UserService().FindById(id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return ToUser(user), nil</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package resolvers

import (
        "context"

        "github.com/nmarsollier/authgo/internal/graph/tools"
)

func Grant(ctx context.Context, userID string, permissions []string) (bool, error) <span class="cov0" title="0">{
        if err := tools.ValidateAdmin(ctx); err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov0" title="0">di := tools.GqlDi(ctx)

        if err := di.UserService().Grant(userID, permissions); err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov0" title="0">return true, nil</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package resolvers

import (
        "context"

        "github.com/nmarsollier/authgo/internal/graph/tools"
)

func Revoke(ctx context.Context, userID string, permissions []string) (bool, error) <span class="cov0" title="0">{
        if err := tools.ValidateAdmin(ctx); err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov0" title="0">di := tools.GqlDi(ctx)

        if err := di.UserService().Revoke(userID, permissions); err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov0" title="0">return true, nil</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">package resolvers

import (
        "context"

        "github.com/nmarsollier/authgo/internal/graph/model"
        "github.com/nmarsollier/authgo/internal/graph/tools"
        "github.com/nmarsollier/authgo/internal/usecases"
)

// SignIn is the resolver for the signIn field.
func SignIn(ctx context.Context, login string, password string) (*model.Token, error) <span class="cov0" title="0">{
        env := tools.GqlDi(ctx)

        tokenString, err := env.SignInUseCase().SignIn(&amp;usecases.SignInRequest{Login: login, Password: password})
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;model.Token{
                Token: tokenString.Token,
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">package resolvers

import (
        "context"

        "github.com/nmarsollier/authgo/internal/graph/tools"
)

func SignOut(ctx context.Context) (bool, error) <span class="cov0" title="0">{
        tokenString, err := tools.TokenString(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov0" title="0">env := tools.GqlDi(ctx)

        if err := env.InvalidateTokenUseCase().InvalidateToken(tokenString); err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov0" title="0">return true, nil</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">package resolvers

import (
        "context"

        "github.com/nmarsollier/authgo/internal/graph/model"
        "github.com/nmarsollier/authgo/internal/graph/tools"
        "github.com/nmarsollier/authgo/internal/usecases"
)

func SignUp(ctx context.Context, name string, login string, password string) (*model.Token, error) <span class="cov0" title="0">{
        env := tools.GqlDi(ctx)
        token, err := env.SignUpUseCase().SignUp(&amp;usecases.SignUpRequest{
                Name:     name,
                Login:    login,
                Password: password,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;model.Token{
                Token: token.Token,
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">package resolvers

import (
        "github.com/nmarsollier/authgo/internal/graph/model"
        "github.com/nmarsollier/authgo/internal/user"
)

func ToUser(user *user.UserData) (result *model.User) <span class="cov0" title="0">{
        return &amp;model.User{
                ID:          user.Id,
                Name:        user.Name,
                Permissions: user.Permissions,
                Login:       user.Login,
                Enabled:     user.Enabled,
        }
}</span>
</pre>
		
		<pre class="file" id="file26" style="display: none">package schema

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.56

import (
        "context"
        "fmt"

        "github.com/nmarsollier/authgo/internal/graph/model"
)

// FindUserByID is the resolver for the findUserByID field.
func (r *entityResolver) FindUserByID(ctx context.Context, id string) (*model.User, error) <span class="cov0" title="0">{
        panic(fmt.Errorf("not implemented: FindUserByID - findUserByID"))</span>
}

// Entity returns model.EntityResolver implementation.
func (r *Resolver) Entity() model.EntityResolver <span class="cov0" title="0">{ return &amp;entityResolver{r} }</span>

type entityResolver struct{ *Resolver }
</pre>
		
		<pre class="file" id="file27" style="display: none">package schema

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.56

import (
        "context"

        "github.com/nmarsollier/authgo/internal/graph/model"
        "github.com/nmarsollier/authgo/internal/graph/resolvers"
)

// SignIn is the resolver for the signIn field.
func (r *mutationResolver) SignIn(ctx context.Context, login string, password string) (*model.Token, error) <span class="cov0" title="0">{
        return resolvers.SignIn(ctx, login, password)
}</span>

// SignUp is the resolver for the signUp field.
func (r *mutationResolver) SignUp(ctx context.Context, name string, login string, password string) (*model.Token, error) <span class="cov0" title="0">{
        return resolvers.SignUp(ctx, name, login, password)
}</span>

// SignOut is the resolver for the signOut field.
func (r *mutationResolver) SignOut(ctx context.Context) (bool, error) <span class="cov0" title="0">{
        return resolvers.SignOut(ctx)
}</span>

// ChangePassword is the resolver for the changePassword field.
func (r *mutationResolver) ChangePassword(ctx context.Context, oldPassword string, newPassword string) (bool, error) <span class="cov0" title="0">{
        return resolvers.ChangePassword(ctx, oldPassword, newPassword)
}</span>

// Enable is the resolver for the enable field.
func (r *mutationResolver) Enable(ctx context.Context, userID string) (bool, error) <span class="cov0" title="0">{
        return resolvers.Enable(ctx, userID)
}</span>

// Disable is the resolver for the disable field.
func (r *mutationResolver) Disable(ctx context.Context, userID string) (bool, error) <span class="cov0" title="0">{
        return resolvers.Disable(ctx, userID)
}</span>

// Grant is the resolver for the grant field.
func (r *mutationResolver) Grant(ctx context.Context, userID string, permissions []string) (bool, error) <span class="cov0" title="0">{
        return resolvers.Grant(ctx, userID, permissions)
}</span>

// Revoke is the resolver for the revoke field.
func (r *mutationResolver) Revoke(ctx context.Context, userID string, permissions []string) (bool, error) <span class="cov0" title="0">{
        return resolvers.Revoke(ctx, userID, permissions)
}</span>

// CurrentUser is the resolver for the currentUser field.
func (r *queryResolver) CurrentUser(ctx context.Context) (*model.User, error) <span class="cov0" title="0">{
        return resolvers.CurrentUser(ctx)
}</span>

// Users is the resolver for the users field.
func (r *queryResolver) Users(ctx context.Context) ([]*model.User, error) <span class="cov0" title="0">{
        return resolvers.FindAllUsers(ctx)
}</span>

// Mutation returns model.MutationResolver implementation.
func (r *Resolver) Mutation() model.MutationResolver <span class="cov0" title="0">{ return &amp;mutationResolver{r} }</span>

// Query returns model.QueryResolver implementation.
func (r *Resolver) Query() model.QueryResolver <span class="cov0" title="0">{ return &amp;queryResolver{r} }</span>

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
</pre>
		
		<pre class="file" id="file28" style="display: none">package graph

import (
        "fmt"
        "net/http"

        "github.com/99designs/gqlgen/graphql/handler"
        "github.com/99designs/gqlgen/graphql/playground"
        "github.com/nmarsollier/authgo/internal/engine/env"
        "github.com/nmarsollier/authgo/internal/engine/log"
        "github.com/nmarsollier/authgo/internal/graph/model"
        "github.com/nmarsollier/authgo/internal/graph/schema"
)

func Start() <span class="cov0" title="0">{
        logger := log.Get(env.Get().FluentUrl)
        port := env.Get().GqlPort
        srv := handler.NewDefaultServer(model.NewExecutableSchema(model.Config{Resolvers: &amp;schema.Resolver{}}))

        http.Handle("/", playground.Handler("GraphQL playground", "/query"))
        http.Handle("/query", srv)

        logger.Info("GraphQL playground in port : ", port)
        logger.Error(http.ListenAndServe(fmt.Sprintf(":%d", env.Get().GqlPort), nil))
}</span>
</pre>
		
		<pre class="file" id="file29" style="display: none">package tools

import (
        "context"
        "strings"

        "github.com/99designs/gqlgen/graphql"
        "github.com/nmarsollier/authgo/internal/engine/errs"
        "github.com/nmarsollier/authgo/internal/token"
)

func ValidateLoggedIn(ctx context.Context) error <span class="cov0" title="0">{
        _, err := HeaderToken(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func ValidateAdmin(ctx context.Context) error <span class="cov0" title="0">{
        token, err := HeaderToken(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">di := GqlDi(ctx)
        if !di.UserService().Granted(token.UserID.Hex(), "admin") </span><span class="cov0" title="0">{
                di.Logger().Warn("Unauthorized")
                return errs.Unauthorized
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// HeaderToken Token data from Authorization header
func HeaderToken(ctx context.Context) (*token.Token, error) <span class="cov0" title="0">{
        di := GqlDi(ctx)

        tokenString, err := TokenString(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs.Unauthorized
        }</span>

        <span class="cov0" title="0">payload, err := di.TokenService().Validate(tokenString)
        if err != nil </span><span class="cov0" title="0">{
                di.Logger().Error(err)
                return nil, err
        }</span>

        <span class="cov0" title="0">return payload, nil</span>
}

// HeaderToken Token data from Authorization header
func TokenString(ctx context.Context) (string, error) <span class="cov0" title="0">{
        operationContext := graphql.GetOperationContext(ctx)
        tokenString := operationContext.Headers.Get("Authorization")

        if strings.Index(strings.ToUpper(tokenString), "BEARER ") == 0 </span><span class="cov0" title="0">{
                tokenString = tokenString[7:]
        }</span> else<span class="cov0" title="0"> {
                return "", errs.Unauthorized
        }</span>

        <span class="cov0" title="0">return tokenString, nil</span>
}
</pre>
		
		<pre class="file" id="file30" style="display: none">package tools

import (
        "context"

        "github.com/99designs/gqlgen/graphql"
        "github.com/nmarsollier/authgo/internal/engine/di"
)

func GqlDi(c context.Context) di.Injector <span class="cov0" title="0">{
        operationContext := graphql.GetOperationContext(c)
        context_deps, exist := operationContext.Variables["di"]
        if exist </span><span class="cov0" title="0">{
                return context_deps.(di.Injector)
        }</span>

        <span class="cov0" title="0">deps := di.NewInjector(newLogger(c))
        operationContext.Variables["di"] = deps
        return deps</span>
}
</pre>
		
		<pre class="file" id="file31" style="display: none">package tools

import (
        "context"

        "github.com/99designs/gqlgen/graphql"
        "github.com/nmarsollier/authgo/internal/engine/env"
        "github.com/nmarsollier/authgo/internal/engine/log"
        uuid "github.com/satori/go.uuid"
)

func newLogger(ctx context.Context) log.LogRusEntry <span class="cov0" title="0">{
        operationContext := graphql.GetOperationContext(ctx)

        return log.Get(env.Get().FluentUrl).
                WithField(log.LOG_FIELD_CORRELATION_ID, getCorrelationId(ctx)).
                WithField(log.LOG_FIELD_CONTROLLER, "GraphQL").
                WithField(log.LOG_FIELD_HTTP_METHOD, operationContext.OperationName).
                WithField(log.LOG_FIELD_HTTP_PATH, operationContext.OperationName)
}</span>

func getCorrelationId(ctx context.Context) string <span class="cov0" title="0">{
        operationContext := graphql.GetOperationContext(ctx)
        value := operationContext.Headers.Get("Authorization")

        if len(value) == 0 </span><span class="cov0" title="0">{
                value = uuid.NewV4().String()
        }</span>

        <span class="cov0" title="0">return value</span>
}
</pre>
		
		<pre class="file" id="file32" style="display: none">package rabbit

import (
        "encoding/json"

        "github.com/nmarsollier/authgo/internal/engine/log"
        "github.com/nmarsollier/authgo/internal/engine/rbt"
)

type SendLogoutService interface {
        SendLogout(token string) error
}

type sendLogoutService struct {
        channel rbt.RabbitChannel
        log     log.LogRusEntry
}

func NewSendLogoutService(
        log log.LogRusEntry,
        channel rbt.RabbitChannel,
) (SendLogoutService, error) <span class="cov8" title="1">{
        return &amp;sendLogoutService{
                channel: channel,
                log:     log,
        }, nil
}</span>

//        @Summary                Mensage Rabbit
//        @Description        SendLogout envía un broadcast a rabbit con logout. Esto no es Rest es RabbitMQ.
//        @Tags                        Rabbit
//        @Accept                        json
//        @Produce                json
//        @Param                        body        body        message        true        "Token deshabilitado"
//        @Router                        /rabbit/logout [put]
//
// SendLogout envía un broadcast a rabbit con logout
func (s *sendLogoutService) SendLogout(token string) error <span class="cov8" title="1">{
        logger := s.log.
                WithField(log.LOG_FIELD_CONTROLLER, "Rabbit").
                WithField(log.LOG_FIELD_RABBIT_ACTION, "Emit").
                WithField(log.LOG_FIELD_RABBIT_EXCHANGE, "auth").
                WithField(log.LOG_FIELD_RABBIT_QUEUE, "logout")

        corrId, _ := logger.Data()[log.LOG_FIELD_CORRELATION_ID].(string)
        send := message{
                CorrelationId: corrId,
                Message:       token,
        }

        err := s.channel.ExchangeDeclare(
                "auth",   // name
                "fanout", // type
        )
        if err != nil </span><span class="cov0" title="0">{
                logger.Error(err)
                return err
        }</span>

        <span class="cov8" title="1">body, err := json.Marshal(send)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error(err)
                return err
        }</span>

        <span class="cov8" title="1">err = s.channel.Publish(
                "auth", // exchange
                "",     // routing key
                body)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error(err)
                return err
        }</span>

        <span class="cov8" title="1">logger.Info("Rabbit logout enviado", string(body))
        return nil</span>
}

type message struct {
        CorrelationId string `json:"correlation_id" example:"123123" `
        Message       string `json:"message" example:"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ0b2tlbklEIjoiNjZiNjBlYzhlMGYzYzY4OTUzMzJlOWNmIiwidXNlcklEIjoiNjZhZmQ3ZWU4YTBhYjRjZjQ0YTQ3NDcyIn0.who7upBctOpmlVmTvOgH1qFKOHKXmuQCkEjMV3qeySg" `
}
</pre>
		
		<pre class="file" id="file33" style="display: none">package rest

import (
        "github.com/gin-gonic/gin"
        "github.com/nmarsollier/authgo/internal/rest/server"
)

// @Summary                Logout
// @Description        Desloguea un usuario en el sistema, invalida el token.
// @Tags                        Seguridad
// @Accept                        json
// @Produce                json
// @Param                        Authorization        header        string        true        "Bearer {token}"
// @Success                200                                "No Content"
// @Failure                500                                {object}        server.ErrorData        "Error response"
// @Router                        /users/signout [get]
//
// Desloguea un usuario en el sistema, invalida el token.
func getUserSignOutRoute(engine *gin.Engine) <span class="cov8" title="1">{
        engine.GET(
                "/users/signout",
                server.IsAuthenticatedMiddleware,
                signOut,
        )
}</span>

func signOut(c *gin.Context) <span class="cov8" title="1">{
        tokenString, _ := server.HeaderAuthorization(c)
        di := server.GinDi(c)

        if err := di.InvalidateTokenUseCase().InvalidateToken(tokenString); err != nil </span><span class="cov8" title="1">{
                server.AbortWithError(c, err)
                return
        }</span>

        <span class="cov8" title="1">c.Done()</span>
}
</pre>
		
		<pre class="file" id="file34" style="display: none">package rest

import (
        "github.com/gin-gonic/gin"
        "github.com/nmarsollier/authgo/internal/rest/server"
)

//        @Summary                Listar Usuarios
//        @Description        Obtiene información de todos los usuarios. El usuario logueado debe tener permisos "admin".
//        @Tags                        Seguridad
//        @Accept                        json
//        @Produce                json
//        @Param                        Authorization        header                string                                true        "Bearer {token}"
//        @Success                200                                {array}                user.UserData                "Users"
//        @Failure                400                                {object}        errs.ValidationErr        "Bad Request"
//        @Failure                401                                {object}        server.ErrorData        "Unauthorized"
//        @Failure                404                                {object}        server.ErrorData        "Not Found"
//        @Failure                500                                {object}        server.ErrorData        "Internal Server Error"
//        @Router                        /users/all [get]
//
// Obtiene información de todos los usuarios.
func getUsersRoute(engine *gin.Engine) <span class="cov8" title="1">{
        engine.GET(
                "/users/all",
                server.IsAdminMiddleware,
                users,
        )
}</span>

func users(c *gin.Context) <span class="cov0" title="0">{
        di := server.GinDi(c)
        result, err := di.UserService().FindAllUsers()

        if err != nil </span><span class="cov0" title="0">{
                server.AbortWithError(c, err)
                return
        }</span>

        <span class="cov0" title="0">c.JSON(200, result)</span>
}
</pre>
		
		<pre class="file" id="file35" style="display: none">package rest

import (
        "github.com/gin-gonic/gin"
        "github.com/nmarsollier/authgo/internal/rest/server"
)

//        @Summary                Usuario Actual
//        @Description        Obtiene información del usuario actual.
//        @Tags                        Seguridad
//        @Accept                        json
//        @Produce                json
//        @Param                        Authorization        header                string                                true        "Bearer {token}"
//        @Success                200                                {object}        user.UserData                "User data"
//        @Failure                400                                {object}        errs.ValidationErr        "Bad Request"
//        @Failure                401                                {object}        server.ErrorData        "Unauthorized"
//        @Failure                404                                {object}        server.ErrorData        "Not Found"
//        @Failure                500                                {object}        server.ErrorData        "Internal Server Error"
//        @Router                        /users/current [get]
//
// Obtiene información del usuario actual.
func getUsersCurrentRoute(engine *gin.Engine) <span class="cov8" title="1">{
        engine.GET(
                "/users/current",
                server.IsAuthenticatedMiddleware,
                currentUser,
        )
}</span>

func currentUser(c *gin.Context) <span class="cov0" title="0">{
        token := server.HeaderToken(c)

        di := server.GinDi(c)
        user, err := di.UserService().FindById(token.UserID.Hex())
        if err != nil </span><span class="cov0" title="0">{
                server.AbortWithError(c, err)
                return
        }</span>

        <span class="cov0" title="0">c.JSON(200, user)</span>
}
</pre>
		
		<pre class="file" id="file36" style="display: none">package rest

import (
        "github.com/gin-gonic/gin"
        "github.com/nmarsollier/authgo/internal/rest/server"
)

//        @Summary                Deshabilitar Usuario
//        @Description        Deshabilita un usuario en el sistema. El usuario logueado debe tener permisos "admin".
//        @Tags                        Seguridad
//        @Accept                        json
//        @Produce                json
//        @Param                        userId                        path        string        true        "ID del usuario a deshabilitar"
//        @Param                        Authorization        header        string        true        "Bearer {token}"
//        @Success                200                                "No Content"
//        @Failure                400                                {object}        errs.ValidationErr        "Bad Request"
//        @Failure                401                                {object}        server.ErrorData        "Unauthorized"
//        @Failure                404                                {object}        server.ErrorData        "Not Found"
//        @Failure                500                                {object}        server.ErrorData        "Internal Server Error"
//        @Router                        /users/:userId/disable [post]
//
// Deshabilitar Usuario
func postUsersIdDisableRoute(engine *gin.Engine) <span class="cov8" title="1">{
        engine.POST(
                "/users/:userID/disable",
                server.IsAdminMiddleware,
                disable,
        )
}</span>

func disable(c *gin.Context) <span class="cov0" title="0">{
        userId := c.Param("userID")

        di := server.GinDi(c)
        if err := di.UserService().Disable(userId); err != nil </span><span class="cov0" title="0">{
                server.AbortWithError(c, err)
        }</span>
}
</pre>
		
		<pre class="file" id="file37" style="display: none">package rest

import (
        "github.com/gin-gonic/gin"
        "github.com/nmarsollier/authgo/internal/rest/server"
)

//        @Summary                Enable User
//        @Description        Habilita un usuario en el sistema. El usuario logueado debe tener permisos "admin".
//        @Tags                        Seguridad
//        @Accept                        json
//        @Produce                json
//        @Param                        userId                        path        string        true        "ID del usuario a habilitar"
//        @Param                        Authorization        header        string        true        "Bearer {token}"
//        @Success                200                                "No Content"
//        @Failure                400                                {object}        errs.ValidationErr        "Bad Request"
//        @Failure                401                                {object}        server.ErrorData        "Unauthorized"
//        @Failure                404                                {object}        server.ErrorData        "Not Found"
//        @Failure                500                                {object}        server.ErrorData        "Internal Server Error"
//        @Router                        /users/:userId/enable [post]
//
// Habilita un usuario en el sistema.
func postUsersIdEnableRoute(engine *gin.Engine) <span class="cov8" title="1">{
        engine.POST(
                "/users/:userID/enable",
                server.IsAdminMiddleware,
                enable,
        )
}</span>

func enable(c *gin.Context) <span class="cov0" title="0">{
        userId := c.Param("userID")
        di := server.GinDi(c)

        if err := di.UserService().Enable(userId); err != nil </span><span class="cov0" title="0">{
                server.AbortWithError(c, err)
        }</span>
}
</pre>
		
		<pre class="file" id="file38" style="display: none">package rest

import (
        "github.com/gin-gonic/gin"
        "github.com/nmarsollier/authgo/internal/rest/server"
)

//        @Summary                Haiblitar permisos
//        @Description        Otorga permisos al usuario indicado, el usuario logueado tiene que tener permiso "admin".
//        @Tags                        Seguridad
//        @Accept                        json
//        @Produce                json
//        @Param                        userId                        path        string                                true        "ID del usuario a habilitar permiso"
//        @Param                        Authorization        header        string                                true        "Bearer {token}"
//        @Param                        body                        body        grantPermissionBody        true        "Permisos a Habilitar"
//        @Success                200                                "No Content"
//        @Failure                400                                {object}        errs.ValidationErr        "Bad Request"
//        @Failure                401                                {object}        server.ErrorData        "Unauthorized"
//        @Failure                404                                {object}        server.ErrorData        "Not Found"
//        @Failure                500                                {object}        server.ErrorData        "Internal Server Error"
//        @Router                        /users/:userID/grant [post]
//
// Otorga permisos al usuario indicado.
func postUsersIdGrantRoute(engine *gin.Engine) <span class="cov8" title="1">{
        engine.POST(
                "/users/:userID/grant",
                server.IsAdminMiddleware,
                grantPermission,
        )
}</span>

type grantPermissionBody struct {
        Permissions []string `json:"permissions" binding:"required"`
}

func grantPermission(c *gin.Context) <span class="cov0" title="0">{
        body := grantPermissionBody{}
        if err := c.ShouldBindJSON(&amp;body); err != nil </span><span class="cov0" title="0">{
                server.AbortWithError(c, err)
                return
        }</span>
        <span class="cov0" title="0">userId := c.Param("userID")

        di := server.GinDi(c)
        if err := di.UserService().Grant(userId, body.Permissions); err != nil </span><span class="cov0" title="0">{
                server.AbortWithError(c, err)
                return
        }</span>
}
</pre>
		
		<pre class="file" id="file39" style="display: none">package rest

import (
        "github.com/gin-gonic/gin"
        "github.com/nmarsollier/authgo/internal/rest/server"
)

//        @Summary                Quitar permisos
//        @Description        Quita permisos al usuario indicado, el usuario logueado tiene que tener permiso "admin".
//        @Tags                        Seguridad
//        @Accept                        json
//        @Produce                json
//        @Param                        userId                        path        string                                true        "ID del usuario a quitar permiso"
//        @Param                        Authorization        header        string                                true        "Bearer {token}"
//        @Param                        body                        body        grantPermissionBody        true        "Permisos a Qutiar"
//        @Success                200                                "No Content"
//        @Failure                400                                {object}        errs.ValidationErr        "Bad Request"
//        @Failure                401                                {object}        server.ErrorData        "Unauthorized"
//        @Failure                404                                {object}        server.ErrorData        "Not Found"
//        @Failure                500                                {object}        server.ErrorData        "Internal Server Error"
//        @Router                        /users/:userID/revoke [post]
//
// Quita permisos al usuario indicado.
func postUsersIdRevokeRoute(engine *gin.Engine) <span class="cov8" title="1">{
        engine.POST(
                "/users/:userID/revoke",
                server.IsAdminMiddleware,
                revokePermission,
        )
}</span>

type revokePermissionBody struct {
        Permissions []string `json:"permissions" binding:"required"`
}

func revokePermission(c *gin.Context) <span class="cov0" title="0">{
        body := revokePermissionBody{}
        if err := c.ShouldBindJSON(&amp;body); err != nil </span><span class="cov0" title="0">{
                server.AbortWithError(c, err)
                return
        }</span>

        <span class="cov0" title="0">userId := c.Param("userID")

        di := server.GinDi(c)
        if err := di.UserService().Revoke(userId, body.Permissions); err != nil </span><span class="cov0" title="0">{
                server.AbortWithError(c, err)
                return
        }</span>
}
</pre>
		
		<pre class="file" id="file40" style="display: none">package rest

import (
        "github.com/gin-gonic/gin"
        "github.com/nmarsollier/authgo/internal/rest/server"
)

//        @Summary                Cambiar Password
//        @Description        Cambia la contraseña del usuario actual.
//        @Tags                        Seguridad
//        @Accept                        json
//        @Produce                json
//        @Param                        body                        body        changePasswordBody        true        "Passwords"
//        @Param                        Authorization        header        string                                true        "Bearer {token}"
//        @Success                200                                "No Content"
//        @Failure                400                                {object}        errs.ValidationErr        "Bad Request"
//        @Failure                401                                {object}        server.ErrorData        "Unauthorized"
//        @Failure                404                                {object}        server.ErrorData        "Not Found"
//        @Failure                500                                {object}        server.ErrorData        "Internal Server Error"
//        @Router                        /user/password [post]
//
// Cambia la contraseña del usuario actual.
func getUserPasswordRoute(engine *gin.Engine) <span class="cov8" title="1">{
        engine.POST(
                "/users/password",
                server.IsAuthenticatedMiddleware,
                changePassword,
        )
}</span>

type changePasswordBody struct {
        Current string `json:"currentPassword" binding:"required,min=1,max=100"`
        New     string `json:"newPassword" binding:"required,min=1,max=100"`
}

func changePassword(c *gin.Context) <span class="cov0" title="0">{
        body := changePasswordBody{}
        if err := c.ShouldBindJSON(&amp;body); err != nil </span><span class="cov0" title="0">{
                server.AbortWithError(c, err)
                return
        }</span>
        <span class="cov0" title="0">token := server.HeaderToken(c)

        di := server.GinDi(c)
        if err := di.UserService().ChangePassword(token.UserID.Hex(), body.Current, body.New); err != nil </span><span class="cov0" title="0">{
                server.AbortWithError(c, err)
                return
        }</span>
}
</pre>
		
		<pre class="file" id="file41" style="display: none">package rest

import (
        "github.com/gin-gonic/gin"
        "github.com/nmarsollier/authgo/internal/rest/server"
        "github.com/nmarsollier/authgo/internal/usecases"
)

//        @Summary                Login
//        @Description        Loguea un usuario en el sistema.
//        @Tags                        Seguridad
//        @Accept                        json
//        @Produce                json
//        @Param                        body        body                usecases.SignInRequest        true        "Sign in information"
//        @Success                200                {object}        usecases.TokenResponse        "User Token"
//        @Failure                400                {object}        errs.ValidationErr                "Bad Request"
//        @Failure                401                {object}        server.ErrorData                "Unauthorized"
//        @Failure                404                {object}        server.ErrorData                "Not Found"
//        @Failure                500                {object}        server.ErrorData                "Internal Server Error"
//        @Router                        /users/signin [post]
//
// Loguea un usuario en el sistema.
func postUserSignInRoute(engine *gin.Engine) <span class="cov8" title="1">{
        engine.POST(
                "/users/signin",
                signIn,
        )
}</span>

func signIn(c *gin.Context) <span class="cov0" title="0">{
        login := &amp;usecases.SignInRequest{}
        if err := c.ShouldBindJSON(&amp;login); err != nil </span><span class="cov0" title="0">{
                server.AbortWithError(c, err)
                return
        }</span>

        <span class="cov0" title="0">di := server.GinDi(c)
        token, err := di.SignInUseCase().SignIn(login)
        if err != nil </span><span class="cov0" title="0">{
                server.AbortWithError(c, err)
                return
        }</span>

        <span class="cov0" title="0">c.JSON(200, token)</span>
}
</pre>
		
		<pre class="file" id="file42" style="display: none">package rest

import (
        "github.com/gin-gonic/gin"
        "github.com/nmarsollier/authgo/internal/rest/server"
        "github.com/nmarsollier/authgo/internal/usecases"
)

//        @Summary                Registrar Usuario
//        @Description        Registra un nuevo usuario en el sistema.
//        @Tags                        Seguridad
//        @Accept                        json
//        @Produce                json
//        @Param                        body        body                usecases.SignUpRequest        true        "Informacion de ususario"
//        @Success                200                {object}        usecases.TokenResponse        "User Token"
//        @Failure                400                {object}        errs.ValidationErr                "Bad Request"
//        @Failure                401                {object}        server.ErrorData                "Unauthorized"
//        @Failure                404                {object}        server.ErrorData                "Not Found"
//        @Failure                500                {object}        server.ErrorData                "Internal Server Error"
//        @Router                        /users/signup [post]
//
// Registra un nuevo usuario en el sistema.
func postUsersRoute(engine *gin.Engine) <span class="cov8" title="1">{
        engine.POST(
                "/users/signup",
                signUp,
        )
}</span>

func signUp(c *gin.Context) <span class="cov0" title="0">{
        body := usecases.SignUpRequest{}
        if err := c.ShouldBindJSON(&amp;body); err != nil </span><span class="cov0" title="0">{
                server.AbortWithError(c, err)
                return
        }</span>

        <span class="cov0" title="0">di := server.GinDi(c)
        token, err := di.SignUpUseCase().SignUp(&amp;body)
        if err != nil </span><span class="cov0" title="0">{
                server.AbortWithError(c, err)
                return
        }</span>

        <span class="cov0" title="0">c.JSON(200, token)</span>
}
</pre>
		
		<pre class="file" id="file43" style="display: none">package rest

import (
        "fmt"

        "github.com/gin-gonic/gin"
        "github.com/nmarsollier/authgo/internal/engine/env"
        "github.com/nmarsollier/authgo/internal/rest/server"
)

// Start this server
func Start() <span class="cov0" title="0">{
        InitRoutes(server.Router())
        server.Router().Run(fmt.Sprintf(":%d", env.Get().Port))
}</span>

func InitRoutes(engine *gin.Engine) <span class="cov8" title="1">{
        getUserSignOutRoute(engine)
        getUsersCurrentRoute(engine)
        getUsersRoute(engine)
        getUserPasswordRoute(engine)
        postUserSignInRoute(engine)
        postUsersRoute(engine)
        postUsersIdDisableRoute(engine)
        postUsersIdEnableRoute(engine)
        postUsersIdGrantRoute(engine)
        postUsersIdRevokeRoute(engine)
}</span>
</pre>
		
		<pre class="file" id="file44" style="display: none">package server

import (
        "github.com/gin-gonic/gin"
        "github.com/nmarsollier/authgo/internal/engine/errs"
        "github.com/nmarsollier/authgo/internal/engine/log"
)

// Gin middleware to validate user token and Admin Access
func IsAdminMiddleware(c *gin.Context) <span class="cov0" title="0">{
        payload, err := fetchAuthHeader(c)

        if err != nil </span><span class="cov0" title="0">{
                c.Error(errs.Unauthorized)
                c.Abort()
                return
        }</span>

        <span class="cov0" title="0">di := GinDi(c)
        di.Logger().WithField(log.LOG_FIELD_USER_ID, payload.UserID.Hex())

        if !di.UserService().Granted(payload.UserID.Hex(), "admin") </span><span class="cov0" title="0">{
                di.Logger().Warn("Unauthorized")
                c.Error(errs.Unauthorized)
                c.Abort()
        }</span>
}
</pre>
		
		<pre class="file" id="file45" style="display: none">package server

import (
        "github.com/gin-gonic/gin"
        "github.com/nmarsollier/authgo/internal/engine/errs"
        "github.com/nmarsollier/authgo/internal/engine/log"
)

// Gin middleware to validate logged in user token
func IsAuthenticatedMiddleware(c *gin.Context) <span class="cov8" title="1">{
        token, err := fetchAuthHeader(c)
        if err != nil </span><span class="cov8" title="1">{
                c.Error(errs.Unauthorized)
                c.Abort()
                return
        }</span>

        <span class="cov8" title="1">GinDi(c).Logger().WithField(log.LOG_FIELD_USER_ID, token.UserID.Hex())</span>
}
</pre>
		
		<pre class="file" id="file46" style="display: none">package server

import (
        "github.com/gin-gonic/gin"
        "github.com/nmarsollier/authgo/internal/engine/di"
        "github.com/nmarsollier/authgo/internal/engine/env"
        "github.com/nmarsollier/authgo/internal/engine/log"
        uuid "github.com/satori/go.uuid"
)

func DiInjectorMiddleware() gin.HandlerFunc <span class="cov8" title="1">{
        return func(c *gin.Context) </span><span class="cov8" title="1">{
                var deps di.Injector
                dep_param, exists := c.Get("di")

                if !exists </span><span class="cov0" title="0">{
                        logger := ginLogger(c)
                        deps = di.NewInjector(logger)
                        c.Set("di", deps)
                }</span> else<span class="cov8" title="1"> {
                        deps = dep_param.(di.Injector)
                }</span>

                <span class="cov8" title="1">c.Next()

                if c.Request.Method != "OPTIONS" </span><span class="cov8" title="1">{
                        deps.Logger().WithField(log.LOG_FIELD_HTTP_STATUS, c.Writer.Status()).Info("Completed")
                }</span>
        }
}

func GinDi(c *gin.Context) di.Injector <span class="cov8" title="1">{
        return c.MustGet("di").(di.Injector)
}</span>

func ginLogger(c *gin.Context) log.LogRusEntry <span class="cov0" title="0">{
        return log.Get(env.Get().FluentUrl).
                WithField(log.LOG_FIELD_CORRELATION_ID, getCorrelationId(c)).
                WithField(log.LOG_FIELD_CONTROLLER, "Rest").
                WithField(log.LOG_FIELD_HTTP_METHOD, c.Request.Method).
                WithField(log.LOG_FIELD_HTTP_PATH, c.Request.URL.Path)
}</span>

func getCorrelationId(c *gin.Context) string <span class="cov0" title="0">{
        value := c.GetHeader(log.LOG_FIELD_CORRELATION_ID)

        if len(value) == 0 </span><span class="cov0" title="0">{
                value = uuid.NewV4().String()
        }</span>

        <span class="cov0" title="0">return value</span>
}
</pre>
		
		<pre class="file" id="file47" style="display: none">package server

import (
        "time"

        "github.com/gin-contrib/gzip"
        "github.com/gin-gonic/gin"
        cors "github.com/itsjamie/gin-cors"
        _ "github.com/nmarsollier/authgo/docs"
        swaggerFiles "github.com/swaggo/files"
        ginSwagger "github.com/swaggo/gin-swagger"
)

var engine *gin.Engine = nil

func Router() *gin.Engine <span class="cov0" title="0">{
        if engine == nil </span><span class="cov0" title="0">{
                engine = gin.Default()

                engine.Use(gzip.Gzip(gzip.DefaultCompression))
                engine.Use(DiInjectorMiddleware())

                engine.Use(cors.Middleware(cors.Config{
                        Origins:         "*",
                        Methods:         "GET, PUT, POST, DELETE",
                        RequestHeaders:  "Origin, Authorization, Content-Type",
                        ExposedHeaders:  "",
                        MaxAge:          50 * time.Second,
                        Credentials:     false,
                        ValidateHeaders: false,
                }))

                engine.Use(ErrorHandler)

                engine.GET("/docs/*any", ginSwagger.WrapHandler(swaggerFiles.Handler))
        }</span>

        <span class="cov0" title="0">return engine</span>
}

func AbortWithError(c *gin.Context, err error) <span class="cov8" title="1">{
        c.Error(err)
        c.Abort()
}</span>
</pre>
		
		<pre class="file" id="file48" style="display: none">package server

import (
        "errors"
        "strings"

        "github.com/gin-gonic/gin"
        "github.com/go-playground/validator/v10"
        "github.com/nmarsollier/authgo/internal/engine/db"
        "github.com/nmarsollier/authgo/internal/engine/di"
        "github.com/nmarsollier/authgo/internal/engine/errs"
        "go.mongodb.org/mongo-driver/mongo"
        "go.mongodb.org/mongo-driver/x/mongo/driver/topology"
)

func ErrorHandler(c *gin.Context) <span class="cov8" title="1">{
        c.Next()
        handleErrorIfNeeded(c)
}</span>

func handleErrorIfNeeded(c *gin.Context) <span class="cov8" title="1">{
        err := c.Errors.Last()
        if err == nil </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">if errors.Is(err, mongo.ErrNoDocuments) </span><span class="cov0" title="0">{
                setError(c, errs.NotFound)
                return
        }</span>

        <span class="cov8" title="1">if errors.Is(err, topology.ErrServerSelectionTimeout) || errors.Is(err, topology.ErrTopologyClosed) </span><span class="cov0" title="0">{
                di.IsDbTimeoutError(err)
                setError(c, errs.Internal)
                return
        }</span>

        <span class="cov8" title="1">switch value := err.Err.(type) </span>{
        case errs.RestError:<span class="cov8" title="1">
                setError(c, value)</span>
        case errs.Validation:<span class="cov0" title="0">
                c.JSON(400, err)</span>
        case validator.ValidationErrors:<span class="cov0" title="0">
                handleValidationError(c, value)</span>
        case mongo.WriteException:<span class="cov0" title="0">
                if db.IsDbUniqueKeyError(value) </span><span class="cov0" title="0">{
                        setError(c, errs.AlreadyExist)
                }</span> else<span class="cov0" title="0"> {
                        setError(c, errs.Internal)
                }</span>
        case error:<span class="cov0" title="0">
                c.JSON(500, ErrorData{
                        Error: value.Error(),
                })</span>
        default:<span class="cov0" title="0">
                setError(c, errs.Internal)</span>
        }
}

func handleValidationError(c *gin.Context, validationErrors validator.ValidationErrors) <span class="cov0" title="0">{
        err := errs.NewValidation()

        for _, e := range validationErrors </span><span class="cov0" title="0">{
                err.Add(strings.ToLower(e.Field()), e.Tag())
        }</span>

        <span class="cov0" title="0">c.JSON(400, err)</span>
}

func setError(c *gin.Context, err errs.RestError) <span class="cov8" title="1">{
        c.JSON(err.Status(), err)
}</span>

type ErrorData struct {
        Error string `json:"error"`
}
</pre>
		
		<pre class="file" id="file49" style="display: none">package server

import (
        "strings"

        "github.com/gin-gonic/gin"
        "github.com/nmarsollier/authgo/internal/engine/errs"
        "github.com/nmarsollier/authgo/internal/token"
)

// HeaderAuthorization token string from Authorization header
func HeaderAuthorization(c *gin.Context) (string, error) <span class="cov8" title="1">{
        tokenString := c.GetHeader("Authorization")

        if strings.Index(strings.ToUpper(tokenString), "BEARER ") == 0 </span><span class="cov8" title="1">{
                return tokenString[7:], nil
        }</span>

        <span class="cov0" title="0">return "", errs.Unauthorized</span>
}

// HeaderToken Token data from Authorization header
func HeaderToken(c *gin.Context) *token.Token <span class="cov0" title="0">{
        return c.MustGet("auth_header").(*token.Token)
}</span>

func fetchAuthHeader(c *gin.Context) (*token.Token, error) <span class="cov8" title="1">{
        di := GinDi(c)
        tokenString, err := HeaderAuthorization(c)
        if err != nil </span><span class="cov0" title="0">{
                di.Logger().Error(err)
                return nil, err
        }</span>

        <span class="cov8" title="1">payload, err := di.TokenService().Validate(tokenString)
        if err != nil </span><span class="cov8" title="1">{
                di.Logger().Error(err)
                return nil, err
        }</span>

        <span class="cov8" title="1">c.Set("auth_header", payload)

        return payload, nil</span>
}
</pre>
		
		<pre class="file" id="file50" style="display: none">package token

import (
        "time"

        "github.com/nmarsollier/authgo/internal/engine/errs"
        gocache "github.com/patrickmn/go-cache"
)

type TokenCache interface {
        Add(token *Token) error
        Get(tokenString string) (*Token, error)
        Remove(token string)
}

func NewTokenCache() TokenCache <span class="cov8" title="1">{
        cache := gocache.New(60*time.Minute, 10*time.Minute)

        return &amp;tokenCache{
                cache: cache,
        }
}</span>

type tokenCache struct {
        cache *gocache.Cache
}

// Add genera un nuevo token al cache
func (c *tokenCache) Add(token *Token) error <span class="cov0" title="0">{
        tokenString, err := Encode(token)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">c.cache.Set(tokenString, token, gocache.DefaultExpiration)
        return nil</span>
}

func (c *tokenCache) Get(tokenString string) (*Token, error) <span class="cov8" title="1">{
        // Si esta en cache, retornamos el cache
        if found, ok := c.cache.Get(tokenString); ok </span><span class="cov0" title="0">{
                if token, ok := found.(*Token); ok </span><span class="cov0" title="0">{
                        return token, nil
                }</span>
        }

        <span class="cov8" title="1">return nil, errs.NotFound</span>
}

// Remove elimia un token del cache
func (c *tokenCache) Remove(tokenString string) <span class="cov8" title="1">{
        c.cache.Delete(tokenString)
}</span>
</pre>
		
		<pre class="file" id="file51" style="display: none">package token

import (
        "context"

        "github.com/nmarsollier/authgo/internal/engine/db"
        "github.com/nmarsollier/authgo/internal/engine/errs"
        "github.com/nmarsollier/authgo/internal/engine/log"
        "go.mongodb.org/mongo-driver/bson/primitive"
)

type TokenRepository interface {
        Insert(userID primitive.ObjectID) (*Token, error)
        FindByID(tokenID string) (*Token, error)
        Delete(tokenID primitive.ObjectID) error
}

func NewTokenRepository(
        log log.LogRusEntry,
        collection db.Collection,
) (TokenRepository, error) <span class="cov8" title="1">{
        return &amp;tokenRepository{
                log:        log,
                collection: collection,
        }, nil
}</span>

type tokenRepository struct {
        log        log.LogRusEntry
        collection db.Collection
}

func (r *tokenRepository) Insert(userID primitive.ObjectID) (*Token, error) <span class="cov0" title="0">{
        token := newToken(userID)

        _, err := r.collection.InsertOne(context.Background(), token)
        if err != nil </span><span class="cov0" title="0">{
                r.log.Error(err)
                return nil, err
        }</span>

        <span class="cov0" title="0">return token, nil</span>
}

func (r *tokenRepository) FindByID(tokenID string) (*Token, error) <span class="cov8" title="1">{
        _id, err := primitive.ObjectIDFromHex(tokenID)
        if err != nil </span><span class="cov0" title="0">{
                r.log.Error(err)
                return nil, errs.Unauthorized
        }</span>

        <span class="cov8" title="1">token := &amp;Token{}
        filter := DbTokenIdFilter{ID: _id}

        if err = r.collection.FindOne(context.Background(), filter, token); err != nil </span><span class="cov8" title="1">{
                r.log.Error(err)
                return nil, err
        }</span>

        <span class="cov8" title="1">return token, nil</span>
}

func (r *tokenRepository) Delete(tokenID primitive.ObjectID) error <span class="cov8" title="1">{
        _, err := r.collection.UpdateOne(context.Background(),
                DbTokenIdFilter{ID: tokenID},
                DbDeleteTokenDocument{Set: DbDeleteTokenBody{Enabled: false}},
        )

        return err
}</span>

type DbDeleteTokenBody struct {
        Enabled bool `bson:"enabled"`
}

type DbDeleteTokenDocument struct {
        Set DbDeleteTokenBody `bson:"$set"`
}

type DbTokenIdFilter struct {
        ID primitive.ObjectID `bson:"_id"`
}
</pre>
		
		<pre class="file" id="file52" style="display: none">package token

import (
        "fmt"

        jwt "github.com/dgrijalva/jwt-go/v4"
        "github.com/nmarsollier/authgo/internal/engine/env"
        "github.com/nmarsollier/authgo/internal/engine/errs"
        "go.mongodb.org/mongo-driver/bson/primitive"
)

type Token struct {
        ID      primitive.ObjectID `bson:"_id"`
        UserID  primitive.ObjectID `bson:"userId"`
        Enabled bool               `bson:"enabled"`
}

func newToken(userID primitive.ObjectID) *Token <span class="cov0" title="0">{
        return &amp;Token{
                ID:      primitive.NewObjectID(),
                UserID:  userID,
                Enabled: true,
        }
}</span>

func Encode(t *Token) (string, error) <span class="cov8" title="1">{
        jwtToken := jwt.NewWithClaims(jwt.SigningMethodHS256, jwt.MapClaims{
                "tokenID": t.ID.Hex(),
                "userID":  t.UserID.Hex(),
        })

        // Sign and get the complete encoded token as a string using the secret
        tokenString, err := jwtToken.SignedString([]byte(env.Get().JWTSecret))
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov8" title="1">return tokenString, nil</span>
}

func ExtractPayload(tokenString string) (string, string, error) <span class="cov8" title="1">{
        token, err := jwt.Parse(tokenString, func(token *jwt.Token) (interface{}, error) </span><span class="cov8" title="1">{
                if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("unexpected signing method: %v", token.Header["alg"])
                }</span>

                <span class="cov8" title="1">return []byte(env.Get().JWTSecret), nil</span>
        })

        <span class="cov8" title="1">if err != nil || !token.Valid </span><span class="cov8" title="1">{
                return "", "", errs.Unauthorized
        }</span>

        <span class="cov8" title="1">claims, ok := token.Claims.(jwt.MapClaims)

        if !ok </span><span class="cov0" title="0">{
                return "", "", errs.Unauthorized
        }</span>

        <span class="cov8" title="1">tokenID := claims["tokenID"].(string)
        userID := claims["userID"].(string)

        return tokenID, userID, nil</span>
}
</pre>
		
		<pre class="file" id="file53" style="display: none">package token

import (
        "github.com/nmarsollier/authgo/internal/engine/errs"
        "github.com/nmarsollier/authgo/internal/engine/log"
        "go.mongodb.org/mongo-driver/bson/primitive"
)

type TokenService interface {
        Create(userID string) (*Token, error)
        Validate(tokenString string) (*Token, error)
        Invalidate(tokenString string) error
        Find(tokenID string) (*Token, error)
}

func NewTokenService(
        log log.LogRusEntry,
        cache TokenCache,
        repository TokenRepository,
) TokenService <span class="cov8" title="1">{
        return &amp;tokenService{
                log:        log,
                cache:      cache,
                repository: repository,
        }
}</span>

type tokenService struct {
        log        log.LogRusEntry
        cache      TokenCache
        repository TokenRepository
}

func (s *tokenService) Create(userID string) (*Token, error) <span class="cov0" title="0">{
        _id, err := primitive.ObjectIDFromHex(userID)
        if err != nil </span><span class="cov0" title="0">{
                s.log.Error(err)
                return nil, errs.Unauthorized
        }</span>

        <span class="cov0" title="0">token, err := s.repository.Insert(_id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">s.cache.Add(token)

        return token, nil</span>
}

func (s *tokenService) Validate(tokenString string) (*Token, error) <span class="cov8" title="1">{
        if token, err := s.cache.Get(tokenString); err == nil </span><span class="cov0" title="0">{
                return token, err
        }</span>

        <span class="cov8" title="1">tokenID, _, err := ExtractPayload(tokenString)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">token, err := s.repository.FindByID(tokenID)
        if err != nil || !token.Enabled </span><span class="cov8" title="1">{
                return nil, errs.Unauthorized
        }</span>

        <span class="cov8" title="1">return token, nil</span>
}

func (s *tokenService) Invalidate(tokenString string) error <span class="cov8" title="1">{
        tokenID, _, err := ExtractPayload(tokenString)
        if err != nil </span><span class="cov0" title="0">{
                return errs.Unauthorized
        }</span>

        <span class="cov8" title="1">_id, err := primitive.ObjectIDFromHex(tokenID)
        if err != nil </span><span class="cov0" title="0">{
                s.log.Error(err)
                return errs.Unauthorized
        }</span>

        <span class="cov8" title="1">if err = s.repository.Delete(_id); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">s.cache.Remove(tokenString)

        return nil</span>
}

// Find busca un token en la db
func (s *tokenService) Find(tokenID string) (*Token, error) <span class="cov0" title="0">{
        token, err := s.repository.FindByID(tokenID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">s.cache.Add(token)

        return token, nil</span>
}
</pre>
		
		<pre class="file" id="file54" style="display: none">package usecases

import (
        "github.com/nmarsollier/authgo/internal/engine/log"
        "github.com/nmarsollier/authgo/internal/rabbit"
        "github.com/nmarsollier/authgo/internal/token"
)

type InvalidateTokenUseCase interface {
        InvalidateToken(token string) error
}

func NewInvalidateTokenUseCase(
        log log.LogRusEntry,
        tokenService token.TokenService,
        sendLogout rabbit.SendLogoutService,
) InvalidateTokenUseCase <span class="cov8" title="1">{
        return &amp;invalidateTokenUseCase{
                log:          log,
                tokenService: tokenService,
                rabbit:       sendLogout,
        }
}</span>

type invalidateTokenUseCase struct {
        log          log.LogRusEntry
        tokenService token.TokenService
        rabbit       rabbit.SendLogoutService
}

func (s *invalidateTokenUseCase) InvalidateToken(token string) error <span class="cov8" title="1">{
        err := s.tokenService.Invalidate(token)

        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">go func() </span><span class="cov8" title="1">{
                if s.rabbit == nil </span><span class="cov0" title="0">{
                        s.log.Info("Rabbit logout no se pudo enviar")
                        return
                }</span>

                <span class="cov8" title="1">if err = s.rabbit.SendLogout("Bearer " + token); err != nil </span><span class="cov0" title="0">{
                        s.log.Info("Rabbit logout no se pudo enviar")
                }</span>
        }()

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file55" style="display: none">package usecases

import (
        "github.com/nmarsollier/authgo/internal/engine/errs"
        "github.com/nmarsollier/authgo/internal/token"
        "github.com/nmarsollier/authgo/internal/user"
)

type SignInUseCase interface {
        SignIn(request *SignInRequest) (*TokenResponse, error)
}

func NewSignInUseCase(userService user.UserService, tokenService token.TokenService) SignInUseCase <span class="cov0" title="0">{
        return &amp;signInUseCase{
                userService:  userService,
                tokenService: tokenService,
        }
}</span>

type signInUseCase struct {
        userService  user.UserService
        tokenService token.TokenService
}

type SignInRequest struct {
        Password string `json:"password" binding:"required"`
        Login    string `json:"login" binding:"required"`
}

func (s *signInUseCase) SignIn(request *SignInRequest) (*TokenResponse, error) <span class="cov0" title="0">{
        user, err := s.userService.SignIn(request.Login, request.Password)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs.Unauthorized
        }</span>

        <span class="cov0" title="0">newToken, err := s.tokenService.Create(user.Id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs.Unauthorized
        }</span>

        <span class="cov0" title="0">tokenString, err := token.Encode(newToken)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs.Unauthorized
        }</span>

        <span class="cov0" title="0">return &amp;TokenResponse{Token: tokenString}, nil</span>
}
</pre>
		
		<pre class="file" id="file56" style="display: none">package usecases

import (
        "github.com/nmarsollier/authgo/internal/engine/errs"
        "github.com/nmarsollier/authgo/internal/token"
        "github.com/nmarsollier/authgo/internal/user"
)

type SignUpUseCase interface {
        SignUp(request *SignUpRequest) (*TokenResponse, error)
}

func NewSignUpUseCase(userService user.UserService, tokenService token.TokenService) SignUpUseCase <span class="cov0" title="0">{
        return &amp;signUpUseCase{
                userService:  userService,
                tokenService: tokenService,
        }
}</span>

type signUpUseCase struct {
        userService  user.UserService
        tokenService token.TokenService
}

type SignUpRequest struct {
        Name     string `json:"name" binding:"required"`
        Password string `json:"password" binding:"required"`
        Login    string `json:"login" binding:"required"`
}

type TokenResponse struct {
        Token string `json:"token"`
}

func (s *signUpUseCase) SignUp(request *SignUpRequest) (*TokenResponse, error) <span class="cov0" title="0">{
        user, err := s.userService.New(request.Login, request.Name, request.Password)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">newToken, err := s.tokenService.Create(user.Id)

        if err != nil </span><span class="cov0" title="0">{
                return nil, errs.Internal
        }</span>

        <span class="cov0" title="0">tokenString, err := token.Encode(newToken)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs.Unauthorized
        }</span>

        <span class="cov0" title="0">return &amp;TokenResponse{Token: tokenString}, nil</span>
}
</pre>
		
		<pre class="file" id="file57" style="display: none">package user

type UserData struct {
        Id          string   `json:"id"`
        Name        string   `json:"name"`
        Permissions []string `json:"permissions"`
        Login       string   `json:"login"`
        Enabled     bool     `json:"enabled"`
}

func (UserData) IsEntity() {<span class="cov0" title="0">}</span>

func NewUserData(user *User) *UserData <span class="cov0" title="0">{
        return &amp;UserData{
                Id:          user.ID.Hex(),
                Name:        user.Name,
                Permissions: user.Permissions,
                Login:       user.Login,
                Enabled:     user.Enabled,
        }
}</span>
</pre>
		
		<pre class="file" id="file58" style="display: none">package user

import (
        "context"
        "time"

        "github.com/nmarsollier/authgo/internal/engine/db"
        "github.com/nmarsollier/authgo/internal/engine/log"
        "go.mongodb.org/mongo-driver/bson"
        "go.mongodb.org/mongo-driver/bson/primitive"
        "go.mongodb.org/mongo-driver/mongo"
)

type UserRepository interface {
        Insert(usr *User) (*User, error)
        Update(usr *User) (*User, error)
        FindAll() ([]*User, error)
        FindByID(userID string) (*User, error)
        FindByLogin(login string) (*User, error)
}

func NewUserRepository(
        log log.LogRusEntry,
        collection db.Collection,
) (UserRepository, error) <span class="cov0" title="0">{
        return &amp;userRepository{
                log:        log,
                collection: collection,
        }, nil
}</span>

type userRepository struct {
        log        log.LogRusEntry
        collection db.Collection
}

func (r *userRepository) Insert(user *User) (*User, error) <span class="cov0" title="0">{
        if err := user.validateSchema(); err != nil </span><span class="cov0" title="0">{
                r.log.Error(err)
                return nil, err
        }</span>

        <span class="cov0" title="0">if _, err := r.collection.InsertOne(context.Background(), user); err != nil </span><span class="cov0" title="0">{
                r.log.Error(err)
                return nil, err
        }</span>

        <span class="cov0" title="0">return user, nil</span>
}

func (r *userRepository) Update(user *User) (*User, error) <span class="cov0" title="0">{
        if err := user.validateSchema(); err != nil </span><span class="cov0" title="0">{
                r.log.Error(err)
                return nil, err
        }</span>

        <span class="cov0" title="0">user.Updated = time.Now()

        _, err := r.collection.UpdateOne(context.Background(),
                DbUserIdFilter{ID: user.ID},
                DbUserUpdateDocument{
                        Set: DbUserUpdateDocumentBody{
                                Password:    user.Password,
                                Name:        user.Name,
                                Enabled:     user.Enabled,
                                Updated:     user.Updated,
                                Permissions: user.Permissions,
                        },
                },
        )

        if err != nil </span><span class="cov0" title="0">{
                r.log.Error(err)
                return nil, err
        }</span>

        <span class="cov0" title="0">return user, nil</span>
}

type DbUserUpdateDocumentBody struct {
        Name        string    `bson:"name" validate:"required,min=1,max=100"`
        Password    string    `bson:"password" validate:"required"`
        Permissions []string  `bson:"permissions"`
        Enabled     bool      `bson:"enabled"`
        Updated     time.Time `bson:"updated"`
}

type DbUserUpdateDocument struct {
        Set DbUserUpdateDocumentBody `bson:"$set"`
}

func (r *userRepository) FindAll() ([]*User, error) <span class="cov0" title="0">{
        filter := bson.D{}
        cur, err := r.collection.Find(context.Background(), filter)
        if err != nil </span><span class="cov0" title="0">{
                r.log.Error(err)
                return nil, err
        }</span>
        <span class="cov0" title="0">defer cur.Close(context.Background())

        users := []*User{}
        for cur.Next(context.Background()) </span><span class="cov0" title="0">{
                user := &amp;User{}
                if err := cur.Decode(user); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">users = append(users, user)</span>
        }

        <span class="cov0" title="0">return users, nil</span>
}

func (r *userRepository) FindByID(userID string) (*User, error) <span class="cov0" title="0">{
        _id, err := primitive.ObjectIDFromHex(userID)
        if err != nil </span><span class="cov0" title="0">{
                r.log.Error(err)
                return nil, ErrID
        }</span>

        <span class="cov0" title="0">user := &amp;User{}
        filter := DbUserIdFilter{ID: _id}
        if err = r.collection.FindOne(context.Background(), filter, user); err != nil </span><span class="cov0" title="0">{
                r.log.Error(err)
                return nil, err
        }</span>

        <span class="cov0" title="0">return user, nil</span>
}

type DbUserIdFilter struct {
        ID primitive.ObjectID `bson:"_id"`
}

func (r *userRepository) FindByLogin(login string) (*User, error) <span class="cov0" title="0">{
        user := &amp;User{}
        filter := DbUserLoginFilter{Login: login}
        err := r.collection.FindOne(context.Background(), filter, user)
        if err != nil </span><span class="cov0" title="0">{
                r.log.Error(err)
                if err == mongo.ErrNoDocuments </span><span class="cov0" title="0">{
                        return nil, ErrLogin
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }

        <span class="cov0" title="0">return user, nil</span>
}

type DbUserLoginFilter struct {
        Login string `bson:"login"`
}
</pre>
		
		<pre class="file" id="file59" style="display: none">package user

import (
        "time"

        "github.com/go-playground/validator/v10"
        "go.mongodb.org/mongo-driver/bson/primitive"
        "golang.org/x/crypto/bcrypt"
)

// User data structure
type User struct {
        ID          primitive.ObjectID `bson:"_id"`
        Name        string             `bson:"name" validate:"required,min=1,max=100"`
        Login       string             `bson:"login" validate:"required,min=5,max=100"`
        Password    string             `bson:"password" validate:"required"`
        Permissions []string           `bson:"permissions"`
        Enabled     bool               `bson:"enabled"`
        Created     time.Time          `bson:"created"`
        Updated     time.Time          `bson:"updated"`
}

// NewUser Nueva instancia de usuario
func NewUser() *User <span class="cov0" title="0">{
        return &amp;User{
                ID:          primitive.NewObjectID(),
                Enabled:     true,
                Created:     time.Now(),
                Updated:     time.Now(),
                Permissions: []string{"user"},
        }
}</span>

// setPasswordText Asigna la contraseña en modo texto, la encripta
func (e *User) setPasswordText(pwd string) error <span class="cov0" title="0">{
        hash, err := encryptPassword(pwd)
        if err != nil </span><span class="cov0" title="0">{
                return ErrPassword
        }</span>

        <span class="cov0" title="0">e.Password = hash
        return nil</span>
}

// validatePassword Valida si la contraseña es la correcta
func (e *User) validatePassword(plainPwd string) error <span class="cov0" title="0">{
        if err := bcrypt.CompareHashAndPassword([]byte(e.Password), []byte(plainPwd)); err != nil </span><span class="cov0" title="0">{
                return ErrPassword
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// granted verifica si el usuario tiene el permiso indicado
func (e *User) granted(permission string) bool <span class="cov0" title="0">{
        for _, p := range e.Permissions </span><span class="cov0" title="0">{
                if p == permission </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

// grant le otorga el permiso indicado al usuario
func (e *User) grant(permission string) <span class="cov0" title="0">{
        if !e.granted(permission) </span><span class="cov0" title="0">{
                e.Permissions = append(e.Permissions, permission)
        }</span>
}

// revoke le revoca el permiso indicado al usuario
func (e *User) revoke(permission string) <span class="cov0" title="0">{
        if e.granted(permission) </span><span class="cov0" title="0">{
                var newPermissions []string
                for _, p := range e.Permissions </span><span class="cov0" title="0">{
                        if p != permission </span><span class="cov0" title="0">{
                                newPermissions = append(newPermissions, p)
                        }</span>
                }
                <span class="cov0" title="0">e.Permissions = newPermissions</span>
        }
}

// validateSchema valida la estructura para ser insertada en la db
func (e *User) validateSchema() error <span class="cov0" title="0">{
        return validator.New().Struct(e)
}</span>

func encryptPassword(pwd string) (string, error) <span class="cov0" title="0">{
        hash, err := bcrypt.GenerateFromPassword([]byte(pwd), bcrypt.MinCost)
        if err != nil </span><span class="cov0" title="0">{
                return "", ErrPassword
        }</span>

        <span class="cov0" title="0">return string(hash), nil</span>
}
</pre>
		
		<pre class="file" id="file60" style="display: none">package user

import (
        "github.com/nmarsollier/authgo/internal/engine/errs"
)

type UserService interface {
        ChangePassword(userID string, current string, newPassword string) error
        Disable(userID string) error
        Enable(userID string) error
        FindById(userID string) (*UserData, error)
        FindAllUsers() ([]*UserData, error)
        Grant(userID string, permissions []string) error
        Granted(userID string, permission string) bool
        Revoke(userID string, permissions []string) error
        New(login string, name string, password string) (result *UserData, err error)
        SignIn(login string, password string) (user *UserData, err error)
}

func NewUserService(userRepository UserRepository) UserService <span class="cov0" title="0">{
        return &amp;userService{
                repository: userRepository,
        }
}</span>

type userService struct {
        repository UserRepository
}

func (s *userService) ChangePassword(userID string, current string, newPassword string) error <span class="cov0" title="0">{
        user, err := s.repository.FindByID(userID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err = user.validatePassword(current); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err = user.setPasswordText(newPassword); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">_, err = s.repository.Update(user)

        return err</span>
}

func (s *userService) Disable(userID string) error <span class="cov0" title="0">{
        usr, err := s.repository.FindByID(userID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">usr.Enabled = false

        _, err = s.repository.Update(usr)

        return err</span>
}

func (s *userService) FindAllUsers() (users []*UserData, err error) <span class="cov0" title="0">{
        user, err := s.repository.FindAll()

        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">for i := 0; i &lt; len(user); i = i + 1 </span><span class="cov0" title="0">{
                users = append(users, NewUserData(user[i]))
        }</span>

        <span class="cov0" title="0">return</span>
}

func (s *userService) New(login string, name string, password string) (*UserData, error) <span class="cov0" title="0">{
        newUser := NewUser()
        newUser.Login = login
        newUser.Name = name
        newUser.setPasswordText(password)

        result, err := s.repository.Insert(newUser)
        return NewUserData(result), err
}</span>

func (s *userService) Get(userID string) (*UserData, error) <span class="cov0" title="0">{
        user, err := s.repository.FindByID(userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if !user.Enabled </span><span class="cov0" title="0">{
                return nil, errs.NotFound
        }</span>

        <span class="cov0" title="0">return NewUserData(user), err</span>
}

func (s *userService) Grant(userID string, permissions []string) error <span class="cov0" title="0">{
        user, err := s.repository.FindByID(userID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">for _, value := range permissions </span><span class="cov0" title="0">{
                user.grant(value)
        }</span>
        <span class="cov0" title="0">_, err = s.repository.Update(user)

        return err</span>
}

func (s *userService) Granted(userID string, permission string) bool <span class="cov0" title="0">{
        usr, err := s.repository.FindByID(userID)
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">return usr.granted(permission)</span>
}

func (s *userService) Revoke(userID string, permissions []string) error <span class="cov0" title="0">{
        user, err := s.repository.FindByID(userID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">for _, value := range permissions </span><span class="cov0" title="0">{
                user.revoke(value)
        }</span>
        <span class="cov0" title="0">_, err = s.repository.Update(user)

        return err</span>
}

func (s *userService) SignIn(login string, password string) (*UserData, error) <span class="cov0" title="0">{
        user, err := s.repository.FindByLogin(login)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if !user.Enabled </span><span class="cov0" title="0">{
                return nil, errs.Unauthorized
        }</span>

        <span class="cov0" title="0">if err = user.validatePassword(password); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return NewUserData(user), nil</span>
}

func (s *userService) Enable(userID string) error <span class="cov0" title="0">{
        usr, err := s.repository.FindByID(userID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">usr.Enabled = true
        _, err = s.repository.Update(usr)

        return err</span>
}

func (s *userService) FindById(userID string) (*UserData, error) <span class="cov0" title="0">{
        user, err := s.repository.FindByID(userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return NewUserData(user), err</span>
}
</pre>
		
		<pre class="file" id="file61" style="display: none">package main

import (
        "github.com/nmarsollier/authgo/internal/graph"
        routes "github.com/nmarsollier/authgo/internal/rest"
)

//        @title                        AuthGo
//        @version                1.0
//        @description        Microservicio de Autentificación.

//        @contact.name        Nestor Marsollier
//        @contact.email        nmarsollier@gmail.com

// @host                localhost:3000
// @BasePath        /v1
func main() <span class="cov0" title="0">{
        go graph.Start()

        routes.Start()
}</span>
</pre>
		
		<pre class="file" id="file62" style="display: none">package db

import (
        "github.com/golang/mock/gomock"
        "github.com/nmarsollier/authgo/test/mock"
        "go.mongodb.org/mongo-driver/mongo"
)

// Mock Data
var TestIsUniqueError = mongo.WriteException{
        WriteErrors: []mongo.WriteError{
                {
                        Code: 11000,
                },
        },
}

var TestOtherDbError = mongo.WriteException{
        WriteErrors: []mongo.WriteError{
                {
                        Code: 1,
                },
        },
}

// Espect common functions
func ExpectFindOneError(coll *mock.MockCollection, err error, times int) <span class="cov8" title="1">{
        coll.EXPECT().FindOne(gomock.Any(), gomock.Any(), gomock.Any()).DoAndReturn(
                func(arg1 interface{}, params interface{}, update interface{}) error </span><span class="cov8" title="1">{
                        return err
                }</span>,
        ).Times(times)
}
func ExpectInsertOneError(coll *mock.MockCollection, err error, times int) <span class="cov0" title="0">{
        coll.EXPECT().InsertOne(gomock.Any(), gomock.Any()).Return("", err).Times(times)
}</span>

func ExpectUpdateOneError(coll *mock.MockCollection, err error, times int) <span class="cov8" title="1">{
        coll.EXPECT().UpdateOne(gomock.Any(), gomock.Any(), gomock.Any()).Return(int64(0), err).Times(times)
}</span>

func ExpectInsertOne(coll *mock.MockCollection, times int) <span class="cov0" title="0">{
        coll.EXPECT().InsertOne(gomock.Any(), gomock.Any()).Return("", nil).Times(times)
}</span>
</pre>
		
		<pre class="file" id="file63" style="display: none">package di

import (
        "github.com/golang/mock/gomock"
        "github.com/nmarsollier/authgo/internal/engine/db"
        "github.com/nmarsollier/authgo/internal/engine/di"
        "github.com/nmarsollier/authgo/internal/engine/log"
        "github.com/nmarsollier/authgo/internal/engine/rbt"
        "github.com/nmarsollier/authgo/internal/rabbit"
        "github.com/nmarsollier/authgo/internal/token"
        "github.com/nmarsollier/authgo/internal/usecases"
        "github.com/nmarsollier/authgo/internal/user"
        tlog "github.com/nmarsollier/authgo/test/engine/log"
        "github.com/nmarsollier/authgo/test/mock"
        trabbit "github.com/nmarsollier/authgo/test/rabbit"
        "go.mongodb.org/mongo-driver/mongo"
)

type TestInjector struct {
        di.Deps
}

func NewTestInjector(
        ctrl *gomock.Controller, withFieldCount int, errorCount int, infoCount int, dataCount int, warnCount int, fatalCount int,
) *TestInjector <span class="cov8" title="1">{

        result := &amp;TestInjector{
                Deps: di.Deps{
                        CurrLog: tlog.NewTestLogger(ctrl, withFieldCount, errorCount, infoCount, dataCount, warnCount, fatalCount),
                },
        }

        mongo := mock.NewMockCollection(ctrl)
        result.SetTokenCollection(mongo)
        result.SetUserCollection(mongo)
        result.SetRabbitChannel(trabbit.DefaultMockRabbitChannel(ctrl, 0))
        return result
}</span>

func (t *TestInjector) SetDatabase(database *mongo.Database) <span class="cov0" title="0">{
        t.CurrDatabase = database
}</span>

func (t *TestInjector) SetLogger(log log.LogRusEntry) <span class="cov0" title="0">{
        t.CurrLog = log
}</span>

func (t *TestInjector) SetInvalidateTokenUseCase(useCase usecases.InvalidateTokenUseCase) <span class="cov0" title="0">{
        t.CurrInvalidateTokenUseCase = useCase
}</span>

func (t *TestInjector) SetSendLogoutService(service rabbit.SendLogoutService) <span class="cov0" title="0">{
        t.CurrSendLogoutService = service
}</span>

func (t *TestInjector) SetSignInUseCase(useCase usecases.SignInUseCase) <span class="cov0" title="0">{
        t.CurrSignInUseCase = useCase
}</span>

func (t *TestInjector) SetSignUpUseCase(useCase usecases.SignUpUseCase) <span class="cov0" title="0">{
        t.CurrSignUpUseCase = useCase
}</span>

func (t *TestInjector) SetTokenRepository(repository token.TokenRepository) <span class="cov0" title="0">{
        t.CurrTokenRepository = repository
}</span>

func (t *TestInjector) SetTokenService(service token.TokenService) <span class="cov0" title="0">{
        t.CurrTokenService = service
}</span>

func (t *TestInjector) SetUserRepository(repository user.UserRepository) <span class="cov0" title="0">{
        t.CurrUserRepository = repository
}</span>

func (t *TestInjector) SetUserService(service user.UserService) <span class="cov0" title="0">{
        t.CurrUserService = service
}</span>

func (t *TestInjector) SetRabbitChannel(channel rbt.RabbitChannel) <span class="cov8" title="1">{
        t.CurrRabbitChannel = channel
}</span>

func (t *TestInjector) SetTokenCache(cache token.TokenCache) <span class="cov0" title="0">{
        t.CurrTokenCache = cache
}</span>

func (t *TestInjector) SetTokenCollection(collection db.Collection) <span class="cov8" title="1">{
        t.CurrTokenCollection = collection
}</span>

func (t *TestInjector) SetUserCollection(collection db.Collection) <span class="cov8" title="1">{
        t.CurrUserCollection = collection
}</span>
</pre>
		
		<pre class="file" id="file64" style="display: none">package log

import (
        "github.com/golang/mock/gomock"
        "github.com/nmarsollier/authgo/internal/engine/log"
        "github.com/nmarsollier/authgo/test/mock"
        "github.com/sirupsen/logrus"
)

func NewTestLogger(ctrl *gomock.Controller, withFieldCount int, errorCount int, infoCount int, dataCount int, warnCount int, fatalCount int) log.LogRusEntry <span class="cov8" title="1">{
        logger := mock.NewMockLogRusEntry(ctrl)
        logger.EXPECT().WithField(gomock.Any(), gomock.Any()).Return(logger).Times(withFieldCount)
        logger.EXPECT().Error(gomock.Any()).Return().Times(errorCount)
        logger.EXPECT().Info(gomock.Any()).Return().Times(infoCount)
        logger.EXPECT().Warn(gomock.Any()).Return().Times(warnCount)
        logger.EXPECT().Fatal(gomock.Any()).Return().Times(fatalCount)

        logger.EXPECT().Data().Return(logrus.Fields{
                log.LOG_FIELD_CORRELATION_ID: "correlationId",
        }).Times(dataCount)

        return logger
}</span>
</pre>
		
		<pre class="file" id="file65" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: ./internal/token/cache.go

// Package mock is a generated GoMock package.
package mock

import (
        reflect "reflect"

        gomock "github.com/golang/mock/gomock"
        token "github.com/nmarsollier/authgo/internal/token"
)

// MockTokenCache is a mock of TokenCache interface.
type MockTokenCache struct {
        ctrl     *gomock.Controller
        recorder *MockTokenCacheMockRecorder
}

// MockTokenCacheMockRecorder is the mock recorder for MockTokenCache.
type MockTokenCacheMockRecorder struct {
        mock *MockTokenCache
}

// NewMockTokenCache creates a new mock instance.
func NewMockTokenCache(ctrl *gomock.Controller) *MockTokenCache <span class="cov0" title="0">{
        mock := &amp;MockTokenCache{ctrl: ctrl}
        mock.recorder = &amp;MockTokenCacheMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockTokenCache) EXPECT() *MockTokenCacheMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// Add mocks base method.
func (m *MockTokenCache) Add(token *token.Token) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Add", token)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Add indicates an expected call of Add.
func (mr *MockTokenCacheMockRecorder) Add(token interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Add", reflect.TypeOf((*MockTokenCache)(nil).Add), token)
}</span>

// Get mocks base method.
func (m *MockTokenCache) Get(tokenString string) (*token.Token, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Get", tokenString)
        ret0, _ := ret[0].(*token.Token)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// Get indicates an expected call of Get.
func (mr *MockTokenCacheMockRecorder) Get(tokenString interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Get", reflect.TypeOf((*MockTokenCache)(nil).Get), tokenString)
}</span>

// Remove mocks base method.
func (m *MockTokenCache) Remove(token string) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        m.ctrl.Call(m, "Remove", token)
}</span>

// Remove indicates an expected call of Remove.
func (mr *MockTokenCacheMockRecorder) Remove(token interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Remove", reflect.TypeOf((*MockTokenCache)(nil).Remove), token)
}</span>
</pre>
		
		<pre class="file" id="file66" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: ./internal/engine/di/injector.go

// Package mock is a generated GoMock package.
package mock

import (
        reflect "reflect"

        gomock "github.com/golang/mock/gomock"
        db "github.com/nmarsollier/authgo/internal/engine/db"
        log "github.com/nmarsollier/authgo/internal/engine/log"
        rbt "github.com/nmarsollier/authgo/internal/engine/rbt"
        rabbit "github.com/nmarsollier/authgo/internal/rabbit"
        token "github.com/nmarsollier/authgo/internal/token"
        usecases "github.com/nmarsollier/authgo/internal/usecases"
        user "github.com/nmarsollier/authgo/internal/user"
        mongo "go.mongodb.org/mongo-driver/mongo"
)

// MockInjector is a mock of Injector interface.
type MockInjector struct {
        ctrl     *gomock.Controller
        recorder *MockInjectorMockRecorder
}

// MockInjectorMockRecorder is the mock recorder for MockInjector.
type MockInjectorMockRecorder struct {
        mock *MockInjector
}

// NewMockInjector creates a new mock instance.
func NewMockInjector(ctrl *gomock.Controller) *MockInjector <span class="cov0" title="0">{
        mock := &amp;MockInjector{ctrl: ctrl}
        mock.recorder = &amp;MockInjectorMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockInjector) EXPECT() *MockInjectorMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// Database mocks base method.
func (m *MockInjector) Database() *mongo.Database <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Database")
        ret0, _ := ret[0].(*mongo.Database)
        return ret0
}</span>

// Database indicates an expected call of Database.
func (mr *MockInjectorMockRecorder) Database() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Database", reflect.TypeOf((*MockInjector)(nil).Database))
}</span>

// InvalidateTokenUseCase mocks base method.
func (m *MockInjector) InvalidateTokenUseCase() usecases.InvalidateTokenUseCase <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "InvalidateTokenUseCase")
        ret0, _ := ret[0].(usecases.InvalidateTokenUseCase)
        return ret0
}</span>

// InvalidateTokenUseCase indicates an expected call of InvalidateTokenUseCase.
func (mr *MockInjectorMockRecorder) InvalidateTokenUseCase() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "InvalidateTokenUseCase", reflect.TypeOf((*MockInjector)(nil).InvalidateTokenUseCase))
}</span>

// Logger mocks base method.
func (m *MockInjector) Logger() log.LogRusEntry <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Logger")
        ret0, _ := ret[0].(log.LogRusEntry)
        return ret0
}</span>

// Logger indicates an expected call of Logger.
func (mr *MockInjectorMockRecorder) Logger() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Logger", reflect.TypeOf((*MockInjector)(nil).Logger))
}</span>

// RabbitChannel mocks base method.
func (m *MockInjector) RabbitChannel() rbt.RabbitChannel <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "RabbitChannel")
        ret0, _ := ret[0].(rbt.RabbitChannel)
        return ret0
}</span>

// RabbitChannel indicates an expected call of RabbitChannel.
func (mr *MockInjectorMockRecorder) RabbitChannel() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RabbitChannel", reflect.TypeOf((*MockInjector)(nil).RabbitChannel))
}</span>

// SendLogoutService mocks base method.
func (m *MockInjector) SendLogoutService() rabbit.SendLogoutService <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "SendLogoutService")
        ret0, _ := ret[0].(rabbit.SendLogoutService)
        return ret0
}</span>

// SendLogoutService indicates an expected call of SendLogoutService.
func (mr *MockInjectorMockRecorder) SendLogoutService() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SendLogoutService", reflect.TypeOf((*MockInjector)(nil).SendLogoutService))
}</span>

// SignInUseCase mocks base method.
func (m *MockInjector) SignInUseCase() usecases.SignInUseCase <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "SignInUseCase")
        ret0, _ := ret[0].(usecases.SignInUseCase)
        return ret0
}</span>

// SignInUseCase indicates an expected call of SignInUseCase.
func (mr *MockInjectorMockRecorder) SignInUseCase() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SignInUseCase", reflect.TypeOf((*MockInjector)(nil).SignInUseCase))
}</span>

// SignUpUseCase mocks base method.
func (m *MockInjector) SignUpUseCase() usecases.SignUpUseCase <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "SignUpUseCase")
        ret0, _ := ret[0].(usecases.SignUpUseCase)
        return ret0
}</span>

// SignUpUseCase indicates an expected call of SignUpUseCase.
func (mr *MockInjectorMockRecorder) SignUpUseCase() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SignUpUseCase", reflect.TypeOf((*MockInjector)(nil).SignUpUseCase))
}</span>

// TokenCache mocks base method.
func (m *MockInjector) TokenCache() token.TokenCache <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "TokenCache")
        ret0, _ := ret[0].(token.TokenCache)
        return ret0
}</span>

// TokenCache indicates an expected call of TokenCache.
func (mr *MockInjectorMockRecorder) TokenCache() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "TokenCache", reflect.TypeOf((*MockInjector)(nil).TokenCache))
}</span>

// TokenCollection mocks base method.
func (m *MockInjector) TokenCollection() db.Collection <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "TokenCollection")
        ret0, _ := ret[0].(db.Collection)
        return ret0
}</span>

// TokenCollection indicates an expected call of TokenCollection.
func (mr *MockInjectorMockRecorder) TokenCollection() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "TokenCollection", reflect.TypeOf((*MockInjector)(nil).TokenCollection))
}</span>

// TokenRepository mocks base method.
func (m *MockInjector) TokenRepository() token.TokenRepository <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "TokenRepository")
        ret0, _ := ret[0].(token.TokenRepository)
        return ret0
}</span>

// TokenRepository indicates an expected call of TokenRepository.
func (mr *MockInjectorMockRecorder) TokenRepository() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "TokenRepository", reflect.TypeOf((*MockInjector)(nil).TokenRepository))
}</span>

// TokenService mocks base method.
func (m *MockInjector) TokenService() token.TokenService <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "TokenService")
        ret0, _ := ret[0].(token.TokenService)
        return ret0
}</span>

// TokenService indicates an expected call of TokenService.
func (mr *MockInjectorMockRecorder) TokenService() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "TokenService", reflect.TypeOf((*MockInjector)(nil).TokenService))
}</span>

// UserCollection mocks base method.
func (m *MockInjector) UserCollection() db.Collection <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "UserCollection")
        ret0, _ := ret[0].(db.Collection)
        return ret0
}</span>

// UserCollection indicates an expected call of UserCollection.
func (mr *MockInjectorMockRecorder) UserCollection() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UserCollection", reflect.TypeOf((*MockInjector)(nil).UserCollection))
}</span>

// UserRepository mocks base method.
func (m *MockInjector) UserRepository() user.UserRepository <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "UserRepository")
        ret0, _ := ret[0].(user.UserRepository)
        return ret0
}</span>

// UserRepository indicates an expected call of UserRepository.
func (mr *MockInjectorMockRecorder) UserRepository() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UserRepository", reflect.TypeOf((*MockInjector)(nil).UserRepository))
}</span>

// UserService mocks base method.
func (m *MockInjector) UserService() user.UserService <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "UserService")
        ret0, _ := ret[0].(user.UserService)
        return ret0
}</span>

// UserService indicates an expected call of UserService.
func (mr *MockInjectorMockRecorder) UserService() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UserService", reflect.TypeOf((*MockInjector)(nil).UserService))
}</span>
</pre>
		
		<pre class="file" id="file67" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: ./internal/usecases/invalidate_token.go

// Package mock is a generated GoMock package.
package mock

import (
        reflect "reflect"

        gomock "github.com/golang/mock/gomock"
)

// MockInvalidateTokenUseCase is a mock of InvalidateTokenUseCase interface.
type MockInvalidateTokenUseCase struct {
        ctrl     *gomock.Controller
        recorder *MockInvalidateTokenUseCaseMockRecorder
}

// MockInvalidateTokenUseCaseMockRecorder is the mock recorder for MockInvalidateTokenUseCase.
type MockInvalidateTokenUseCaseMockRecorder struct {
        mock *MockInvalidateTokenUseCase
}

// NewMockInvalidateTokenUseCase creates a new mock instance.
func NewMockInvalidateTokenUseCase(ctrl *gomock.Controller) *MockInvalidateTokenUseCase <span class="cov0" title="0">{
        mock := &amp;MockInvalidateTokenUseCase{ctrl: ctrl}
        mock.recorder = &amp;MockInvalidateTokenUseCaseMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockInvalidateTokenUseCase) EXPECT() *MockInvalidateTokenUseCaseMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// InvalidateToken mocks base method.
func (m *MockInvalidateTokenUseCase) InvalidateToken(token string) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "InvalidateToken", token)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// InvalidateToken indicates an expected call of InvalidateToken.
func (mr *MockInvalidateTokenUseCaseMockRecorder) InvalidateToken(token interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "InvalidateToken", reflect.TypeOf((*MockInvalidateTokenUseCase)(nil).InvalidateToken), token)
}</span>
</pre>
		
		<pre class="file" id="file68" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: ./internal/engine/log/logger.go

// Package mock is a generated GoMock package.
package mock

import (
        reflect "reflect"

        gomock "github.com/golang/mock/gomock"
        log "github.com/nmarsollier/authgo/internal/engine/log"
        logrus "github.com/sirupsen/logrus"
)

// MockLogRusEntry is a mock of LogRusEntry interface.
type MockLogRusEntry struct {
        ctrl     *gomock.Controller
        recorder *MockLogRusEntryMockRecorder
}

// MockLogRusEntryMockRecorder is the mock recorder for MockLogRusEntry.
type MockLogRusEntryMockRecorder struct {
        mock *MockLogRusEntry
}

// NewMockLogRusEntry creates a new mock instance.
func NewMockLogRusEntry(ctrl *gomock.Controller) *MockLogRusEntry <span class="cov8" title="1">{
        mock := &amp;MockLogRusEntry{ctrl: ctrl}
        mock.recorder = &amp;MockLogRusEntryMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockLogRusEntry) EXPECT() *MockLogRusEntryMockRecorder <span class="cov8" title="1">{
        return m.recorder
}</span>

// Data mocks base method.
func (m *MockLogRusEntry) Data() logrus.Fields <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Data")
        ret0, _ := ret[0].(logrus.Fields)
        return ret0
}</span>

// Data indicates an expected call of Data.
func (mr *MockLogRusEntryMockRecorder) Data() *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Data", reflect.TypeOf((*MockLogRusEntry)(nil).Data))
}</span>

// Error mocks base method.
func (m *MockLogRusEntry) Error(args ...interface{}) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        varargs := []interface{}{}
        for _, a := range args </span><span class="cov8" title="1">{
                varargs = append(varargs, a)
        }</span>
        <span class="cov8" title="1">m.ctrl.Call(m, "Error", varargs...)</span>
}

// Error indicates an expected call of Error.
func (mr *MockLogRusEntryMockRecorder) Error(args ...interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Error", reflect.TypeOf((*MockLogRusEntry)(nil).Error), args...)
}</span>

// Fatal mocks base method.
func (m *MockLogRusEntry) Fatal(args ...interface{}) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        varargs := []interface{}{}
        for _, a := range args </span><span class="cov0" title="0">{
                varargs = append(varargs, a)
        }</span>
        <span class="cov0" title="0">m.ctrl.Call(m, "Fatal", varargs...)</span>
}

// Fatal indicates an expected call of Fatal.
func (mr *MockLogRusEntryMockRecorder) Fatal(args ...interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Fatal", reflect.TypeOf((*MockLogRusEntry)(nil).Fatal), args...)
}</span>

// Info mocks base method.
func (m *MockLogRusEntry) Info(args ...interface{}) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        varargs := []interface{}{}
        for _, a := range args </span><span class="cov8" title="1">{
                varargs = append(varargs, a)
        }</span>
        <span class="cov8" title="1">m.ctrl.Call(m, "Info", varargs...)</span>
}

// Info indicates an expected call of Info.
func (mr *MockLogRusEntryMockRecorder) Info(args ...interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Info", reflect.TypeOf((*MockLogRusEntry)(nil).Info), args...)
}</span>

// Warn mocks base method.
func (m *MockLogRusEntry) Warn(args ...interface{}) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        varargs := []interface{}{}
        for _, a := range args </span><span class="cov0" title="0">{
                varargs = append(varargs, a)
        }</span>
        <span class="cov0" title="0">m.ctrl.Call(m, "Warn", varargs...)</span>
}

// Warn indicates an expected call of Warn.
func (mr *MockLogRusEntryMockRecorder) Warn(args ...interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Warn", reflect.TypeOf((*MockLogRusEntry)(nil).Warn), args...)
}</span>

// WithField mocks base method.
func (m *MockLogRusEntry) WithField(key string, value interface{}) log.LogRusEntry <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "WithField", key, value)
        ret0, _ := ret[0].(log.LogRusEntry)
        return ret0
}</span>

// WithField indicates an expected call of WithField.
func (mr *MockLogRusEntryMockRecorder) WithField(key, value interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "WithField", reflect.TypeOf((*MockLogRusEntry)(nil).WithField), key, value)
}</span>
</pre>
		
		<pre class="file" id="file69" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: ./internal/engine/db/collection.go

// Package mock is a generated GoMock package.
package mock

import (
        context "context"
        reflect "reflect"

        gomock "github.com/golang/mock/gomock"
        db "github.com/nmarsollier/authgo/internal/engine/db"
)

// MockCollection is a mock of Collection interface.
type MockCollection struct {
        ctrl     *gomock.Controller
        recorder *MockCollectionMockRecorder
}

// MockCollectionMockRecorder is the mock recorder for MockCollection.
type MockCollectionMockRecorder struct {
        mock *MockCollection
}

// NewMockCollection creates a new mock instance.
func NewMockCollection(ctrl *gomock.Controller) *MockCollection <span class="cov8" title="1">{
        mock := &amp;MockCollection{ctrl: ctrl}
        mock.recorder = &amp;MockCollectionMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockCollection) EXPECT() *MockCollectionMockRecorder <span class="cov8" title="1">{
        return m.recorder
}</span>

// Find mocks base method.
func (m *MockCollection) Find(ctx context.Context, filter interface{}) (db.Cursor, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Find", ctx, filter)
        ret0, _ := ret[0].(db.Cursor)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// Find indicates an expected call of Find.
func (mr *MockCollectionMockRecorder) Find(ctx, filter interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Find", reflect.TypeOf((*MockCollection)(nil).Find), ctx, filter)
}</span>

// FindOne mocks base method.
func (m *MockCollection) FindOne(ctx context.Context, filter, v interface{}) error <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "FindOne", ctx, filter, v)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// FindOne indicates an expected call of FindOne.
func (mr *MockCollectionMockRecorder) FindOne(ctx, filter, v interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FindOne", reflect.TypeOf((*MockCollection)(nil).FindOne), ctx, filter, v)
}</span>

// InsertOne mocks base method.
func (m *MockCollection) InsertOne(ctx context.Context, document interface{}) (interface{}, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "InsertOne", ctx, document)
        ret0, _ := ret[0].(interface{})
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// InsertOne indicates an expected call of InsertOne.
func (mr *MockCollectionMockRecorder) InsertOne(ctx, document interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "InsertOne", reflect.TypeOf((*MockCollection)(nil).InsertOne), ctx, document)
}</span>

// UpdateOne mocks base method.
func (m *MockCollection) UpdateOne(ctx context.Context, filter, update interface{}) (int64, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "UpdateOne", ctx, filter, update)
        ret0, _ := ret[0].(int64)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// UpdateOne indicates an expected call of UpdateOne.
func (mr *MockCollectionMockRecorder) UpdateOne(ctx, filter, update interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateOne", reflect.TypeOf((*MockCollection)(nil).UpdateOne), ctx, filter, update)
}</span>

// MockCursor is a mock of Cursor interface.
type MockCursor struct {
        ctrl     *gomock.Controller
        recorder *MockCursorMockRecorder
}

// MockCursorMockRecorder is the mock recorder for MockCursor.
type MockCursorMockRecorder struct {
        mock *MockCursor
}

// NewMockCursor creates a new mock instance.
func NewMockCursor(ctrl *gomock.Controller) *MockCursor <span class="cov0" title="0">{
        mock := &amp;MockCursor{ctrl: ctrl}
        mock.recorder = &amp;MockCursorMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockCursor) EXPECT() *MockCursorMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// Close mocks base method.
func (m *MockCursor) Close(ctx context.Context) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Close", ctx)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Close indicates an expected call of Close.
func (mr *MockCursorMockRecorder) Close(ctx interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Close", reflect.TypeOf((*MockCursor)(nil).Close), ctx)
}</span>

// Decode mocks base method.
func (m *MockCursor) Decode(val interface{}) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Decode", val)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Decode indicates an expected call of Decode.
func (mr *MockCursorMockRecorder) Decode(val interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Decode", reflect.TypeOf((*MockCursor)(nil).Decode), val)
}</span>

// Next mocks base method.
func (m *MockCursor) Next(ctx context.Context) bool <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Next", ctx)
        ret0, _ := ret[0].(bool)
        return ret0
}</span>

// Next indicates an expected call of Next.
func (mr *MockCursorMockRecorder) Next(ctx interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Next", reflect.TypeOf((*MockCursor)(nil).Next), ctx)
}</span>
</pre>
		
		<pre class="file" id="file70" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: ./internal/engine/rbt/rabbit_channel.go

// Package mock is a generated GoMock package.
package mock

import (
        reflect "reflect"

        gomock "github.com/golang/mock/gomock"
)

// MockRabbitChannel is a mock of RabbitChannel interface.
type MockRabbitChannel struct {
        ctrl     *gomock.Controller
        recorder *MockRabbitChannelMockRecorder
}

// MockRabbitChannelMockRecorder is the mock recorder for MockRabbitChannel.
type MockRabbitChannelMockRecorder struct {
        mock *MockRabbitChannel
}

// NewMockRabbitChannel creates a new mock instance.
func NewMockRabbitChannel(ctrl *gomock.Controller) *MockRabbitChannel <span class="cov8" title="1">{
        mock := &amp;MockRabbitChannel{ctrl: ctrl}
        mock.recorder = &amp;MockRabbitChannelMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockRabbitChannel) EXPECT() *MockRabbitChannelMockRecorder <span class="cov8" title="1">{
        return m.recorder
}</span>

// ExchangeDeclare mocks base method.
func (m *MockRabbitChannel) ExchangeDeclare(name, chType string) error <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "ExchangeDeclare", name, chType)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// ExchangeDeclare indicates an expected call of ExchangeDeclare.
func (mr *MockRabbitChannelMockRecorder) ExchangeDeclare(name, chType interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ExchangeDeclare", reflect.TypeOf((*MockRabbitChannel)(nil).ExchangeDeclare), name, chType)
}</span>

// Publish mocks base method.
func (m *MockRabbitChannel) Publish(exchange, routingKey string, body []byte) error <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Publish", exchange, routingKey, body)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Publish indicates an expected call of Publish.
func (mr *MockRabbitChannelMockRecorder) Publish(exchange, routingKey, body interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Publish", reflect.TypeOf((*MockRabbitChannel)(nil).Publish), exchange, routingKey, body)
}</span>
</pre>
		
		<pre class="file" id="file71" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: ./internal/rabbit/send_logout.go

// Package mock is a generated GoMock package.
package mock

import (
        reflect "reflect"

        gomock "github.com/golang/mock/gomock"
)

// MockSendLogoutService is a mock of SendLogoutService interface.
type MockSendLogoutService struct {
        ctrl     *gomock.Controller
        recorder *MockSendLogoutServiceMockRecorder
}

// MockSendLogoutServiceMockRecorder is the mock recorder for MockSendLogoutService.
type MockSendLogoutServiceMockRecorder struct {
        mock *MockSendLogoutService
}

// NewMockSendLogoutService creates a new mock instance.
func NewMockSendLogoutService(ctrl *gomock.Controller) *MockSendLogoutService <span class="cov0" title="0">{
        mock := &amp;MockSendLogoutService{ctrl: ctrl}
        mock.recorder = &amp;MockSendLogoutServiceMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockSendLogoutService) EXPECT() *MockSendLogoutServiceMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// SendLogout mocks base method.
func (m *MockSendLogoutService) SendLogout(token string) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "SendLogout", token)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// SendLogout indicates an expected call of SendLogout.
func (mr *MockSendLogoutServiceMockRecorder) SendLogout(token interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SendLogout", reflect.TypeOf((*MockSendLogoutService)(nil).SendLogout), token)
}</span>
</pre>
		
		<pre class="file" id="file72" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: ./internal/usecases/sign_in.go

// Package mock is a generated GoMock package.
package mock

import (
        reflect "reflect"

        gomock "github.com/golang/mock/gomock"
        usecases "github.com/nmarsollier/authgo/internal/usecases"
)

// MockSignInUseCase is a mock of SignInUseCase interface.
type MockSignInUseCase struct {
        ctrl     *gomock.Controller
        recorder *MockSignInUseCaseMockRecorder
}

// MockSignInUseCaseMockRecorder is the mock recorder for MockSignInUseCase.
type MockSignInUseCaseMockRecorder struct {
        mock *MockSignInUseCase
}

// NewMockSignInUseCase creates a new mock instance.
func NewMockSignInUseCase(ctrl *gomock.Controller) *MockSignInUseCase <span class="cov0" title="0">{
        mock := &amp;MockSignInUseCase{ctrl: ctrl}
        mock.recorder = &amp;MockSignInUseCaseMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockSignInUseCase) EXPECT() *MockSignInUseCaseMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// SignIn mocks base method.
func (m *MockSignInUseCase) SignIn(request *usecases.SignInRequest) (*usecases.TokenResponse, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "SignIn", request)
        ret0, _ := ret[0].(*usecases.TokenResponse)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// SignIn indicates an expected call of SignIn.
func (mr *MockSignInUseCaseMockRecorder) SignIn(request interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SignIn", reflect.TypeOf((*MockSignInUseCase)(nil).SignIn), request)
}</span>
</pre>
		
		<pre class="file" id="file73" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: ./internal/usecases/sign_up.go

// Package mock is a generated GoMock package.
package mock

import (
        reflect "reflect"

        gomock "github.com/golang/mock/gomock"
        usecases "github.com/nmarsollier/authgo/internal/usecases"
)

// MockSignUpUseCase is a mock of SignUpUseCase interface.
type MockSignUpUseCase struct {
        ctrl     *gomock.Controller
        recorder *MockSignUpUseCaseMockRecorder
}

// MockSignUpUseCaseMockRecorder is the mock recorder for MockSignUpUseCase.
type MockSignUpUseCaseMockRecorder struct {
        mock *MockSignUpUseCase
}

// NewMockSignUpUseCase creates a new mock instance.
func NewMockSignUpUseCase(ctrl *gomock.Controller) *MockSignUpUseCase <span class="cov0" title="0">{
        mock := &amp;MockSignUpUseCase{ctrl: ctrl}
        mock.recorder = &amp;MockSignUpUseCaseMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockSignUpUseCase) EXPECT() *MockSignUpUseCaseMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// SignUp mocks base method.
func (m *MockSignUpUseCase) SignUp(request *usecases.SignUpRequest) (*usecases.TokenResponse, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "SignUp", request)
        ret0, _ := ret[0].(*usecases.TokenResponse)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// SignUp indicates an expected call of SignUp.
func (mr *MockSignUpUseCaseMockRecorder) SignUp(request interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SignUp", reflect.TypeOf((*MockSignUpUseCase)(nil).SignUp), request)
}</span>
</pre>
		
		<pre class="file" id="file74" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: ./internal/token/repository.go

// Package mock is a generated GoMock package.
package mock

import (
        reflect "reflect"

        gomock "github.com/golang/mock/gomock"
        token "github.com/nmarsollier/authgo/internal/token"
        primitive "go.mongodb.org/mongo-driver/bson/primitive"
)

// MockTokenRepository is a mock of TokenRepository interface.
type MockTokenRepository struct {
        ctrl     *gomock.Controller
        recorder *MockTokenRepositoryMockRecorder
}

// MockTokenRepositoryMockRecorder is the mock recorder for MockTokenRepository.
type MockTokenRepositoryMockRecorder struct {
        mock *MockTokenRepository
}

// NewMockTokenRepository creates a new mock instance.
func NewMockTokenRepository(ctrl *gomock.Controller) *MockTokenRepository <span class="cov0" title="0">{
        mock := &amp;MockTokenRepository{ctrl: ctrl}
        mock.recorder = &amp;MockTokenRepositoryMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockTokenRepository) EXPECT() *MockTokenRepositoryMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// Delete mocks base method.
func (m *MockTokenRepository) Delete(tokenID primitive.ObjectID) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Delete", tokenID)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Delete indicates an expected call of Delete.
func (mr *MockTokenRepositoryMockRecorder) Delete(tokenID interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Delete", reflect.TypeOf((*MockTokenRepository)(nil).Delete), tokenID)
}</span>

// FindByID mocks base method.
func (m *MockTokenRepository) FindByID(tokenID string) (*token.Token, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "FindByID", tokenID)
        ret0, _ := ret[0].(*token.Token)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// FindByID indicates an expected call of FindByID.
func (mr *MockTokenRepositoryMockRecorder) FindByID(tokenID interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FindByID", reflect.TypeOf((*MockTokenRepository)(nil).FindByID), tokenID)
}</span>

// Insert mocks base method.
func (m *MockTokenRepository) Insert(userID primitive.ObjectID) (*token.Token, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Insert", userID)
        ret0, _ := ret[0].(*token.Token)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// Insert indicates an expected call of Insert.
func (mr *MockTokenRepositoryMockRecorder) Insert(userID interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Insert", reflect.TypeOf((*MockTokenRepository)(nil).Insert), userID)
}</span>
</pre>
		
		<pre class="file" id="file75" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: ./internal/token/service.go

// Package mock is a generated GoMock package.
package mock

import (
        reflect "reflect"

        gomock "github.com/golang/mock/gomock"
        token "github.com/nmarsollier/authgo/internal/token"
)

// MockTokenService is a mock of TokenService interface.
type MockTokenService struct {
        ctrl     *gomock.Controller
        recorder *MockTokenServiceMockRecorder
}

// MockTokenServiceMockRecorder is the mock recorder for MockTokenService.
type MockTokenServiceMockRecorder struct {
        mock *MockTokenService
}

// NewMockTokenService creates a new mock instance.
func NewMockTokenService(ctrl *gomock.Controller) *MockTokenService <span class="cov0" title="0">{
        mock := &amp;MockTokenService{ctrl: ctrl}
        mock.recorder = &amp;MockTokenServiceMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockTokenService) EXPECT() *MockTokenServiceMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// Create mocks base method.
func (m *MockTokenService) Create(userID string) (*token.Token, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Create", userID)
        ret0, _ := ret[0].(*token.Token)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// Create indicates an expected call of Create.
func (mr *MockTokenServiceMockRecorder) Create(userID interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Create", reflect.TypeOf((*MockTokenService)(nil).Create), userID)
}</span>

// Find mocks base method.
func (m *MockTokenService) Find(tokenID string) (*token.Token, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Find", tokenID)
        ret0, _ := ret[0].(*token.Token)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// Find indicates an expected call of Find.
func (mr *MockTokenServiceMockRecorder) Find(tokenID interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Find", reflect.TypeOf((*MockTokenService)(nil).Find), tokenID)
}</span>

// Invalidate mocks base method.
func (m *MockTokenService) Invalidate(tokenString string) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Invalidate", tokenString)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Invalidate indicates an expected call of Invalidate.
func (mr *MockTokenServiceMockRecorder) Invalidate(tokenString interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Invalidate", reflect.TypeOf((*MockTokenService)(nil).Invalidate), tokenString)
}</span>

// Validate mocks base method.
func (m *MockTokenService) Validate(tokenString string) (*token.Token, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Validate", tokenString)
        ret0, _ := ret[0].(*token.Token)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// Validate indicates an expected call of Validate.
func (mr *MockTokenServiceMockRecorder) Validate(tokenString interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Validate", reflect.TypeOf((*MockTokenService)(nil).Validate), tokenString)
}</span>
</pre>
		
		<pre class="file" id="file76" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: ./internal/user/repository.go

// Package mock is a generated GoMock package.
package mock

import (
        reflect "reflect"

        gomock "github.com/golang/mock/gomock"
        user "github.com/nmarsollier/authgo/internal/user"
)

// MockUserRepository is a mock of UserRepository interface.
type MockUserRepository struct {
        ctrl     *gomock.Controller
        recorder *MockUserRepositoryMockRecorder
}

// MockUserRepositoryMockRecorder is the mock recorder for MockUserRepository.
type MockUserRepositoryMockRecorder struct {
        mock *MockUserRepository
}

// NewMockUserRepository creates a new mock instance.
func NewMockUserRepository(ctrl *gomock.Controller) *MockUserRepository <span class="cov0" title="0">{
        mock := &amp;MockUserRepository{ctrl: ctrl}
        mock.recorder = &amp;MockUserRepositoryMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockUserRepository) EXPECT() *MockUserRepositoryMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// FindAll mocks base method.
func (m *MockUserRepository) FindAll() ([]*user.User, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "FindAll")
        ret0, _ := ret[0].([]*user.User)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// FindAll indicates an expected call of FindAll.
func (mr *MockUserRepositoryMockRecorder) FindAll() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FindAll", reflect.TypeOf((*MockUserRepository)(nil).FindAll))
}</span>

// FindByID mocks base method.
func (m *MockUserRepository) FindByID(userID string) (*user.User, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "FindByID", userID)
        ret0, _ := ret[0].(*user.User)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// FindByID indicates an expected call of FindByID.
func (mr *MockUserRepositoryMockRecorder) FindByID(userID interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FindByID", reflect.TypeOf((*MockUserRepository)(nil).FindByID), userID)
}</span>

// FindByLogin mocks base method.
func (m *MockUserRepository) FindByLogin(login string) (*user.User, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "FindByLogin", login)
        ret0, _ := ret[0].(*user.User)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// FindByLogin indicates an expected call of FindByLogin.
func (mr *MockUserRepositoryMockRecorder) FindByLogin(login interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FindByLogin", reflect.TypeOf((*MockUserRepository)(nil).FindByLogin), login)
}</span>

// Insert mocks base method.
func (m *MockUserRepository) Insert(usr *user.User) (*user.User, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Insert", usr)
        ret0, _ := ret[0].(*user.User)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// Insert indicates an expected call of Insert.
func (mr *MockUserRepositoryMockRecorder) Insert(usr interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Insert", reflect.TypeOf((*MockUserRepository)(nil).Insert), usr)
}</span>

// Update mocks base method.
func (m *MockUserRepository) Update(usr *user.User) (*user.User, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Update", usr)
        ret0, _ := ret[0].(*user.User)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// Update indicates an expected call of Update.
func (mr *MockUserRepositoryMockRecorder) Update(usr interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Update", reflect.TypeOf((*MockUserRepository)(nil).Update), usr)
}</span>
</pre>
		
		<pre class="file" id="file77" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: ./internal/user/service.go

// Package mock is a generated GoMock package.
package mock

import (
        reflect "reflect"

        gomock "github.com/golang/mock/gomock"
        user "github.com/nmarsollier/authgo/internal/user"
)

// MockUserService is a mock of UserService interface.
type MockUserService struct {
        ctrl     *gomock.Controller
        recorder *MockUserServiceMockRecorder
}

// MockUserServiceMockRecorder is the mock recorder for MockUserService.
type MockUserServiceMockRecorder struct {
        mock *MockUserService
}

// NewMockUserService creates a new mock instance.
func NewMockUserService(ctrl *gomock.Controller) *MockUserService <span class="cov0" title="0">{
        mock := &amp;MockUserService{ctrl: ctrl}
        mock.recorder = &amp;MockUserServiceMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockUserService) EXPECT() *MockUserServiceMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// ChangePassword mocks base method.
func (m *MockUserService) ChangePassword(userID, current, newPassword string) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "ChangePassword", userID, current, newPassword)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// ChangePassword indicates an expected call of ChangePassword.
func (mr *MockUserServiceMockRecorder) ChangePassword(userID, current, newPassword interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ChangePassword", reflect.TypeOf((*MockUserService)(nil).ChangePassword), userID, current, newPassword)
}</span>

// Disable mocks base method.
func (m *MockUserService) Disable(userID string) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Disable", userID)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Disable indicates an expected call of Disable.
func (mr *MockUserServiceMockRecorder) Disable(userID interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Disable", reflect.TypeOf((*MockUserService)(nil).Disable), userID)
}</span>

// Enable mocks base method.
func (m *MockUserService) Enable(userID string) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Enable", userID)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Enable indicates an expected call of Enable.
func (mr *MockUserServiceMockRecorder) Enable(userID interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Enable", reflect.TypeOf((*MockUserService)(nil).Enable), userID)
}</span>

// FindAllUsers mocks base method.
func (m *MockUserService) FindAllUsers() ([]*user.UserData, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "FindAllUsers")
        ret0, _ := ret[0].([]*user.UserData)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// FindAllUsers indicates an expected call of FindAllUsers.
func (mr *MockUserServiceMockRecorder) FindAllUsers() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FindAllUsers", reflect.TypeOf((*MockUserService)(nil).FindAllUsers))
}</span>

// FindById mocks base method.
func (m *MockUserService) FindById(userID string) (*user.UserData, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "FindById", userID)
        ret0, _ := ret[0].(*user.UserData)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// FindById indicates an expected call of FindById.
func (mr *MockUserServiceMockRecorder) FindById(userID interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FindById", reflect.TypeOf((*MockUserService)(nil).FindById), userID)
}</span>

// Grant mocks base method.
func (m *MockUserService) Grant(userID string, permissions []string) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Grant", userID, permissions)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Grant indicates an expected call of Grant.
func (mr *MockUserServiceMockRecorder) Grant(userID, permissions interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Grant", reflect.TypeOf((*MockUserService)(nil).Grant), userID, permissions)
}</span>

// Granted mocks base method.
func (m *MockUserService) Granted(userID, permission string) bool <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Granted", userID, permission)
        ret0, _ := ret[0].(bool)
        return ret0
}</span>

// Granted indicates an expected call of Granted.
func (mr *MockUserServiceMockRecorder) Granted(userID, permission interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Granted", reflect.TypeOf((*MockUserService)(nil).Granted), userID, permission)
}</span>

// New mocks base method.
func (m *MockUserService) New(login, name, password string) (*user.UserData, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "New", login, name, password)
        ret0, _ := ret[0].(*user.UserData)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// New indicates an expected call of New.
func (mr *MockUserServiceMockRecorder) New(login, name, password interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "New", reflect.TypeOf((*MockUserService)(nil).New), login, name, password)
}</span>

// Revoke mocks base method.
func (m *MockUserService) Revoke(userID string, permissions []string) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Revoke", userID, permissions)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Revoke indicates an expected call of Revoke.
func (mr *MockUserServiceMockRecorder) Revoke(userID, permissions interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Revoke", reflect.TypeOf((*MockUserService)(nil).Revoke), userID, permissions)
}</span>

// SignIn mocks base method.
func (m *MockUserService) SignIn(login, password string) (*user.UserData, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "SignIn", login, password)
        ret0, _ := ret[0].(*user.UserData)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// SignIn indicates an expected call of SignIn.
func (mr *MockUserServiceMockRecorder) SignIn(login, password interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SignIn", reflect.TypeOf((*MockUserService)(nil).SignIn), login, password)
}</span>
</pre>
		
		<pre class="file" id="file78" style="display: none">package rabbit

import (
        "github.com/golang/mock/gomock"
        "github.com/nmarsollier/authgo/test/mock"
)

func DefaultMockRabbitChannel(ctrl *gomock.Controller, times int) *mock.MockRabbitChannel <span class="cov8" title="1">{
        channel := mock.NewMockRabbitChannel(ctrl)
        channel.EXPECT().ExchangeDeclare(gomock.Any(), gomock.Any()).Return(nil).Times(times)
        return channel
}</span>
</pre>
		
		<pre class="file" id="file79" style="display: none">package rest

import (
        "encoding/json"
        "net/http"
        "net/http/httptest"
        "testing"

        _ "github.com/nmarsollier/authgo/docs"
        "github.com/stretchr/testify/assert"
)

// Assertion Functions
func AssertUnauthorized(t *testing.T, w *httptest.ResponseRecorder) <span class="cov8" title="1">{
        assert.Equal(t, http.StatusUnauthorized, w.Code)

        var result map[string]interface{}
        json.Unmarshal(w.Body.Bytes(), &amp;result)

        assert.Equal(t, result["error"], "Unauthorized")
}</span>

func AssertDocumentNotFound(t *testing.T, w *httptest.ResponseRecorder) <span class="cov8" title="1">{
        assert.Equal(t, http.StatusNotFound, w.Code)

        var result map[string]interface{}
        json.Unmarshal(w.Body.Bytes(), &amp;result)
        assert.Equal(t, "Document not found", result["error"])
}</span>

func AssertInternalServerError(t *testing.T, w *httptest.ResponseRecorder) <span class="cov0" title="0">{
        assert.Equal(t, http.StatusInternalServerError, w.Code)
}</span>

func AssertBadRequestError(t *testing.T, w *httptest.ResponseRecorder) <span class="cov0" title="0">{
        assert.Equal(t, http.StatusBadRequest, w.Code)
}</span>
</pre>
		
		<pre class="file" id="file80" style="display: none">package rest

import (
        "github.com/gin-contrib/gzip"
        "github.com/gin-gonic/gin"
        "github.com/golang/mock/gomock"
        _ "github.com/nmarsollier/authgo/docs"
        "github.com/nmarsollier/authgo/internal/engine/di"
        "github.com/nmarsollier/authgo/internal/rest/server"
)

func TestRouter(ctrl *gomock.Controller, deps di.Injector) *gin.Engine <span class="cov8" title="1">{
        engine := gin.Default()
        engine.Use(func(c *gin.Context) </span><span class="cov8" title="1">{
                c.Set("di", deps)
                c.Next()
        }</span>)

        <span class="cov8" title="1">engine.Use(gzip.Gzip(gzip.DefaultCompression))
        engine.Use(server.DiInjectorMiddleware())
        engine.Use(server.ErrorHandler)

        return engine</span>
}
</pre>
		
		<pre class="file" id="file81" style="display: none">package rest

import (
        "bytes"
        "encoding/json"
        "net/http"
        "net/http/httptest"

        _ "github.com/nmarsollier/authgo/docs"
)

// Requests Test functions
func TestGetRequest(url string, tokenString string) (*http.Request, *httptest.ResponseRecorder) <span class="cov8" title="1">{
        req, _ := http.NewRequest("GET", url, bytes.NewBuffer([]byte{}))
        if len(tokenString) &gt; 0 </span><span class="cov8" title="1">{
                req.Header.Add("Authorization", "Bearer "+tokenString)
        }</span>
        <span class="cov8" title="1">w := httptest.NewRecorder()
        return req, w</span>
}

func TestPostRequest(url string, body interface{}, tokenString string) (*http.Request, *httptest.ResponseRecorder) <span class="cov0" title="0">{
        jsonBody, _ := json.Marshal(body)

        req, _ := http.NewRequest("POST", url, bytes.NewBuffer(jsonBody))
        if len(tokenString) &gt; 0 </span><span class="cov0" title="0">{
                req.Header.Add("Authorization", "Bearer "+tokenString)
        }</span>
        <span class="cov0" title="0">w := httptest.NewRecorder()
        return req, w</span>
}
</pre>
		
		<pre class="file" id="file82" style="display: none">package token

import (
        "testing"

        gomock "github.com/golang/mock/gomock"
        "github.com/nmarsollier/authgo/internal/token"
        "github.com/nmarsollier/authgo/test/mock"
        "github.com/stretchr/testify/assert"
        "go.mongodb.org/mongo-driver/bson/primitive"
)

func TestToken() (*token.Token, string) <span class="cov8" title="1">{
        tokenData := &amp;token.Token{
                ID:      primitive.NewObjectID(),
                UserID:  primitive.NewObjectID(),
                Enabled: true,
        }

        tokenString, _ := token.Encode(tokenData)

        return tokenData, tokenString
}</span>

func ExpectTokenFindOne(coll *mock.MockCollection, tokenData *token.Token, times int) <span class="cov0" title="0">{
        coll.EXPECT().FindOne(gomock.Any(), gomock.Any(), gomock.Any()).DoAndReturn(
                func(arg1 interface{}, params token.DbTokenIdFilter, token *token.Token) error </span><span class="cov0" title="0">{
                        // Asign return values
                        *token = *tokenData
                        return nil
                }</span>,
        ).Times(times)
}

func ExpectTokenAuthFindOne(t *testing.T, coll *mock.MockCollection, tokenData *token.Token) <span class="cov8" title="1">{
        coll.EXPECT().FindOne(gomock.Any(), gomock.Any(), gomock.Any()).DoAndReturn(
                func(arg1 interface{}, tokenIdUpdate token.DbTokenIdFilter, token *token.Token) error </span><span class="cov8" title="1">{
                        assert.Equal(t, tokenData.ID, tokenIdUpdate.ID)

                        *token = *tokenData
                        return nil
                }</span>,
        ).Times(1)
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
